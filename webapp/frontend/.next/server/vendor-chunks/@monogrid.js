"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@monogrid";
exports.ids = ["vendor-chunks/@monogrid"];
exports.modules = {

/***/ "(ssr)/./node_modules/@monogrid/gainmap-js/dist/Loader-DLI-_JDP.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@monogrid/gainmap-js/dist/Loader-DLI-_JDP.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   G: () => (/* binding */ GainMapNotFoundError),\n/* harmony export */   L: () => (/* binding */ LoaderBaseShared),\n/* harmony export */   M: () => (/* binding */ MPFExtractor),\n/* harmony export */   X: () => (/* binding */ XMPMetadataNotFoundError),\n/* harmony export */   a: () => (/* binding */ extractXMP),\n/* harmony export */   c: () => (/* binding */ createDecodeFunction),\n/* harmony export */   e: () => (/* binding */ extractGainmapFromJPEG)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n/**\n * @monogrid/gainmap-js v3.4.0\n * With ‚ù§Ô∏è, by MONOGRID <gainmap@monogrid.com>\n */ \n/**\n * Shared decode implementation factory\n * Creates a decode function that prepares a QuadRenderer with the given parameters\n */ function createDecodeFunction(config) {\n    return (params)=>{\n        const { sdr, gainMap, renderer } = params;\n        if (sdr.colorSpace !== three__WEBPACK_IMPORTED_MODULE_0__.SRGBColorSpace) {\n            console.warn(\"SDR Colorspace needs to be *SRGBColorSpace*, setting it automatically\");\n            sdr.colorSpace = three__WEBPACK_IMPORTED_MODULE_0__.SRGBColorSpace;\n        }\n        sdr.needsUpdate = true;\n        if (gainMap.colorSpace !== three__WEBPACK_IMPORTED_MODULE_0__.LinearSRGBColorSpace) {\n            console.warn(\"Gainmap Colorspace needs to be *LinearSRGBColorSpace*, setting it automatically\");\n            gainMap.colorSpace = three__WEBPACK_IMPORTED_MODULE_0__.LinearSRGBColorSpace;\n        }\n        gainMap.needsUpdate = true;\n        const material = config.createMaterial({\n            ...params,\n            sdr,\n            gainMap\n        });\n        const quadRenderer = config.createQuadRenderer({\n            width: sdr.image.width,\n            height: sdr.image.height,\n            type: three__WEBPACK_IMPORTED_MODULE_0__.HalfFloatType,\n            colorSpace: three__WEBPACK_IMPORTED_MODULE_0__.LinearSRGBColorSpace,\n            material,\n            renderer,\n            renderTargetOptions: params.renderTargetOptions\n        });\n        return quadRenderer;\n    };\n}\nclass GainMapNotFoundError extends Error {\n}\nclass XMPMetadataNotFoundError extends Error {\n}\nconst getXMLValue = (xml, tag, defaultValue)=>{\n    // Check for attribute format first: tag=\"value\"\n    const attributeMatch = new RegExp(`${tag}=\"([^\"]*)\"`, \"i\").exec(xml);\n    if (attributeMatch) return attributeMatch[1];\n    // Check for tag format: <tag>value</tag> or <tag><rdf:li>value</rdf:li>...</tag>\n    const tagMatch = new RegExp(`<${tag}[^>]*>([\\\\s\\\\S]*?)</${tag}>`, \"i\").exec(xml);\n    if (tagMatch) {\n        // Check if it contains rdf:li elements\n        const liValues = tagMatch[1].match(/<rdf:li>([^<]*)<\\/rdf:li>/g);\n        if (liValues && liValues.length === 3) {\n            return liValues.map((v)=>v.replace(/<\\/?rdf:li>/g, \"\"));\n        }\n        return tagMatch[1].trim();\n    }\n    if (defaultValue !== undefined) return defaultValue;\n    throw new Error(`Can't find ${tag} in gainmap metadata`);\n};\nconst extractXMP = (input)=>{\n    let str;\n    // support node test environment\n    if (typeof TextDecoder !== \"undefined\") str = new TextDecoder().decode(input);\n    else str = input.toString();\n    let start = str.indexOf(\"<x:xmpmeta\");\n    while(start !== -1){\n        const end = str.indexOf(\"x:xmpmeta>\", start);\n        const xmpBlock = str.slice(start, end + 10);\n        try {\n            const gainMapMin = getXMLValue(xmpBlock, \"hdrgm:GainMapMin\", \"0\");\n            const gainMapMax = getXMLValue(xmpBlock, \"hdrgm:GainMapMax\");\n            const gamma = getXMLValue(xmpBlock, \"hdrgm:Gamma\", \"1\");\n            const offsetSDR = getXMLValue(xmpBlock, \"hdrgm:OffsetSDR\", \"0.015625\");\n            const offsetHDR = getXMLValue(xmpBlock, \"hdrgm:OffsetHDR\", \"0.015625\");\n            // These are always attributes, so we can use a simpler regex\n            const hdrCapacityMinMatch = /hdrgm:HDRCapacityMin=\"([^\"]*)\"/.exec(xmpBlock);\n            const hdrCapacityMin = hdrCapacityMinMatch ? hdrCapacityMinMatch[1] : \"0\";\n            const hdrCapacityMaxMatch = /hdrgm:HDRCapacityMax=\"([^\"]*)\"/.exec(xmpBlock);\n            if (!hdrCapacityMaxMatch) throw new Error(\"Incomplete gainmap metadata\");\n            const hdrCapacityMax = hdrCapacityMaxMatch[1];\n            return {\n                gainMapMin: Array.isArray(gainMapMin) ? gainMapMin.map((v)=>parseFloat(v)) : [\n                    parseFloat(gainMapMin),\n                    parseFloat(gainMapMin),\n                    parseFloat(gainMapMin)\n                ],\n                gainMapMax: Array.isArray(gainMapMax) ? gainMapMax.map((v)=>parseFloat(v)) : [\n                    parseFloat(gainMapMax),\n                    parseFloat(gainMapMax),\n                    parseFloat(gainMapMax)\n                ],\n                gamma: Array.isArray(gamma) ? gamma.map((v)=>parseFloat(v)) : [\n                    parseFloat(gamma),\n                    parseFloat(gamma),\n                    parseFloat(gamma)\n                ],\n                offsetSdr: Array.isArray(offsetSDR) ? offsetSDR.map((v)=>parseFloat(v)) : [\n                    parseFloat(offsetSDR),\n                    parseFloat(offsetSDR),\n                    parseFloat(offsetSDR)\n                ],\n                offsetHdr: Array.isArray(offsetHDR) ? offsetHDR.map((v)=>parseFloat(v)) : [\n                    parseFloat(offsetHDR),\n                    parseFloat(offsetHDR),\n                    parseFloat(offsetHDR)\n                ],\n                hdrCapacityMin: parseFloat(hdrCapacityMin),\n                hdrCapacityMax: parseFloat(hdrCapacityMax)\n            };\n        } catch (e) {\n        // Continue searching for another xmpmeta block if this one fails\n        }\n        start = str.indexOf(\"<x:xmpmeta\", end);\n    }\n};\n/**\n * MPF Extractor (Multi Picture Format Extractor)\n * By Henrik S Nilsson 2019\n *\n * Extracts images stored in images based on the MPF format (found here: https://www.cipa.jp/e/std/std-sec.html\n * under \"CIPA DC-007-Translation-2021 Multi-Picture Format\"\n *\n * Overly commented, and without intention of being complete or production ready.\n * Created to extract depth maps from iPhone images, and to learn about image metadata.\n * Kudos to: Phil Harvey (exiftool), Jaume Sanchez (android-lens-blur-depth-extractor)\n */ class MPFExtractor {\n    constructor(options){\n        this.options = {\n            debug: options && options.debug !== undefined ? options.debug : false,\n            extractFII: options && options.extractFII !== undefined ? options.extractFII : true,\n            extractNonFII: options && options.extractNonFII !== undefined ? options.extractNonFII : true\n        };\n    }\n    extract(imageArrayBuffer) {\n        return new Promise((resolve, reject)=>{\n            const debug = this.options.debug;\n            const dataView = new DataView(imageArrayBuffer.buffer);\n            // If you're executing this line on a big endian machine, it'll be reversed.\n            // bigEnd further down though, refers to the endianness of the image itself.\n            if (dataView.getUint16(0) !== 0xffd8) {\n                reject(new Error(\"Not a valid jpeg\"));\n                return;\n            }\n            const length = dataView.byteLength;\n            let offset = 2;\n            let loops = 0;\n            let marker; // APP# marker\n            while(offset < length){\n                if (++loops > 250) {\n                    reject(new Error(`Found no marker after ${loops} loops üòµ`));\n                    return;\n                }\n                if (dataView.getUint8(offset) !== 0xff) {\n                    reject(new Error(`Not a valid marker at offset 0x${offset.toString(16)}, found: 0x${dataView.getUint8(offset).toString(16)}`));\n                    return;\n                }\n                marker = dataView.getUint8(offset + 1);\n                if (debug) console.log(`Marker: ${marker.toString(16)}`);\n                if (marker === 0xe2) {\n                    if (debug) console.log(\"Found APP2 marker (0xffe2)\");\n                    // Works for iPhone 8 Plus, X, and XSMax. Or any photos of MPF format.\n                    // Great way to visualize image information in html is using Exiftool. E.g.:\n                    // ./exiftool.exe -htmldump -wantTrailer photo.jpg > photo.html\n                    const formatPt = offset + 4;\n                    /*\n                     *  Structure of the MP Format Identifier\n                     *\n                     *  Offset Addr.  | Code (Hex)  | Description\n                     *  +00             ff            Marker Prefix      <-- offset\n                     *  +01             e2            APP2\n                     *  +02             #n            APP2 Field Length\n                     *  +03             #n            APP2 Field Length\n                     *  +04             4d            'M'                <-- formatPt\n                     *  +05             50            'P'\n                     *  +06             46            'F'\n                     *  +07             00            NULL\n                     *                                                   <-- tiffOffset\n                     */ if (dataView.getUint32(formatPt) === 0x4d504600) {\n                        // Found MPF tag, so we start dig out sub images\n                        const tiffOffset = formatPt + 4;\n                        let bigEnd; // Endianness from TIFF header\n                        // Test for TIFF validity and endianness\n                        // 0x4949 and 0x4D4D ('II' and 'MM') marks Little Endian and Big Endian\n                        if (dataView.getUint16(tiffOffset) === 0x4949) {\n                            bigEnd = false;\n                        } else if (dataView.getUint16(tiffOffset) === 0x4d4d) {\n                            bigEnd = true;\n                        } else {\n                            reject(new Error(\"No valid endianness marker found in TIFF header\"));\n                            return;\n                        }\n                        if (dataView.getUint16(tiffOffset + 2, !bigEnd) !== 0x002a) {\n                            reject(new Error(\"Not valid TIFF data! (no 0x002A marker)\"));\n                            return;\n                        }\n                        // 32 bit number stating the offset from the start of the 8 Byte MP Header\n                        // to MP Index IFD Least possible value is thus 8 (means 0 offset)\n                        const firstIFDOffset = dataView.getUint32(tiffOffset + 4, !bigEnd);\n                        if (firstIFDOffset < 0x00000008) {\n                            reject(new Error(\"Not valid TIFF data! (First offset less than 8)\"));\n                            return;\n                        }\n                        // Move ahead to MP Index IFD\n                        // Assume we're at the first IFD, so firstIFDOffset points to\n                        // MP Index IFD and not MP Attributes IFD. (If we try extract from a sub image,\n                        // we fail silently here due to this assumption)\n                        // Count (2 Byte) | MP Index Fields a.k.a. MP Entries (count * 12 Byte) | Offset of Next IFD (4 Byte)\n                        const dirStart = tiffOffset + firstIFDOffset; // Start of IFD (Image File Directory)\n                        const count = dataView.getUint16(dirStart, !bigEnd); // Count of MPEntries (2 Byte)\n                        // Extract info from MPEntries (starting after Count)\n                        const entriesStart = dirStart + 2;\n                        let numberOfImages = 0;\n                        for(let i = entriesStart; i < entriesStart + 12 * count; i += 12){\n                            // Each entry is 12 Bytes long\n                            // Check MP Index IFD tags, here we only take tag 0xb001 = Number of images\n                            if (dataView.getUint16(i, !bigEnd) === 0xb001) {\n                                // stored in Last 4 bytes of its 12 Byte entry.\n                                numberOfImages = dataView.getUint32(i + 8, !bigEnd);\n                            }\n                        }\n                        const nextIFDOffsetLen = 4; // 4 Byte offset field that appears after MP Index IFD tags\n                        const MPImageListValPt = dirStart + 2 + count * 12 + nextIFDOffsetLen;\n                        const images = [];\n                        for(let i = MPImageListValPt; i < MPImageListValPt + numberOfImages * 16; i += 16){\n                            const image = {\n                                MPType: dataView.getUint32(i, !bigEnd),\n                                size: dataView.getUint32(i + 4, !bigEnd),\n                                // This offset is specified relative to the address of the MP Endian\n                                // field in the MP Header, unless the image is a First Individual Image,\n                                // in which case the value of the offset shall be NULL (0x00000000).\n                                dataOffset: dataView.getUint32(i + 8, !bigEnd),\n                                dependantImages: dataView.getUint32(i + 12, !bigEnd),\n                                start: -1,\n                                end: -1,\n                                isFII: false\n                            };\n                            if (!image.dataOffset) {\n                                // dataOffset is 0x00000000 for First Individual Image\n                                image.start = 0;\n                                image.isFII = true;\n                            } else {\n                                image.start = tiffOffset + image.dataOffset;\n                                image.isFII = false;\n                            }\n                            image.end = image.start + image.size;\n                            images.push(image);\n                        }\n                        if (this.options.extractNonFII && images.length) {\n                            const bufferBlob = new Blob([\n                                dataView\n                            ]);\n                            const imgs = [];\n                            for (const image of images){\n                                if (image.isFII && !this.options.extractFII) {\n                                    continue; // Skip FII\n                                }\n                                const imageBlob = bufferBlob.slice(image.start, image.end + 1, \"image/jpeg\");\n                                // we don't need this\n                                // const imageUrl = URL.createObjectURL(imageBlob)\n                                // image.img = document.createElement('img')\n                                // image.img.src = imageUrl\n                                imgs.push(imageBlob);\n                            }\n                            resolve(imgs);\n                        }\n                    }\n                }\n                offset += 2 + dataView.getUint16(offset + 2);\n            }\n        });\n    }\n}\n/**\n * Extracts XMP Metadata and the gain map recovery image\n * from a single JPEG file.\n *\n * @category Decoding Functions\n * @group Decoding Functions\n * @param jpegFile an `Uint8Array` containing and encoded JPEG file\n * @returns an sdr `Uint8Array` compressed in JPEG, a gainMap `Uint8Array` compressed in JPEG and the XMP parsed XMP metadata\n * @throws Error if XMP Metadata is not found\n * @throws Error if Gain map image is not found\n * @example\n * import { FileLoader } from 'three'\n * import { extractGainmapFromJPEG } from '@monogrid/gainmap-js'\n *\n * const jpegFile = await new FileLoader()\n *  .setResponseType('arraybuffer')\n *  .loadAsync('image.jpg')\n *\n * const { sdr, gainMap, metadata } = extractGainmapFromJPEG(jpegFile)\n */ const extractGainmapFromJPEG = async (jpegFile)=>{\n    const metadata = extractXMP(jpegFile);\n    if (!metadata) throw new XMPMetadataNotFoundError(\"Gain map XMP metadata not found\");\n    const mpfExtractor = new MPFExtractor({\n        extractFII: true,\n        extractNonFII: true\n    });\n    const images = await mpfExtractor.extract(jpegFile);\n    if (images.length !== 2) throw new GainMapNotFoundError(\"Gain map recovery image not found\");\n    return {\n        sdr: new Uint8Array(await images[0].arrayBuffer()),\n        gainMap: new Uint8Array(await images[1].arrayBuffer()),\n        metadata\n    };\n};\n/**\n * private function, async get image from blob\n *\n * @param blob\n * @returns\n */ const getHTMLImageFromBlob = (blob)=>{\n    return new Promise((resolve, reject)=>{\n        const img = document.createElement(\"img\");\n        img.onload = ()=>{\n            resolve(img);\n        };\n        // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\n        img.onerror = (e)=>{\n            reject(e);\n        };\n        img.src = URL.createObjectURL(blob);\n    });\n};\n/**\n * Shared base class for loaders that extracts common logic\n */ class LoaderBaseShared extends three__WEBPACK_IMPORTED_MODULE_0__.Loader {\n    constructor(config, manager){\n        super(manager);\n        this._config = config;\n        if (config.renderer) this._renderer = config.renderer;\n        this._internalLoadingManager = new three__WEBPACK_IMPORTED_MODULE_0__.LoadingManager();\n    }\n    setRenderer(renderer) {\n        this._renderer = renderer;\n        return this;\n    }\n    setRenderTargetOptions(options) {\n        this._renderTargetOptions = options;\n        return this;\n    }\n    prepareQuadRenderer() {\n        if (!this._renderer) {\n            console.warn(\"WARNING: A Renderer was not passed to this Loader constructor or in setRenderer, the result of this Loader will need to be converted to a Data Texture with toDataTexture() before you can use it in your renderer.\");\n        }\n        const material = this._config.createMaterial({\n            gainMapMax: [\n                1,\n                1,\n                1\n            ],\n            gainMapMin: [\n                0,\n                0,\n                0\n            ],\n            gamma: [\n                1,\n                1,\n                1\n            ],\n            offsetHdr: [\n                1,\n                1,\n                1\n            ],\n            offsetSdr: [\n                1,\n                1,\n                1\n            ],\n            hdrCapacityMax: 1,\n            hdrCapacityMin: 0,\n            maxDisplayBoost: 1,\n            gainMap: new three__WEBPACK_IMPORTED_MODULE_0__.Texture(),\n            sdr: new three__WEBPACK_IMPORTED_MODULE_0__.Texture()\n        });\n        return this._config.createQuadRenderer({\n            width: 16,\n            height: 16,\n            type: three__WEBPACK_IMPORTED_MODULE_0__.HalfFloatType,\n            colorSpace: three__WEBPACK_IMPORTED_MODULE_0__.LinearSRGBColorSpace,\n            material,\n            renderer: this._renderer,\n            renderTargetOptions: this._renderTargetOptions\n        });\n    }\n    async processImages(sdrBuffer, gainMapBuffer, imageOrientation) {\n        const gainMapBlob = gainMapBuffer ? new Blob([\n            gainMapBuffer\n        ], {\n            type: \"image/jpeg\"\n        }) : undefined;\n        const sdrBlob = new Blob([\n            sdrBuffer\n        ], {\n            type: \"image/jpeg\"\n        });\n        let sdrImage;\n        let gainMapImage;\n        let needsFlip = false;\n        if (typeof createImageBitmap === \"undefined\") {\n            const res = await Promise.all([\n                gainMapBlob ? getHTMLImageFromBlob(gainMapBlob) : Promise.resolve(undefined),\n                getHTMLImageFromBlob(sdrBlob)\n            ]);\n            gainMapImage = res[0];\n            sdrImage = res[1];\n            needsFlip = imageOrientation === \"flipY\";\n        } else {\n            const res = await Promise.all([\n                gainMapBlob ? createImageBitmap(gainMapBlob, {\n                    imageOrientation: imageOrientation || \"flipY\"\n                }) : Promise.resolve(undefined),\n                createImageBitmap(sdrBlob, {\n                    imageOrientation: imageOrientation || \"flipY\"\n                })\n            ]);\n            gainMapImage = res[0];\n            sdrImage = res[1];\n        }\n        return {\n            sdrImage,\n            gainMapImage,\n            needsFlip\n        };\n    }\n    createTextures(sdrImage, gainMapImage, needsFlip) {\n        const gainMap = new three__WEBPACK_IMPORTED_MODULE_0__.Texture(gainMapImage || new ImageData(2, 2), three__WEBPACK_IMPORTED_MODULE_0__.UVMapping, three__WEBPACK_IMPORTED_MODULE_0__.ClampToEdgeWrapping, three__WEBPACK_IMPORTED_MODULE_0__.ClampToEdgeWrapping, three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter, three__WEBPACK_IMPORTED_MODULE_0__.LinearMipMapLinearFilter, three__WEBPACK_IMPORTED_MODULE_0__.RGBAFormat, three__WEBPACK_IMPORTED_MODULE_0__.UnsignedByteType, 1, three__WEBPACK_IMPORTED_MODULE_0__.LinearSRGBColorSpace);\n        gainMap.flipY = needsFlip;\n        gainMap.needsUpdate = true;\n        const sdr = new three__WEBPACK_IMPORTED_MODULE_0__.Texture(sdrImage, three__WEBPACK_IMPORTED_MODULE_0__.UVMapping, three__WEBPACK_IMPORTED_MODULE_0__.ClampToEdgeWrapping, three__WEBPACK_IMPORTED_MODULE_0__.ClampToEdgeWrapping, three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter, three__WEBPACK_IMPORTED_MODULE_0__.LinearMipMapLinearFilter, three__WEBPACK_IMPORTED_MODULE_0__.RGBAFormat, three__WEBPACK_IMPORTED_MODULE_0__.UnsignedByteType, 1, three__WEBPACK_IMPORTED_MODULE_0__.SRGBColorSpace);\n        sdr.flipY = needsFlip;\n        sdr.needsUpdate = true;\n        return {\n            gainMap,\n            sdr\n        };\n    }\n    updateQuadRenderer(quadRenderer, sdrImage, gainMap, sdr, metadata) {\n        quadRenderer.width = sdrImage.width;\n        quadRenderer.height = sdrImage.height;\n        quadRenderer.material.gainMap = gainMap;\n        quadRenderer.material.sdr = sdr;\n        quadRenderer.material.gainMapMin = metadata.gainMapMin;\n        quadRenderer.material.gainMapMax = metadata.gainMapMax;\n        quadRenderer.material.offsetHdr = metadata.offsetHdr;\n        quadRenderer.material.offsetSdr = metadata.offsetSdr;\n        quadRenderer.material.gamma = metadata.gamma;\n        quadRenderer.material.hdrCapacityMin = metadata.hdrCapacityMin;\n        quadRenderer.material.hdrCapacityMax = metadata.hdrCapacityMax;\n        quadRenderer.material.maxDisplayBoost = Math.pow(2, metadata.hdrCapacityMax);\n        quadRenderer.material.needsUpdate = true;\n    }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1vbm9ncmlkL2dhaW5tYXAtanMvZGlzdC9Mb2FkZXItRExJLV9KRFAuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTs7O0NBR0MsR0FFa047QUFFbk47OztDQUdDLEdBQ0QsU0FBU1kscUJBQXFCQyxNQUFNO0lBQ2hDLE9BQU8sQ0FBQ0M7UUFDSixNQUFNLEVBQUVDLEdBQUcsRUFBRUMsT0FBTyxFQUFFQyxRQUFRLEVBQUUsR0FBR0g7UUFDbkMsSUFBSUMsSUFBSUcsVUFBVSxLQUFLbEIsaURBQWNBLEVBQUU7WUFDbkNtQixRQUFRQyxJQUFJLENBQUM7WUFDYkwsSUFBSUcsVUFBVSxHQUFHbEIsaURBQWNBO1FBQ25DO1FBQ0FlLElBQUlNLFdBQVcsR0FBRztRQUNsQixJQUFJTCxRQUFRRSxVQUFVLEtBQUtqQix1REFBb0JBLEVBQUU7WUFDN0NrQixRQUFRQyxJQUFJLENBQUM7WUFDYkosUUFBUUUsVUFBVSxHQUFHakIsdURBQW9CQTtRQUM3QztRQUNBZSxRQUFRSyxXQUFXLEdBQUc7UUFDdEIsTUFBTUMsV0FBV1QsT0FBT1UsY0FBYyxDQUFDO1lBQ25DLEdBQUdULE1BQU07WUFDVEM7WUFDQUM7UUFDSjtRQUNBLE1BQU1RLGVBQWVYLE9BQU9ZLGtCQUFrQixDQUFDO1lBQzNDQyxPQUFPWCxJQUFJWSxLQUFLLENBQUNELEtBQUs7WUFDdEJFLFFBQVFiLElBQUlZLEtBQUssQ0FBQ0MsTUFBTTtZQUN4QkMsTUFBTTNCLGdEQUFhQTtZQUNuQmdCLFlBQVlqQix1REFBb0JBO1lBQ2hDcUI7WUFDQUw7WUFDQWEscUJBQXFCaEIsT0FBT2dCLG1CQUFtQjtRQUNuRDtRQUNBLE9BQU9OO0lBQ1g7QUFDSjtBQUVBLE1BQU1PLDZCQUE2QkM7QUFDbkM7QUFFQSxNQUFNQyxpQ0FBaUNEO0FBQ3ZDO0FBRUEsTUFBTUUsY0FBYyxDQUFDQyxLQUFLQyxLQUFLQztJQUMzQixnREFBZ0Q7SUFDaEQsTUFBTUMsaUJBQWlCLElBQUlDLE9BQU8sQ0FBQyxFQUFFSCxJQUFJLFVBQVUsQ0FBQyxFQUFFLEtBQUtJLElBQUksQ0FBQ0w7SUFDaEUsSUFBSUcsZ0JBQ0EsT0FBT0EsY0FBYyxDQUFDLEVBQUU7SUFDNUIsaUZBQWlGO0lBQ2pGLE1BQU1HLFdBQVcsSUFBSUYsT0FBTyxDQUFDLENBQUMsRUFBRUgsSUFBSSxvQkFBb0IsRUFBRUEsSUFBSSxDQUFDLENBQUMsRUFBRSxLQUFLSSxJQUFJLENBQUNMO0lBQzVFLElBQUlNLFVBQVU7UUFDVix1Q0FBdUM7UUFDdkMsTUFBTUMsV0FBV0QsUUFBUSxDQUFDLEVBQUUsQ0FBQ0UsS0FBSyxDQUFDO1FBQ25DLElBQUlELFlBQVlBLFNBQVNFLE1BQU0sS0FBSyxHQUFHO1lBQ25DLE9BQU9GLFNBQVNHLEdBQUcsQ0FBQ0MsQ0FBQUEsSUFBS0EsRUFBRUMsT0FBTyxDQUFDLGdCQUFnQjtRQUN2RDtRQUNBLE9BQU9OLFFBQVEsQ0FBQyxFQUFFLENBQUNPLElBQUk7SUFDM0I7SUFDQSxJQUFJWCxpQkFBaUJZLFdBQ2pCLE9BQU9aO0lBQ1gsTUFBTSxJQUFJTCxNQUFNLENBQUMsV0FBVyxFQUFFSSxJQUFJLG9CQUFvQixDQUFDO0FBQzNEO0FBQ0EsTUFBTWMsYUFBYSxDQUFDQztJQUNoQixJQUFJQztJQUNKLGdDQUFnQztJQUNoQyxJQUFJLE9BQU9DLGdCQUFnQixhQUN2QkQsTUFBTSxJQUFJQyxjQUFjQyxNQUFNLENBQUNIO1NBRS9CQyxNQUFNRCxNQUFNSSxRQUFRO0lBQ3hCLElBQUlDLFFBQVFKLElBQUlLLE9BQU8sQ0FBQztJQUN4QixNQUFPRCxVQUFVLENBQUMsRUFBRztRQUNqQixNQUFNRSxNQUFNTixJQUFJSyxPQUFPLENBQUMsY0FBY0Q7UUFDdEMsTUFBTUcsV0FBV1AsSUFBSVEsS0FBSyxDQUFDSixPQUFPRSxNQUFNO1FBQ3hDLElBQUk7WUFDQSxNQUFNRyxhQUFhM0IsWUFBWXlCLFVBQVUsb0JBQW9CO1lBQzdELE1BQU1HLGFBQWE1QixZQUFZeUIsVUFBVTtZQUN6QyxNQUFNSSxRQUFRN0IsWUFBWXlCLFVBQVUsZUFBZTtZQUNuRCxNQUFNSyxZQUFZOUIsWUFBWXlCLFVBQVUsbUJBQW1CO1lBQzNELE1BQU1NLFlBQVkvQixZQUFZeUIsVUFBVSxtQkFBbUI7WUFDM0QsNkRBQTZEO1lBQzdELE1BQU1PLHNCQUFzQixpQ0FBaUMxQixJQUFJLENBQUNtQjtZQUNsRSxNQUFNUSxpQkFBaUJELHNCQUFzQkEsbUJBQW1CLENBQUMsRUFBRSxHQUFHO1lBQ3RFLE1BQU1FLHNCQUFzQixpQ0FBaUM1QixJQUFJLENBQUNtQjtZQUNsRSxJQUFJLENBQUNTLHFCQUNELE1BQU0sSUFBSXBDLE1BQU07WUFDcEIsTUFBTXFDLGlCQUFpQkQsbUJBQW1CLENBQUMsRUFBRTtZQUM3QyxPQUFPO2dCQUNIUCxZQUFZUyxNQUFNQyxPQUFPLENBQUNWLGNBQWNBLFdBQVdoQixHQUFHLENBQUNDLENBQUFBLElBQUswQixXQUFXMUIsTUFBTTtvQkFBQzBCLFdBQVdYO29CQUFhVyxXQUFXWDtvQkFBYVcsV0FBV1g7aUJBQVk7Z0JBQ3JKQyxZQUFZUSxNQUFNQyxPQUFPLENBQUNULGNBQWNBLFdBQVdqQixHQUFHLENBQUNDLENBQUFBLElBQUswQixXQUFXMUIsTUFBTTtvQkFBQzBCLFdBQVdWO29CQUFhVSxXQUFXVjtvQkFBYVUsV0FBV1Y7aUJBQVk7Z0JBQ3JKQyxPQUFPTyxNQUFNQyxPQUFPLENBQUNSLFNBQVNBLE1BQU1sQixHQUFHLENBQUNDLENBQUFBLElBQUswQixXQUFXMUIsTUFBTTtvQkFBQzBCLFdBQVdUO29CQUFRUyxXQUFXVDtvQkFBUVMsV0FBV1Q7aUJBQU87Z0JBQ3ZIVSxXQUFXSCxNQUFNQyxPQUFPLENBQUNQLGFBQWFBLFVBQVVuQixHQUFHLENBQUNDLENBQUFBLElBQUswQixXQUFXMUIsTUFBTTtvQkFBQzBCLFdBQVdSO29CQUFZUSxXQUFXUjtvQkFBWVEsV0FBV1I7aUJBQVc7Z0JBQy9JVSxXQUFXSixNQUFNQyxPQUFPLENBQUNOLGFBQWFBLFVBQVVwQixHQUFHLENBQUNDLENBQUFBLElBQUswQixXQUFXMUIsTUFBTTtvQkFBQzBCLFdBQVdQO29CQUFZTyxXQUFXUDtvQkFBWU8sV0FBV1A7aUJBQVc7Z0JBQy9JRSxnQkFBZ0JLLFdBQVdMO2dCQUMzQkUsZ0JBQWdCRyxXQUFXSDtZQUMvQjtRQUNKLEVBQ0EsT0FBT00sR0FBRztRQUNOLGlFQUFpRTtRQUNyRTtRQUNBbkIsUUFBUUosSUFBSUssT0FBTyxDQUFDLGNBQWNDO0lBQ3RDO0FBQ0o7QUFFQTs7Ozs7Ozs7OztDQVVDLEdBQ0QsTUFBTWtCO0lBRUZDLFlBQVlDLE9BQU8sQ0FBRTtRQUNqQixJQUFJLENBQUNBLE9BQU8sR0FBRztZQUNYQyxPQUFPRCxXQUFXQSxRQUFRQyxLQUFLLEtBQUs5QixZQUFZNkIsUUFBUUMsS0FBSyxHQUFHO1lBQ2hFQyxZQUFZRixXQUFXQSxRQUFRRSxVQUFVLEtBQUsvQixZQUFZNkIsUUFBUUUsVUFBVSxHQUFHO1lBQy9FQyxlQUFlSCxXQUFXQSxRQUFRRyxhQUFhLEtBQUtoQyxZQUFZNkIsUUFBUUcsYUFBYSxHQUFHO1FBQzVGO0lBQ0o7SUFDQUMsUUFBUUMsZ0JBQWdCLEVBQUU7UUFDdEIsT0FBTyxJQUFJQyxRQUFRLENBQUNDLFNBQVNDO1lBQ3pCLE1BQU1QLFFBQVEsSUFBSSxDQUFDRCxPQUFPLENBQUNDLEtBQUs7WUFDaEMsTUFBTVEsV0FBVyxJQUFJQyxTQUFTTCxpQkFBaUJNLE1BQU07WUFDckQsNEVBQTRFO1lBQzVFLDRFQUE0RTtZQUM1RSxJQUFJRixTQUFTRyxTQUFTLENBQUMsT0FBTyxRQUFRO2dCQUNsQ0osT0FBTyxJQUFJdEQsTUFBTTtnQkFDakI7WUFDSjtZQUNBLE1BQU1ZLFNBQVMyQyxTQUFTSSxVQUFVO1lBQ2xDLElBQUlDLFNBQVM7WUFDYixJQUFJQyxRQUFRO1lBQ1osSUFBSUMsUUFBUSxjQUFjO1lBQzFCLE1BQU9GLFNBQVNoRCxPQUFRO2dCQUNwQixJQUFJLEVBQUVpRCxRQUFRLEtBQUs7b0JBQ2ZQLE9BQU8sSUFBSXRELE1BQU0sQ0FBQyxzQkFBc0IsRUFBRTZELE1BQU0sU0FBUyxDQUFDO29CQUMxRDtnQkFDSjtnQkFDQSxJQUFJTixTQUFTUSxRQUFRLENBQUNILFlBQVksTUFBTTtvQkFDcENOLE9BQU8sSUFBSXRELE1BQU0sQ0FBQywrQkFBK0IsRUFBRTRELE9BQU9yQyxRQUFRLENBQUMsSUFBSSxXQUFXLEVBQUVnQyxTQUFTUSxRQUFRLENBQUNILFFBQVFyQyxRQUFRLENBQUMsSUFBSSxDQUFDO29CQUM1SDtnQkFDSjtnQkFDQXVDLFNBQVNQLFNBQVNRLFFBQVEsQ0FBQ0gsU0FBUztnQkFDcEMsSUFBSWIsT0FDQTVELFFBQVE2RSxHQUFHLENBQUMsQ0FBQyxRQUFRLEVBQUVGLE9BQU92QyxRQUFRLENBQUMsSUFBSSxDQUFDO2dCQUNoRCxJQUFJdUMsV0FBVyxNQUFNO29CQUNqQixJQUFJZixPQUNBNUQsUUFBUTZFLEdBQUcsQ0FBQztvQkFDaEIsc0VBQXNFO29CQUN0RSw0RUFBNEU7b0JBQzVFLCtEQUErRDtvQkFDL0QsTUFBTUMsV0FBV0wsU0FBUztvQkFDMUI7Ozs7Ozs7Ozs7Ozs7cUJBYUMsR0FDRCxJQUFJTCxTQUFTVyxTQUFTLENBQUNELGNBQWMsWUFBWTt3QkFDN0MsZ0RBQWdEO3dCQUNoRCxNQUFNRSxhQUFhRixXQUFXO3dCQUM5QixJQUFJRyxRQUFRLDhCQUE4Qjt3QkFDMUMsd0NBQXdDO3dCQUN4Qyx1RUFBdUU7d0JBQ3ZFLElBQUliLFNBQVNHLFNBQVMsQ0FBQ1MsZ0JBQWdCLFFBQVE7NEJBQzNDQyxTQUFTO3dCQUNiLE9BQ0ssSUFBSWIsU0FBU0csU0FBUyxDQUFDUyxnQkFBZ0IsUUFBUTs0QkFDaERDLFNBQVM7d0JBQ2IsT0FDSzs0QkFDRGQsT0FBTyxJQUFJdEQsTUFBTTs0QkFDakI7d0JBQ0o7d0JBQ0EsSUFBSXVELFNBQVNHLFNBQVMsQ0FBQ1MsYUFBYSxHQUFHLENBQUNDLFlBQVksUUFBUTs0QkFDeERkLE9BQU8sSUFBSXRELE1BQU07NEJBQ2pCO3dCQUNKO3dCQUNBLDBFQUEwRTt3QkFDMUUsa0VBQWtFO3dCQUNsRSxNQUFNcUUsaUJBQWlCZCxTQUFTVyxTQUFTLENBQUNDLGFBQWEsR0FBRyxDQUFDQzt3QkFDM0QsSUFBSUMsaUJBQWlCLFlBQVk7NEJBQzdCZixPQUFPLElBQUl0RCxNQUFNOzRCQUNqQjt3QkFDSjt3QkFDQSw2QkFBNkI7d0JBQzdCLDZEQUE2RDt3QkFDN0QsK0VBQStFO3dCQUMvRSxnREFBZ0Q7d0JBQ2hELHFHQUFxRzt3QkFDckcsTUFBTXNFLFdBQVdILGFBQWFFLGdCQUFnQixzQ0FBc0M7d0JBQ3BGLE1BQU1FLFFBQVFoQixTQUFTRyxTQUFTLENBQUNZLFVBQVUsQ0FBQ0YsU0FBUyw4QkFBOEI7d0JBQ25GLHFEQUFxRDt3QkFDckQsTUFBTUksZUFBZUYsV0FBVzt3QkFDaEMsSUFBSUcsaUJBQWlCO3dCQUNyQixJQUFLLElBQUlDLElBQUlGLGNBQWNFLElBQUlGLGVBQWUsS0FBS0QsT0FBT0csS0FBSyxHQUFJOzRCQUMvRCw4QkFBOEI7NEJBQzlCLDJFQUEyRTs0QkFDM0UsSUFBSW5CLFNBQVNHLFNBQVMsQ0FBQ2dCLEdBQUcsQ0FBQ04sWUFBWSxRQUFRO2dDQUMzQywrQ0FBK0M7Z0NBQy9DSyxpQkFBaUJsQixTQUFTVyxTQUFTLENBQUNRLElBQUksR0FBRyxDQUFDTjs0QkFDaEQ7d0JBQ0o7d0JBQ0EsTUFBTU8sbUJBQW1CLEdBQUcsMkRBQTJEO3dCQUN2RixNQUFNQyxtQkFBbUJOLFdBQVcsSUFBSUMsUUFBUSxLQUFLSTt3QkFDckQsTUFBTUUsU0FBUyxFQUFFO3dCQUNqQixJQUFLLElBQUlILElBQUlFLGtCQUFrQkYsSUFBSUUsbUJBQW1CSCxpQkFBaUIsSUFBSUMsS0FBSyxHQUFJOzRCQUNoRixNQUFNL0UsUUFBUTtnQ0FDVm1GLFFBQVF2QixTQUFTVyxTQUFTLENBQUNRLEdBQUcsQ0FBQ047Z0NBQy9CVyxNQUFNeEIsU0FBU1csU0FBUyxDQUFDUSxJQUFJLEdBQUcsQ0FBQ047Z0NBQ2pDLG9FQUFvRTtnQ0FDcEUsd0VBQXdFO2dDQUN4RSxvRUFBb0U7Z0NBQ3BFWSxZQUFZekIsU0FBU1csU0FBUyxDQUFDUSxJQUFJLEdBQUcsQ0FBQ047Z0NBQ3ZDYSxpQkFBaUIxQixTQUFTVyxTQUFTLENBQUNRLElBQUksSUFBSSxDQUFDTjtnQ0FDN0M1QyxPQUFPLENBQUM7Z0NBQ1JFLEtBQUssQ0FBQztnQ0FDTndELE9BQU87NEJBQ1g7NEJBQ0EsSUFBSSxDQUFDdkYsTUFBTXFGLFVBQVUsRUFBRTtnQ0FDbkIsc0RBQXNEO2dDQUN0RHJGLE1BQU02QixLQUFLLEdBQUc7Z0NBQ2Q3QixNQUFNdUYsS0FBSyxHQUFHOzRCQUNsQixPQUNLO2dDQUNEdkYsTUFBTTZCLEtBQUssR0FBRzJDLGFBQWF4RSxNQUFNcUYsVUFBVTtnQ0FDM0NyRixNQUFNdUYsS0FBSyxHQUFHOzRCQUNsQjs0QkFDQXZGLE1BQU0rQixHQUFHLEdBQUcvQixNQUFNNkIsS0FBSyxHQUFHN0IsTUFBTW9GLElBQUk7NEJBQ3BDRixPQUFPTSxJQUFJLENBQUN4Rjt3QkFDaEI7d0JBQ0EsSUFBSSxJQUFJLENBQUNtRCxPQUFPLENBQUNHLGFBQWEsSUFBSTRCLE9BQU9qRSxNQUFNLEVBQUU7NEJBQzdDLE1BQU13RSxhQUFhLElBQUlDLEtBQUs7Z0NBQUM5Qjs2QkFBUzs0QkFDdEMsTUFBTStCLE9BQU8sRUFBRTs0QkFDZixLQUFLLE1BQU0zRixTQUFTa0YsT0FBUTtnQ0FDeEIsSUFBSWxGLE1BQU11RixLQUFLLElBQUksQ0FBQyxJQUFJLENBQUNwQyxPQUFPLENBQUNFLFVBQVUsRUFBRTtvQ0FDekMsVUFBVSxXQUFXO2dDQUN6QjtnQ0FDQSxNQUFNdUMsWUFBWUgsV0FBV3hELEtBQUssQ0FBQ2pDLE1BQU02QixLQUFLLEVBQUU3QixNQUFNK0IsR0FBRyxHQUFHLEdBQUc7Z0NBQy9ELHFCQUFxQjtnQ0FDckIsa0RBQWtEO2dDQUNsRCw0Q0FBNEM7Z0NBQzVDLDJCQUEyQjtnQ0FDM0I0RCxLQUFLSCxJQUFJLENBQUNJOzRCQUNkOzRCQUNBbEMsUUFBUWlDO3dCQUNaO29CQUNKO2dCQUNKO2dCQUNBMUIsVUFBVSxJQUFJTCxTQUFTRyxTQUFTLENBQUNFLFNBQVM7WUFDOUM7UUFDSjtJQUNKO0FBQ0o7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQW1CQyxHQUNELE1BQU00Qix5QkFBeUIsT0FBT0M7SUFDbEMsTUFBTUMsV0FBV3hFLFdBQVd1RTtJQUM1QixJQUFJLENBQUNDLFVBQ0QsTUFBTSxJQUFJekYseUJBQXlCO0lBQ3ZDLE1BQU0wRixlQUFlLElBQUkvQyxhQUFhO1FBQUVJLFlBQVk7UUFBTUMsZUFBZTtJQUFLO0lBQzlFLE1BQU00QixTQUFTLE1BQU1jLGFBQWF6QyxPQUFPLENBQUN1QztJQUMxQyxJQUFJWixPQUFPakUsTUFBTSxLQUFLLEdBQ2xCLE1BQU0sSUFBSWIscUJBQXFCO0lBQ25DLE9BQU87UUFDSGhCLEtBQUssSUFBSTZHLFdBQVcsTUFBTWYsTUFBTSxDQUFDLEVBQUUsQ0FBQ2dCLFdBQVc7UUFDL0M3RyxTQUFTLElBQUk0RyxXQUFXLE1BQU1mLE1BQU0sQ0FBQyxFQUFFLENBQUNnQixXQUFXO1FBQ25ESDtJQUNKO0FBQ0o7QUFFQTs7Ozs7Q0FLQyxHQUNELE1BQU1JLHVCQUF1QixDQUFDQztJQUMxQixPQUFPLElBQUkzQyxRQUFRLENBQUNDLFNBQVNDO1FBQ3pCLE1BQU0wQyxNQUFNQyxTQUFTQyxhQUFhLENBQUM7UUFDbkNGLElBQUlHLE1BQU0sR0FBRztZQUFROUMsUUFBUTJDO1FBQU07UUFDbkMsMkVBQTJFO1FBQzNFQSxJQUFJSSxPQUFPLEdBQUcsQ0FBQ3pEO1lBQVFXLE9BQU9YO1FBQUk7UUFDbENxRCxJQUFJSyxHQUFHLEdBQUdDLElBQUlDLGVBQWUsQ0FBQ1I7SUFDbEM7QUFDSjtBQUVBOztDQUVDLEdBQ0QsTUFBTVMseUJBQXlCckkseUNBQU1BO0lBS2pDMEUsWUFBWWhFLE1BQU0sRUFBRTRILE9BQU8sQ0FBRTtRQUN6QixLQUFLLENBQUNBO1FBQ04sSUFBSSxDQUFDQyxPQUFPLEdBQUc3SDtRQUNmLElBQUlBLE9BQU9JLFFBQVEsRUFDZixJQUFJLENBQUMwSCxTQUFTLEdBQUc5SCxPQUFPSSxRQUFRO1FBQ3BDLElBQUksQ0FBQzJILHVCQUF1QixHQUFHLElBQUl4SSxpREFBY0E7SUFDckQ7SUFDQXlJLFlBQVk1SCxRQUFRLEVBQUU7UUFDbEIsSUFBSSxDQUFDMEgsU0FBUyxHQUFHMUg7UUFDakIsT0FBTyxJQUFJO0lBQ2Y7SUFDQTZILHVCQUF1QmhFLE9BQU8sRUFBRTtRQUM1QixJQUFJLENBQUNpRSxvQkFBb0IsR0FBR2pFO1FBQzVCLE9BQU8sSUFBSTtJQUNmO0lBQ0FrRSxzQkFBc0I7UUFDbEIsSUFBSSxDQUFDLElBQUksQ0FBQ0wsU0FBUyxFQUFFO1lBQ2pCeEgsUUFBUUMsSUFBSSxDQUFDO1FBQ2pCO1FBQ0EsTUFBTUUsV0FBVyxJQUFJLENBQUNvSCxPQUFPLENBQUNuSCxjQUFjLENBQUM7WUFDekN1QyxZQUFZO2dCQUFDO2dCQUFHO2dCQUFHO2FBQUU7WUFDckJELFlBQVk7Z0JBQUM7Z0JBQUc7Z0JBQUc7YUFBRTtZQUNyQkUsT0FBTztnQkFBQztnQkFBRztnQkFBRzthQUFFO1lBQ2hCVyxXQUFXO2dCQUFDO2dCQUFHO2dCQUFHO2FBQUU7WUFDcEJELFdBQVc7Z0JBQUM7Z0JBQUc7Z0JBQUc7YUFBRTtZQUNwQkosZ0JBQWdCO1lBQ2hCRixnQkFBZ0I7WUFDaEI4RSxpQkFBaUI7WUFDakJqSSxTQUFTLElBQUlYLDBDQUFPQTtZQUNwQlUsS0FBSyxJQUFJViwwQ0FBT0E7UUFDcEI7UUFDQSxPQUFPLElBQUksQ0FBQ3FJLE9BQU8sQ0FBQ2pILGtCQUFrQixDQUFDO1lBQ25DQyxPQUFPO1lBQ1BFLFFBQVE7WUFDUkMsTUFBTTNCLGdEQUFhQTtZQUNuQmdCLFlBQVlqQix1REFBb0JBO1lBQ2hDcUI7WUFDQUwsVUFBVSxJQUFJLENBQUMwSCxTQUFTO1lBQ3hCN0cscUJBQXFCLElBQUksQ0FBQ2lILG9CQUFvQjtRQUNsRDtJQUNKO0lBQ0EsTUFBTUcsY0FBY0MsU0FBUyxFQUFFQyxhQUFhLEVBQUVDLGdCQUFnQixFQUFFO1FBQzVELE1BQU1DLGNBQWNGLGdCQUFnQixJQUFJL0IsS0FBSztZQUFDK0I7U0FBYyxFQUFFO1lBQUV2SCxNQUFNO1FBQWEsS0FBS29CO1FBQ3hGLE1BQU1zRyxVQUFVLElBQUlsQyxLQUFLO1lBQUM4QjtTQUFVLEVBQUU7WUFBRXRILE1BQU07UUFBYTtRQUMzRCxJQUFJMkg7UUFDSixJQUFJQztRQUNKLElBQUlDLFlBQVk7UUFDaEIsSUFBSSxPQUFPQyxzQkFBc0IsYUFBYTtZQUMxQyxNQUFNQyxNQUFNLE1BQU14RSxRQUFReUUsR0FBRyxDQUFDO2dCQUMxQlAsY0FBY3hCLHFCQUFxQndCLGVBQWVsRSxRQUFRQyxPQUFPLENBQUNwQztnQkFDbEU2RSxxQkFBcUJ5QjthQUN4QjtZQUNERSxlQUFlRyxHQUFHLENBQUMsRUFBRTtZQUNyQkosV0FBV0ksR0FBRyxDQUFDLEVBQUU7WUFDakJGLFlBQVlMLHFCQUFxQjtRQUNyQyxPQUNLO1lBQ0QsTUFBTU8sTUFBTSxNQUFNeEUsUUFBUXlFLEdBQUcsQ0FBQztnQkFDMUJQLGNBQWNLLGtCQUFrQkwsYUFBYTtvQkFBRUQsa0JBQWtCQSxvQkFBb0I7Z0JBQVEsS0FBS2pFLFFBQVFDLE9BQU8sQ0FBQ3BDO2dCQUNsSDBHLGtCQUFrQkosU0FBUztvQkFBRUYsa0JBQWtCQSxvQkFBb0I7Z0JBQVE7YUFDOUU7WUFDREksZUFBZUcsR0FBRyxDQUFDLEVBQUU7WUFDckJKLFdBQVdJLEdBQUcsQ0FBQyxFQUFFO1FBQ3JCO1FBQ0EsT0FBTztZQUFFSjtZQUFVQztZQUFjQztRQUFVO0lBQy9DO0lBQ0FJLGVBQWVOLFFBQVEsRUFBRUMsWUFBWSxFQUFFQyxTQUFTLEVBQUU7UUFDOUMsTUFBTTFJLFVBQVUsSUFBSVgsMENBQU9BLENBQUNvSixnQkFBZ0IsSUFBSU0sVUFBVSxHQUFHLElBQUl6Siw0Q0FBU0EsRUFBRUMsc0RBQW1CQSxFQUFFQSxzREFBbUJBLEVBQUVDLCtDQUFZQSxFQUFFQywyREFBd0JBLEVBQUVDLDZDQUFVQSxFQUFFQyxtREFBZ0JBLEVBQUUsR0FBR1YsdURBQW9CQTtRQUNuTmUsUUFBUWdKLEtBQUssR0FBR047UUFDaEIxSSxRQUFRSyxXQUFXLEdBQUc7UUFDdEIsTUFBTU4sTUFBTSxJQUFJViwwQ0FBT0EsQ0FBQ21KLFVBQVVsSiw0Q0FBU0EsRUFBRUMsc0RBQW1CQSxFQUFFQSxzREFBbUJBLEVBQUVDLCtDQUFZQSxFQUFFQywyREFBd0JBLEVBQUVDLDZDQUFVQSxFQUFFQyxtREFBZ0JBLEVBQUUsR0FBR1gsaURBQWNBO1FBQzlLZSxJQUFJaUosS0FBSyxHQUFHTjtRQUNaM0ksSUFBSU0sV0FBVyxHQUFHO1FBQ2xCLE9BQU87WUFBRUw7WUFBU0Q7UUFBSTtJQUMxQjtJQUNBa0osbUJBQW1CekksWUFBWSxFQUFFZ0ksUUFBUSxFQUFFeEksT0FBTyxFQUFFRCxHQUFHLEVBQUUyRyxRQUFRLEVBQUU7UUFDL0RsRyxhQUFhRSxLQUFLLEdBQUc4SCxTQUFTOUgsS0FBSztRQUNuQ0YsYUFBYUksTUFBTSxHQUFHNEgsU0FBUzVILE1BQU07UUFDckNKLGFBQWFGLFFBQVEsQ0FBQ04sT0FBTyxHQUFHQTtRQUNoQ1EsYUFBYUYsUUFBUSxDQUFDUCxHQUFHLEdBQUdBO1FBQzVCUyxhQUFhRixRQUFRLENBQUN1QyxVQUFVLEdBQUc2RCxTQUFTN0QsVUFBVTtRQUN0RHJDLGFBQWFGLFFBQVEsQ0FBQ3dDLFVBQVUsR0FBRzRELFNBQVM1RCxVQUFVO1FBQ3REdEMsYUFBYUYsUUFBUSxDQUFDb0QsU0FBUyxHQUFHZ0QsU0FBU2hELFNBQVM7UUFDcERsRCxhQUFhRixRQUFRLENBQUNtRCxTQUFTLEdBQUdpRCxTQUFTakQsU0FBUztRQUNwRGpELGFBQWFGLFFBQVEsQ0FBQ3lDLEtBQUssR0FBRzJELFNBQVMzRCxLQUFLO1FBQzVDdkMsYUFBYUYsUUFBUSxDQUFDNkMsY0FBYyxHQUFHdUQsU0FBU3ZELGNBQWM7UUFDOUQzQyxhQUFhRixRQUFRLENBQUMrQyxjQUFjLEdBQUdxRCxTQUFTckQsY0FBYztRQUM5RDdDLGFBQWFGLFFBQVEsQ0FBQzJILGVBQWUsR0FBR2lCLEtBQUtDLEdBQUcsQ0FBQyxHQUFHekMsU0FBU3JELGNBQWM7UUFDM0U3QyxhQUFhRixRQUFRLENBQUNELFdBQVcsR0FBRztJQUN4QztBQUNKO0FBRXVMIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYmx1ZXByaW50LXRvLTNkLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0Btb25vZ3JpZC9nYWlubWFwLWpzL2Rpc3QvTG9hZGVyLURMSS1fSkRQLmpzP2RlM2YiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbW9ub2dyaWQvZ2Fpbm1hcC1qcyB2My40LjBcbiAqIFdpdGgg4p2k77iPLCBieSBNT05PR1JJRCA8Z2Fpbm1hcEBtb25vZ3JpZC5jb20+XG4gKi9cblxuaW1wb3J0IHsgU1JHQkNvbG9yU3BhY2UsIExpbmVhclNSR0JDb2xvclNwYWNlLCBIYWxmRmxvYXRUeXBlLCBMb2FkZXIsIExvYWRpbmdNYW5hZ2VyLCBUZXh0dXJlLCBVVk1hcHBpbmcsIENsYW1wVG9FZGdlV3JhcHBpbmcsIExpbmVhckZpbHRlciwgTGluZWFyTWlwTWFwTGluZWFyRmlsdGVyLCBSR0JBRm9ybWF0LCBVbnNpZ25lZEJ5dGVUeXBlIH0gZnJvbSAndGhyZWUnO1xuXG4vKipcbiAqIFNoYXJlZCBkZWNvZGUgaW1wbGVtZW50YXRpb24gZmFjdG9yeVxuICogQ3JlYXRlcyBhIGRlY29kZSBmdW5jdGlvbiB0aGF0IHByZXBhcmVzIGEgUXVhZFJlbmRlcmVyIHdpdGggdGhlIGdpdmVuIHBhcmFtZXRlcnNcbiAqL1xuZnVuY3Rpb24gY3JlYXRlRGVjb2RlRnVuY3Rpb24oY29uZmlnKSB7XG4gICAgcmV0dXJuIChwYXJhbXMpID0+IHtcbiAgICAgICAgY29uc3QgeyBzZHIsIGdhaW5NYXAsIHJlbmRlcmVyIH0gPSBwYXJhbXM7XG4gICAgICAgIGlmIChzZHIuY29sb3JTcGFjZSAhPT0gU1JHQkNvbG9yU3BhY2UpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignU0RSIENvbG9yc3BhY2UgbmVlZHMgdG8gYmUgKlNSR0JDb2xvclNwYWNlKiwgc2V0dGluZyBpdCBhdXRvbWF0aWNhbGx5Jyk7XG4gICAgICAgICAgICBzZHIuY29sb3JTcGFjZSA9IFNSR0JDb2xvclNwYWNlO1xuICAgICAgICB9XG4gICAgICAgIHNkci5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICAgIGlmIChnYWluTWFwLmNvbG9yU3BhY2UgIT09IExpbmVhclNSR0JDb2xvclNwYWNlKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ0dhaW5tYXAgQ29sb3JzcGFjZSBuZWVkcyB0byBiZSAqTGluZWFyU1JHQkNvbG9yU3BhY2UqLCBzZXR0aW5nIGl0IGF1dG9tYXRpY2FsbHknKTtcbiAgICAgICAgICAgIGdhaW5NYXAuY29sb3JTcGFjZSA9IExpbmVhclNSR0JDb2xvclNwYWNlO1xuICAgICAgICB9XG4gICAgICAgIGdhaW5NYXAubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgICBjb25zdCBtYXRlcmlhbCA9IGNvbmZpZy5jcmVhdGVNYXRlcmlhbCh7XG4gICAgICAgICAgICAuLi5wYXJhbXMsXG4gICAgICAgICAgICBzZHIsXG4gICAgICAgICAgICBnYWluTWFwXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBxdWFkUmVuZGVyZXIgPSBjb25maWcuY3JlYXRlUXVhZFJlbmRlcmVyKHtcbiAgICAgICAgICAgIHdpZHRoOiBzZHIuaW1hZ2Uud2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IHNkci5pbWFnZS5oZWlnaHQsXG4gICAgICAgICAgICB0eXBlOiBIYWxmRmxvYXRUeXBlLFxuICAgICAgICAgICAgY29sb3JTcGFjZTogTGluZWFyU1JHQkNvbG9yU3BhY2UsXG4gICAgICAgICAgICBtYXRlcmlhbCxcbiAgICAgICAgICAgIHJlbmRlcmVyLFxuICAgICAgICAgICAgcmVuZGVyVGFyZ2V0T3B0aW9uczogcGFyYW1zLnJlbmRlclRhcmdldE9wdGlvbnNcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBxdWFkUmVuZGVyZXI7XG4gICAgfTtcbn1cblxuY2xhc3MgR2Fpbk1hcE5vdEZvdW5kRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG59XG5cbmNsYXNzIFhNUE1ldGFkYXRhTm90Rm91bmRFcnJvciBleHRlbmRzIEVycm9yIHtcbn1cblxuY29uc3QgZ2V0WE1MVmFsdWUgPSAoeG1sLCB0YWcsIGRlZmF1bHRWYWx1ZSkgPT4ge1xuICAgIC8vIENoZWNrIGZvciBhdHRyaWJ1dGUgZm9ybWF0IGZpcnN0OiB0YWc9XCJ2YWx1ZVwiXG4gICAgY29uc3QgYXR0cmlidXRlTWF0Y2ggPSBuZXcgUmVnRXhwKGAke3RhZ309XCIoW15cIl0qKVwiYCwgJ2knKS5leGVjKHhtbCk7XG4gICAgaWYgKGF0dHJpYnV0ZU1hdGNoKVxuICAgICAgICByZXR1cm4gYXR0cmlidXRlTWF0Y2hbMV07XG4gICAgLy8gQ2hlY2sgZm9yIHRhZyBmb3JtYXQ6IDx0YWc+dmFsdWU8L3RhZz4gb3IgPHRhZz48cmRmOmxpPnZhbHVlPC9yZGY6bGk+Li4uPC90YWc+XG4gICAgY29uc3QgdGFnTWF0Y2ggPSBuZXcgUmVnRXhwKGA8JHt0YWd9W14+XSo+KFtcXFxcc1xcXFxTXSo/KTwvJHt0YWd9PmAsICdpJykuZXhlYyh4bWwpO1xuICAgIGlmICh0YWdNYXRjaCkge1xuICAgICAgICAvLyBDaGVjayBpZiBpdCBjb250YWlucyByZGY6bGkgZWxlbWVudHNcbiAgICAgICAgY29uc3QgbGlWYWx1ZXMgPSB0YWdNYXRjaFsxXS5tYXRjaCgvPHJkZjpsaT4oW148XSopPFxcL3JkZjpsaT4vZyk7XG4gICAgICAgIGlmIChsaVZhbHVlcyAmJiBsaVZhbHVlcy5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgICAgIHJldHVybiBsaVZhbHVlcy5tYXAodiA9PiB2LnJlcGxhY2UoLzxcXC8/cmRmOmxpPi9nLCAnJykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YWdNYXRjaFsxXS50cmltKCk7XG4gICAgfVxuICAgIGlmIChkZWZhdWx0VmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYENhbid0IGZpbmQgJHt0YWd9IGluIGdhaW5tYXAgbWV0YWRhdGFgKTtcbn07XG5jb25zdCBleHRyYWN0WE1QID0gKGlucHV0KSA9PiB7XG4gICAgbGV0IHN0cjtcbiAgICAvLyBzdXBwb3J0IG5vZGUgdGVzdCBlbnZpcm9ubWVudFxuICAgIGlmICh0eXBlb2YgVGV4dERlY29kZXIgIT09ICd1bmRlZmluZWQnKVxuICAgICAgICBzdHIgPSBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUoaW5wdXQpO1xuICAgIGVsc2VcbiAgICAgICAgc3RyID0gaW5wdXQudG9TdHJpbmcoKTtcbiAgICBsZXQgc3RhcnQgPSBzdHIuaW5kZXhPZignPHg6eG1wbWV0YScpO1xuICAgIHdoaWxlIChzdGFydCAhPT0gLTEpIHtcbiAgICAgICAgY29uc3QgZW5kID0gc3RyLmluZGV4T2YoJ3g6eG1wbWV0YT4nLCBzdGFydCk7XG4gICAgICAgIGNvbnN0IHhtcEJsb2NrID0gc3RyLnNsaWNlKHN0YXJ0LCBlbmQgKyAxMCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBnYWluTWFwTWluID0gZ2V0WE1MVmFsdWUoeG1wQmxvY2ssICdoZHJnbTpHYWluTWFwTWluJywgJzAnKTtcbiAgICAgICAgICAgIGNvbnN0IGdhaW5NYXBNYXggPSBnZXRYTUxWYWx1ZSh4bXBCbG9jaywgJ2hkcmdtOkdhaW5NYXBNYXgnKTtcbiAgICAgICAgICAgIGNvbnN0IGdhbW1hID0gZ2V0WE1MVmFsdWUoeG1wQmxvY2ssICdoZHJnbTpHYW1tYScsICcxJyk7XG4gICAgICAgICAgICBjb25zdCBvZmZzZXRTRFIgPSBnZXRYTUxWYWx1ZSh4bXBCbG9jaywgJ2hkcmdtOk9mZnNldFNEUicsICcwLjAxNTYyNScpO1xuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0SERSID0gZ2V0WE1MVmFsdWUoeG1wQmxvY2ssICdoZHJnbTpPZmZzZXRIRFInLCAnMC4wMTU2MjUnKTtcbiAgICAgICAgICAgIC8vIFRoZXNlIGFyZSBhbHdheXMgYXR0cmlidXRlcywgc28gd2UgY2FuIHVzZSBhIHNpbXBsZXIgcmVnZXhcbiAgICAgICAgICAgIGNvbnN0IGhkckNhcGFjaXR5TWluTWF0Y2ggPSAvaGRyZ206SERSQ2FwYWNpdHlNaW49XCIoW15cIl0qKVwiLy5leGVjKHhtcEJsb2NrKTtcbiAgICAgICAgICAgIGNvbnN0IGhkckNhcGFjaXR5TWluID0gaGRyQ2FwYWNpdHlNaW5NYXRjaCA/IGhkckNhcGFjaXR5TWluTWF0Y2hbMV0gOiAnMCc7XG4gICAgICAgICAgICBjb25zdCBoZHJDYXBhY2l0eU1heE1hdGNoID0gL2hkcmdtOkhEUkNhcGFjaXR5TWF4PVwiKFteXCJdKilcIi8uZXhlYyh4bXBCbG9jayk7XG4gICAgICAgICAgICBpZiAoIWhkckNhcGFjaXR5TWF4TWF0Y2gpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbmNvbXBsZXRlIGdhaW5tYXAgbWV0YWRhdGEnKTtcbiAgICAgICAgICAgIGNvbnN0IGhkckNhcGFjaXR5TWF4ID0gaGRyQ2FwYWNpdHlNYXhNYXRjaFsxXTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZ2Fpbk1hcE1pbjogQXJyYXkuaXNBcnJheShnYWluTWFwTWluKSA/IGdhaW5NYXBNaW4ubWFwKHYgPT4gcGFyc2VGbG9hdCh2KSkgOiBbcGFyc2VGbG9hdChnYWluTWFwTWluKSwgcGFyc2VGbG9hdChnYWluTWFwTWluKSwgcGFyc2VGbG9hdChnYWluTWFwTWluKV0sXG4gICAgICAgICAgICAgICAgZ2Fpbk1hcE1heDogQXJyYXkuaXNBcnJheShnYWluTWFwTWF4KSA/IGdhaW5NYXBNYXgubWFwKHYgPT4gcGFyc2VGbG9hdCh2KSkgOiBbcGFyc2VGbG9hdChnYWluTWFwTWF4KSwgcGFyc2VGbG9hdChnYWluTWFwTWF4KSwgcGFyc2VGbG9hdChnYWluTWFwTWF4KV0sXG4gICAgICAgICAgICAgICAgZ2FtbWE6IEFycmF5LmlzQXJyYXkoZ2FtbWEpID8gZ2FtbWEubWFwKHYgPT4gcGFyc2VGbG9hdCh2KSkgOiBbcGFyc2VGbG9hdChnYW1tYSksIHBhcnNlRmxvYXQoZ2FtbWEpLCBwYXJzZUZsb2F0KGdhbW1hKV0sXG4gICAgICAgICAgICAgICAgb2Zmc2V0U2RyOiBBcnJheS5pc0FycmF5KG9mZnNldFNEUikgPyBvZmZzZXRTRFIubWFwKHYgPT4gcGFyc2VGbG9hdCh2KSkgOiBbcGFyc2VGbG9hdChvZmZzZXRTRFIpLCBwYXJzZUZsb2F0KG9mZnNldFNEUiksIHBhcnNlRmxvYXQob2Zmc2V0U0RSKV0sXG4gICAgICAgICAgICAgICAgb2Zmc2V0SGRyOiBBcnJheS5pc0FycmF5KG9mZnNldEhEUikgPyBvZmZzZXRIRFIubWFwKHYgPT4gcGFyc2VGbG9hdCh2KSkgOiBbcGFyc2VGbG9hdChvZmZzZXRIRFIpLCBwYXJzZUZsb2F0KG9mZnNldEhEUiksIHBhcnNlRmxvYXQob2Zmc2V0SERSKV0sXG4gICAgICAgICAgICAgICAgaGRyQ2FwYWNpdHlNaW46IHBhcnNlRmxvYXQoaGRyQ2FwYWNpdHlNaW4pLFxuICAgICAgICAgICAgICAgIGhkckNhcGFjaXR5TWF4OiBwYXJzZUZsb2F0KGhkckNhcGFjaXR5TWF4KVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLy8gQ29udGludWUgc2VhcmNoaW5nIGZvciBhbm90aGVyIHhtcG1ldGEgYmxvY2sgaWYgdGhpcyBvbmUgZmFpbHNcbiAgICAgICAgfVxuICAgICAgICBzdGFydCA9IHN0ci5pbmRleE9mKCc8eDp4bXBtZXRhJywgZW5kKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIE1QRiBFeHRyYWN0b3IgKE11bHRpIFBpY3R1cmUgRm9ybWF0IEV4dHJhY3RvcilcbiAqIEJ5IEhlbnJpayBTIE5pbHNzb24gMjAxOVxuICpcbiAqIEV4dHJhY3RzIGltYWdlcyBzdG9yZWQgaW4gaW1hZ2VzIGJhc2VkIG9uIHRoZSBNUEYgZm9ybWF0IChmb3VuZCBoZXJlOiBodHRwczovL3d3dy5jaXBhLmpwL2Uvc3RkL3N0ZC1zZWMuaHRtbFxuICogdW5kZXIgXCJDSVBBIERDLTAwNy1UcmFuc2xhdGlvbi0yMDIxIE11bHRpLVBpY3R1cmUgRm9ybWF0XCJcbiAqXG4gKiBPdmVybHkgY29tbWVudGVkLCBhbmQgd2l0aG91dCBpbnRlbnRpb24gb2YgYmVpbmcgY29tcGxldGUgb3IgcHJvZHVjdGlvbiByZWFkeS5cbiAqIENyZWF0ZWQgdG8gZXh0cmFjdCBkZXB0aCBtYXBzIGZyb20gaVBob25lIGltYWdlcywgYW5kIHRvIGxlYXJuIGFib3V0IGltYWdlIG1ldGFkYXRhLlxuICogS3Vkb3MgdG86IFBoaWwgSGFydmV5IChleGlmdG9vbCksIEphdW1lIFNhbmNoZXogKGFuZHJvaWQtbGVucy1ibHVyLWRlcHRoLWV4dHJhY3RvcilcbiAqL1xuY2xhc3MgTVBGRXh0cmFjdG9yIHtcbiAgICBvcHRpb25zO1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zID0ge1xuICAgICAgICAgICAgZGVidWc6IG9wdGlvbnMgJiYgb3B0aW9ucy5kZWJ1ZyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5kZWJ1ZyA6IGZhbHNlLFxuICAgICAgICAgICAgZXh0cmFjdEZJSTogb3B0aW9ucyAmJiBvcHRpb25zLmV4dHJhY3RGSUkgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZXh0cmFjdEZJSSA6IHRydWUsXG4gICAgICAgICAgICBleHRyYWN0Tm9uRklJOiBvcHRpb25zICYmIG9wdGlvbnMuZXh0cmFjdE5vbkZJSSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5leHRyYWN0Tm9uRklJIDogdHJ1ZVxuICAgICAgICB9O1xuICAgIH1cbiAgICBleHRyYWN0KGltYWdlQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGRlYnVnID0gdGhpcy5vcHRpb25zLmRlYnVnO1xuICAgICAgICAgICAgY29uc3QgZGF0YVZpZXcgPSBuZXcgRGF0YVZpZXcoaW1hZ2VBcnJheUJ1ZmZlci5idWZmZXIpO1xuICAgICAgICAgICAgLy8gSWYgeW91J3JlIGV4ZWN1dGluZyB0aGlzIGxpbmUgb24gYSBiaWcgZW5kaWFuIG1hY2hpbmUsIGl0J2xsIGJlIHJldmVyc2VkLlxuICAgICAgICAgICAgLy8gYmlnRW5kIGZ1cnRoZXIgZG93biB0aG91Z2gsIHJlZmVycyB0byB0aGUgZW5kaWFubmVzcyBvZiB0aGUgaW1hZ2UgaXRzZWxmLlxuICAgICAgICAgICAgaWYgKGRhdGFWaWV3LmdldFVpbnQxNigwKSAhPT0gMHhmZmQ4KSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignTm90IGEgdmFsaWQganBlZycpKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsZW5ndGggPSBkYXRhVmlldy5ieXRlTGVuZ3RoO1xuICAgICAgICAgICAgbGV0IG9mZnNldCA9IDI7XG4gICAgICAgICAgICBsZXQgbG9vcHMgPSAwO1xuICAgICAgICAgICAgbGV0IG1hcmtlcjsgLy8gQVBQIyBtYXJrZXJcbiAgICAgICAgICAgIHdoaWxlIChvZmZzZXQgPCBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBpZiAoKytsb29wcyA+IDI1MCkge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKGBGb3VuZCBubyBtYXJrZXIgYWZ0ZXIgJHtsb29wc30gbG9vcHMg8J+YtWApKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZGF0YVZpZXcuZ2V0VWludDgob2Zmc2V0KSAhPT0gMHhmZikge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKGBOb3QgYSB2YWxpZCBtYXJrZXIgYXQgb2Zmc2V0IDB4JHtvZmZzZXQudG9TdHJpbmcoMTYpfSwgZm91bmQ6IDB4JHtkYXRhVmlldy5nZXRVaW50OChvZmZzZXQpLnRvU3RyaW5nKDE2KX1gKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbWFya2VyID0gZGF0YVZpZXcuZ2V0VWludDgob2Zmc2V0ICsgMSk7XG4gICAgICAgICAgICAgICAgaWYgKGRlYnVnKVxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgTWFya2VyOiAke21hcmtlci50b1N0cmluZygxNil9YCk7XG4gICAgICAgICAgICAgICAgaWYgKG1hcmtlciA9PT0gMHhlMikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGVidWcpXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnRm91bmQgQVBQMiBtYXJrZXIgKDB4ZmZlMiknKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gV29ya3MgZm9yIGlQaG9uZSA4IFBsdXMsIFgsIGFuZCBYU01heC4gT3IgYW55IHBob3RvcyBvZiBNUEYgZm9ybWF0LlxuICAgICAgICAgICAgICAgICAgICAvLyBHcmVhdCB3YXkgdG8gdmlzdWFsaXplIGltYWdlIGluZm9ybWF0aW9uIGluIGh0bWwgaXMgdXNpbmcgRXhpZnRvb2wuIEUuZy46XG4gICAgICAgICAgICAgICAgICAgIC8vIC4vZXhpZnRvb2wuZXhlIC1odG1sZHVtcCAtd2FudFRyYWlsZXIgcGhvdG8uanBnID4gcGhvdG8uaHRtbFxuICAgICAgICAgICAgICAgICAgICBjb25zdCBmb3JtYXRQdCA9IG9mZnNldCArIDQ7XG4gICAgICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICAgICAqICBTdHJ1Y3R1cmUgb2YgdGhlIE1QIEZvcm1hdCBJZGVudGlmaWVyXG4gICAgICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICAgICAqICBPZmZzZXQgQWRkci4gIHwgQ29kZSAoSGV4KSAgfCBEZXNjcmlwdGlvblxuICAgICAgICAgICAgICAgICAgICAgKiAgKzAwICAgICAgICAgICAgIGZmICAgICAgICAgICAgTWFya2VyIFByZWZpeCAgICAgIDwtLSBvZmZzZXRcbiAgICAgICAgICAgICAgICAgICAgICogICswMSAgICAgICAgICAgICBlMiAgICAgICAgICAgIEFQUDJcbiAgICAgICAgICAgICAgICAgICAgICogICswMiAgICAgICAgICAgICAjbiAgICAgICAgICAgIEFQUDIgRmllbGQgTGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgICAqICArMDMgICAgICAgICAgICAgI24gICAgICAgICAgICBBUFAyIEZpZWxkIExlbmd0aFxuICAgICAgICAgICAgICAgICAgICAgKiAgKzA0ICAgICAgICAgICAgIDRkICAgICAgICAgICAgJ00nICAgICAgICAgICAgICAgIDwtLSBmb3JtYXRQdFxuICAgICAgICAgICAgICAgICAgICAgKiAgKzA1ICAgICAgICAgICAgIDUwICAgICAgICAgICAgJ1AnXG4gICAgICAgICAgICAgICAgICAgICAqICArMDYgICAgICAgICAgICAgNDYgICAgICAgICAgICAnRidcbiAgICAgICAgICAgICAgICAgICAgICogICswNyAgICAgICAgICAgICAwMCAgICAgICAgICAgIE5VTExcbiAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8LS0gdGlmZk9mZnNldFxuICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGFWaWV3LmdldFVpbnQzMihmb3JtYXRQdCkgPT09IDB4NGQ1MDQ2MDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZvdW5kIE1QRiB0YWcsIHNvIHdlIHN0YXJ0IGRpZyBvdXQgc3ViIGltYWdlc1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdGlmZk9mZnNldCA9IGZvcm1hdFB0ICsgNDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBiaWdFbmQ7IC8vIEVuZGlhbm5lc3MgZnJvbSBUSUZGIGhlYWRlclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGVzdCBmb3IgVElGRiB2YWxpZGl0eSBhbmQgZW5kaWFubmVzc1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gMHg0OTQ5IGFuZCAweDRENEQgKCdJSScgYW5kICdNTScpIG1hcmtzIExpdHRsZSBFbmRpYW4gYW5kIEJpZyBFbmRpYW5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXRhVmlldy5nZXRVaW50MTYodGlmZk9mZnNldCkgPT09IDB4NDk0OSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJpZ0VuZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZGF0YVZpZXcuZ2V0VWludDE2KHRpZmZPZmZzZXQpID09PSAweDRkNGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiaWdFbmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignTm8gdmFsaWQgZW5kaWFubmVzcyBtYXJrZXIgZm91bmQgaW4gVElGRiBoZWFkZXInKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGFWaWV3LmdldFVpbnQxNih0aWZmT2Zmc2V0ICsgMiwgIWJpZ0VuZCkgIT09IDB4MDAyYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ05vdCB2YWxpZCBUSUZGIGRhdGEhIChubyAweDAwMkEgbWFya2VyKScpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAzMiBiaXQgbnVtYmVyIHN0YXRpbmcgdGhlIG9mZnNldCBmcm9tIHRoZSBzdGFydCBvZiB0aGUgOCBCeXRlIE1QIEhlYWRlclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdG8gTVAgSW5kZXggSUZEIExlYXN0IHBvc3NpYmxlIHZhbHVlIGlzIHRodXMgOCAobWVhbnMgMCBvZmZzZXQpXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBmaXJzdElGRE9mZnNldCA9IGRhdGFWaWV3LmdldFVpbnQzMih0aWZmT2Zmc2V0ICsgNCwgIWJpZ0VuZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmlyc3RJRkRPZmZzZXQgPCAweDAwMDAwMDA4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignTm90IHZhbGlkIFRJRkYgZGF0YSEgKEZpcnN0IG9mZnNldCBsZXNzIHRoYW4gOCknKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTW92ZSBhaGVhZCB0byBNUCBJbmRleCBJRkRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFzc3VtZSB3ZSdyZSBhdCB0aGUgZmlyc3QgSUZELCBzbyBmaXJzdElGRE9mZnNldCBwb2ludHMgdG9cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1QIEluZGV4IElGRCBhbmQgbm90IE1QIEF0dHJpYnV0ZXMgSUZELiAoSWYgd2UgdHJ5IGV4dHJhY3QgZnJvbSBhIHN1YiBpbWFnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIGZhaWwgc2lsZW50bHkgaGVyZSBkdWUgdG8gdGhpcyBhc3N1bXB0aW9uKVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ291bnQgKDIgQnl0ZSkgfCBNUCBJbmRleCBGaWVsZHMgYS5rLmEuIE1QIEVudHJpZXMgKGNvdW50ICogMTIgQnl0ZSkgfCBPZmZzZXQgb2YgTmV4dCBJRkQgKDQgQnl0ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRpclN0YXJ0ID0gdGlmZk9mZnNldCArIGZpcnN0SUZET2Zmc2V0OyAvLyBTdGFydCBvZiBJRkQgKEltYWdlIEZpbGUgRGlyZWN0b3J5KVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY291bnQgPSBkYXRhVmlldy5nZXRVaW50MTYoZGlyU3RhcnQsICFiaWdFbmQpOyAvLyBDb3VudCBvZiBNUEVudHJpZXMgKDIgQnl0ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEV4dHJhY3QgaW5mbyBmcm9tIE1QRW50cmllcyAoc3RhcnRpbmcgYWZ0ZXIgQ291bnQpXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlbnRyaWVzU3RhcnQgPSBkaXJTdGFydCArIDI7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbnVtYmVyT2ZJbWFnZXMgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IGVudHJpZXNTdGFydDsgaSA8IGVudHJpZXNTdGFydCArIDEyICogY291bnQ7IGkgKz0gMTIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBFYWNoIGVudHJ5IGlzIDEyIEJ5dGVzIGxvbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBNUCBJbmRleCBJRkQgdGFncywgaGVyZSB3ZSBvbmx5IHRha2UgdGFnIDB4YjAwMSA9IE51bWJlciBvZiBpbWFnZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YVZpZXcuZ2V0VWludDE2KGksICFiaWdFbmQpID09PSAweGIwMDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3RvcmVkIGluIExhc3QgNCBieXRlcyBvZiBpdHMgMTIgQnl0ZSBlbnRyeS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVtYmVyT2ZJbWFnZXMgPSBkYXRhVmlldy5nZXRVaW50MzIoaSArIDgsICFiaWdFbmQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5leHRJRkRPZmZzZXRMZW4gPSA0OyAvLyA0IEJ5dGUgb2Zmc2V0IGZpZWxkIHRoYXQgYXBwZWFycyBhZnRlciBNUCBJbmRleCBJRkQgdGFnc1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgTVBJbWFnZUxpc3RWYWxQdCA9IGRpclN0YXJ0ICsgMiArIGNvdW50ICogMTIgKyBuZXh0SUZET2Zmc2V0TGVuO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaW1hZ2VzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gTVBJbWFnZUxpc3RWYWxQdDsgaSA8IE1QSW1hZ2VMaXN0VmFsUHQgKyBudW1iZXJPZkltYWdlcyAqIDE2OyBpICs9IDE2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaW1hZ2UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1QVHlwZTogZGF0YVZpZXcuZ2V0VWludDMyKGksICFiaWdFbmQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaXplOiBkYXRhVmlldy5nZXRVaW50MzIoaSArIDQsICFiaWdFbmQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIG9mZnNldCBpcyBzcGVjaWZpZWQgcmVsYXRpdmUgdG8gdGhlIGFkZHJlc3Mgb2YgdGhlIE1QIEVuZGlhblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBmaWVsZCBpbiB0aGUgTVAgSGVhZGVyLCB1bmxlc3MgdGhlIGltYWdlIGlzIGEgRmlyc3QgSW5kaXZpZHVhbCBJbWFnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW4gd2hpY2ggY2FzZSB0aGUgdmFsdWUgb2YgdGhlIG9mZnNldCBzaGFsbCBiZSBOVUxMICgweDAwMDAwMDAwKS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YU9mZnNldDogZGF0YVZpZXcuZ2V0VWludDMyKGkgKyA4LCAhYmlnRW5kKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVwZW5kYW50SW1hZ2VzOiBkYXRhVmlldy5nZXRVaW50MzIoaSArIDEyLCAhYmlnRW5kKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IC0xLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IC0xLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0ZJSTogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaW1hZ2UuZGF0YU9mZnNldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBkYXRhT2Zmc2V0IGlzIDB4MDAwMDAwMDAgZm9yIEZpcnN0IEluZGl2aWR1YWwgSW1hZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2Uuc3RhcnQgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbWFnZS5pc0ZJSSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbWFnZS5zdGFydCA9IHRpZmZPZmZzZXQgKyBpbWFnZS5kYXRhT2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbWFnZS5pc0ZJSSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbWFnZS5lbmQgPSBpbWFnZS5zdGFydCArIGltYWdlLnNpemU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2VzLnB1c2goaW1hZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5leHRyYWN0Tm9uRklJICYmIGltYWdlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBidWZmZXJCbG9iID0gbmV3IEJsb2IoW2RhdGFWaWV3XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaW1ncyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgaW1hZ2Ugb2YgaW1hZ2VzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbWFnZS5pc0ZJSSAmJiAhdGhpcy5vcHRpb25zLmV4dHJhY3RGSUkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlOyAvLyBTa2lwIEZJSVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGltYWdlQmxvYiA9IGJ1ZmZlckJsb2Iuc2xpY2UoaW1hZ2Uuc3RhcnQsIGltYWdlLmVuZCArIDEsICdpbWFnZS9qcGVnJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIGRvbid0IG5lZWQgdGhpc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjb25zdCBpbWFnZVVybCA9IFVSTC5jcmVhdGVPYmplY3RVUkwoaW1hZ2VCbG9iKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpbWFnZS5pbWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpbWFnZS5pbWcuc3JjID0gaW1hZ2VVcmxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1ncy5wdXNoKGltYWdlQmxvYik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoaW1ncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb2Zmc2V0ICs9IDIgKyBkYXRhVmlldy5nZXRVaW50MTYob2Zmc2V0ICsgMik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuLyoqXG4gKiBFeHRyYWN0cyBYTVAgTWV0YWRhdGEgYW5kIHRoZSBnYWluIG1hcCByZWNvdmVyeSBpbWFnZVxuICogZnJvbSBhIHNpbmdsZSBKUEVHIGZpbGUuXG4gKlxuICogQGNhdGVnb3J5IERlY29kaW5nIEZ1bmN0aW9uc1xuICogQGdyb3VwIERlY29kaW5nIEZ1bmN0aW9uc1xuICogQHBhcmFtIGpwZWdGaWxlIGFuIGBVaW50OEFycmF5YCBjb250YWluaW5nIGFuZCBlbmNvZGVkIEpQRUcgZmlsZVxuICogQHJldHVybnMgYW4gc2RyIGBVaW50OEFycmF5YCBjb21wcmVzc2VkIGluIEpQRUcsIGEgZ2Fpbk1hcCBgVWludDhBcnJheWAgY29tcHJlc3NlZCBpbiBKUEVHIGFuZCB0aGUgWE1QIHBhcnNlZCBYTVAgbWV0YWRhdGFcbiAqIEB0aHJvd3MgRXJyb3IgaWYgWE1QIE1ldGFkYXRhIGlzIG5vdCBmb3VuZFxuICogQHRocm93cyBFcnJvciBpZiBHYWluIG1hcCBpbWFnZSBpcyBub3QgZm91bmRcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgeyBGaWxlTG9hZGVyIH0gZnJvbSAndGhyZWUnXG4gKiBpbXBvcnQgeyBleHRyYWN0R2Fpbm1hcEZyb21KUEVHIH0gZnJvbSAnQG1vbm9ncmlkL2dhaW5tYXAtanMnXG4gKlxuICogY29uc3QganBlZ0ZpbGUgPSBhd2FpdCBuZXcgRmlsZUxvYWRlcigpXG4gKiAgLnNldFJlc3BvbnNlVHlwZSgnYXJyYXlidWZmZXInKVxuICogIC5sb2FkQXN5bmMoJ2ltYWdlLmpwZycpXG4gKlxuICogY29uc3QgeyBzZHIsIGdhaW5NYXAsIG1ldGFkYXRhIH0gPSBleHRyYWN0R2Fpbm1hcEZyb21KUEVHKGpwZWdGaWxlKVxuICovXG5jb25zdCBleHRyYWN0R2Fpbm1hcEZyb21KUEVHID0gYXN5bmMgKGpwZWdGaWxlKSA9PiB7XG4gICAgY29uc3QgbWV0YWRhdGEgPSBleHRyYWN0WE1QKGpwZWdGaWxlKTtcbiAgICBpZiAoIW1ldGFkYXRhKVxuICAgICAgICB0aHJvdyBuZXcgWE1QTWV0YWRhdGFOb3RGb3VuZEVycm9yKCdHYWluIG1hcCBYTVAgbWV0YWRhdGEgbm90IGZvdW5kJyk7XG4gICAgY29uc3QgbXBmRXh0cmFjdG9yID0gbmV3IE1QRkV4dHJhY3Rvcih7IGV4dHJhY3RGSUk6IHRydWUsIGV4dHJhY3ROb25GSUk6IHRydWUgfSk7XG4gICAgY29uc3QgaW1hZ2VzID0gYXdhaXQgbXBmRXh0cmFjdG9yLmV4dHJhY3QoanBlZ0ZpbGUpO1xuICAgIGlmIChpbWFnZXMubGVuZ3RoICE9PSAyKVxuICAgICAgICB0aHJvdyBuZXcgR2Fpbk1hcE5vdEZvdW5kRXJyb3IoJ0dhaW4gbWFwIHJlY292ZXJ5IGltYWdlIG5vdCBmb3VuZCcpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHNkcjogbmV3IFVpbnQ4QXJyYXkoYXdhaXQgaW1hZ2VzWzBdLmFycmF5QnVmZmVyKCkpLFxuICAgICAgICBnYWluTWFwOiBuZXcgVWludDhBcnJheShhd2FpdCBpbWFnZXNbMV0uYXJyYXlCdWZmZXIoKSksXG4gICAgICAgIG1ldGFkYXRhXG4gICAgfTtcbn07XG5cbi8qKlxuICogcHJpdmF0ZSBmdW5jdGlvbiwgYXN5bmMgZ2V0IGltYWdlIGZyb20gYmxvYlxuICpcbiAqIEBwYXJhbSBibG9iXG4gKiBAcmV0dXJuc1xuICovXG5jb25zdCBnZXRIVE1MSW1hZ2VGcm9tQmxvYiA9IChibG9iKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgY29uc3QgaW1nID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW1nJyk7XG4gICAgICAgIGltZy5vbmxvYWQgPSAoKSA9PiB7IHJlc29sdmUoaW1nKTsgfTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9wcmVmZXItcHJvbWlzZS1yZWplY3QtZXJyb3JzXG4gICAgICAgIGltZy5vbmVycm9yID0gKGUpID0+IHsgcmVqZWN0KGUpOyB9O1xuICAgICAgICBpbWcuc3JjID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcbiAgICB9KTtcbn07XG5cbi8qKlxuICogU2hhcmVkIGJhc2UgY2xhc3MgZm9yIGxvYWRlcnMgdGhhdCBleHRyYWN0cyBjb21tb24gbG9naWNcbiAqL1xuY2xhc3MgTG9hZGVyQmFzZVNoYXJlZCBleHRlbmRzIExvYWRlciB7XG4gICAgX3JlbmRlcmVyO1xuICAgIF9yZW5kZXJUYXJnZXRPcHRpb25zO1xuICAgIF9pbnRlcm5hbExvYWRpbmdNYW5hZ2VyO1xuICAgIF9jb25maWc7XG4gICAgY29uc3RydWN0b3IoY29uZmlnLCBtYW5hZ2VyKSB7XG4gICAgICAgIHN1cGVyKG1hbmFnZXIpO1xuICAgICAgICB0aGlzLl9jb25maWcgPSBjb25maWc7XG4gICAgICAgIGlmIChjb25maWcucmVuZGVyZXIpXG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlciA9IGNvbmZpZy5yZW5kZXJlcjtcbiAgICAgICAgdGhpcy5faW50ZXJuYWxMb2FkaW5nTWFuYWdlciA9IG5ldyBMb2FkaW5nTWFuYWdlcigpO1xuICAgIH1cbiAgICBzZXRSZW5kZXJlcihyZW5kZXJlcikge1xuICAgICAgICB0aGlzLl9yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgc2V0UmVuZGVyVGFyZ2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuX3JlbmRlclRhcmdldE9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcHJlcGFyZVF1YWRSZW5kZXJlcigpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9yZW5kZXJlcikge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdXQVJOSU5HOiBBIFJlbmRlcmVyIHdhcyBub3QgcGFzc2VkIHRvIHRoaXMgTG9hZGVyIGNvbnN0cnVjdG9yIG9yIGluIHNldFJlbmRlcmVyLCB0aGUgcmVzdWx0IG9mIHRoaXMgTG9hZGVyIHdpbGwgbmVlZCB0byBiZSBjb252ZXJ0ZWQgdG8gYSBEYXRhIFRleHR1cmUgd2l0aCB0b0RhdGFUZXh0dXJlKCkgYmVmb3JlIHlvdSBjYW4gdXNlIGl0IGluIHlvdXIgcmVuZGVyZXIuJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWF0ZXJpYWwgPSB0aGlzLl9jb25maWcuY3JlYXRlTWF0ZXJpYWwoe1xuICAgICAgICAgICAgZ2Fpbk1hcE1heDogWzEsIDEsIDFdLFxuICAgICAgICAgICAgZ2Fpbk1hcE1pbjogWzAsIDAsIDBdLFxuICAgICAgICAgICAgZ2FtbWE6IFsxLCAxLCAxXSxcbiAgICAgICAgICAgIG9mZnNldEhkcjogWzEsIDEsIDFdLFxuICAgICAgICAgICAgb2Zmc2V0U2RyOiBbMSwgMSwgMV0sXG4gICAgICAgICAgICBoZHJDYXBhY2l0eU1heDogMSxcbiAgICAgICAgICAgIGhkckNhcGFjaXR5TWluOiAwLFxuICAgICAgICAgICAgbWF4RGlzcGxheUJvb3N0OiAxLFxuICAgICAgICAgICAgZ2Fpbk1hcDogbmV3IFRleHR1cmUoKSxcbiAgICAgICAgICAgIHNkcjogbmV3IFRleHR1cmUoKVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbmZpZy5jcmVhdGVRdWFkUmVuZGVyZXIoe1xuICAgICAgICAgICAgd2lkdGg6IDE2LFxuICAgICAgICAgICAgaGVpZ2h0OiAxNixcbiAgICAgICAgICAgIHR5cGU6IEhhbGZGbG9hdFR5cGUsXG4gICAgICAgICAgICBjb2xvclNwYWNlOiBMaW5lYXJTUkdCQ29sb3JTcGFjZSxcbiAgICAgICAgICAgIG1hdGVyaWFsLFxuICAgICAgICAgICAgcmVuZGVyZXI6IHRoaXMuX3JlbmRlcmVyLFxuICAgICAgICAgICAgcmVuZGVyVGFyZ2V0T3B0aW9uczogdGhpcy5fcmVuZGVyVGFyZ2V0T3B0aW9uc1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgcHJvY2Vzc0ltYWdlcyhzZHJCdWZmZXIsIGdhaW5NYXBCdWZmZXIsIGltYWdlT3JpZW50YXRpb24pIHtcbiAgICAgICAgY29uc3QgZ2Fpbk1hcEJsb2IgPSBnYWluTWFwQnVmZmVyID8gbmV3IEJsb2IoW2dhaW5NYXBCdWZmZXJdLCB7IHR5cGU6ICdpbWFnZS9qcGVnJyB9KSA6IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3Qgc2RyQmxvYiA9IG5ldyBCbG9iKFtzZHJCdWZmZXJdLCB7IHR5cGU6ICdpbWFnZS9qcGVnJyB9KTtcbiAgICAgICAgbGV0IHNkckltYWdlO1xuICAgICAgICBsZXQgZ2Fpbk1hcEltYWdlO1xuICAgICAgICBsZXQgbmVlZHNGbGlwID0gZmFsc2U7XG4gICAgICAgIGlmICh0eXBlb2YgY3JlYXRlSW1hZ2VCaXRtYXAgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBjb25zdCByZXMgPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICAgICAgZ2Fpbk1hcEJsb2IgPyBnZXRIVE1MSW1hZ2VGcm9tQmxvYihnYWluTWFwQmxvYikgOiBQcm9taXNlLnJlc29sdmUodW5kZWZpbmVkKSxcbiAgICAgICAgICAgICAgICBnZXRIVE1MSW1hZ2VGcm9tQmxvYihzZHJCbG9iKVxuICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICBnYWluTWFwSW1hZ2UgPSByZXNbMF07XG4gICAgICAgICAgICBzZHJJbWFnZSA9IHJlc1sxXTtcbiAgICAgICAgICAgIG5lZWRzRmxpcCA9IGltYWdlT3JpZW50YXRpb24gPT09ICdmbGlwWSc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCByZXMgPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICAgICAgZ2Fpbk1hcEJsb2IgPyBjcmVhdGVJbWFnZUJpdG1hcChnYWluTWFwQmxvYiwgeyBpbWFnZU9yaWVudGF0aW9uOiBpbWFnZU9yaWVudGF0aW9uIHx8ICdmbGlwWScgfSkgOiBQcm9taXNlLnJlc29sdmUodW5kZWZpbmVkKSxcbiAgICAgICAgICAgICAgICBjcmVhdGVJbWFnZUJpdG1hcChzZHJCbG9iLCB7IGltYWdlT3JpZW50YXRpb246IGltYWdlT3JpZW50YXRpb24gfHwgJ2ZsaXBZJyB9KVxuICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICBnYWluTWFwSW1hZ2UgPSByZXNbMF07XG4gICAgICAgICAgICBzZHJJbWFnZSA9IHJlc1sxXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBzZHJJbWFnZSwgZ2Fpbk1hcEltYWdlLCBuZWVkc0ZsaXAgfTtcbiAgICB9XG4gICAgY3JlYXRlVGV4dHVyZXMoc2RySW1hZ2UsIGdhaW5NYXBJbWFnZSwgbmVlZHNGbGlwKSB7XG4gICAgICAgIGNvbnN0IGdhaW5NYXAgPSBuZXcgVGV4dHVyZShnYWluTWFwSW1hZ2UgfHwgbmV3IEltYWdlRGF0YSgyLCAyKSwgVVZNYXBwaW5nLCBDbGFtcFRvRWRnZVdyYXBwaW5nLCBDbGFtcFRvRWRnZVdyYXBwaW5nLCBMaW5lYXJGaWx0ZXIsIExpbmVhck1pcE1hcExpbmVhckZpbHRlciwgUkdCQUZvcm1hdCwgVW5zaWduZWRCeXRlVHlwZSwgMSwgTGluZWFyU1JHQkNvbG9yU3BhY2UpO1xuICAgICAgICBnYWluTWFwLmZsaXBZID0gbmVlZHNGbGlwO1xuICAgICAgICBnYWluTWFwLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgY29uc3Qgc2RyID0gbmV3IFRleHR1cmUoc2RySW1hZ2UsIFVWTWFwcGluZywgQ2xhbXBUb0VkZ2VXcmFwcGluZywgQ2xhbXBUb0VkZ2VXcmFwcGluZywgTGluZWFyRmlsdGVyLCBMaW5lYXJNaXBNYXBMaW5lYXJGaWx0ZXIsIFJHQkFGb3JtYXQsIFVuc2lnbmVkQnl0ZVR5cGUsIDEsIFNSR0JDb2xvclNwYWNlKTtcbiAgICAgICAgc2RyLmZsaXBZID0gbmVlZHNGbGlwO1xuICAgICAgICBzZHIubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgICByZXR1cm4geyBnYWluTWFwLCBzZHIgfTtcbiAgICB9XG4gICAgdXBkYXRlUXVhZFJlbmRlcmVyKHF1YWRSZW5kZXJlciwgc2RySW1hZ2UsIGdhaW5NYXAsIHNkciwgbWV0YWRhdGEpIHtcbiAgICAgICAgcXVhZFJlbmRlcmVyLndpZHRoID0gc2RySW1hZ2Uud2lkdGg7XG4gICAgICAgIHF1YWRSZW5kZXJlci5oZWlnaHQgPSBzZHJJbWFnZS5oZWlnaHQ7XG4gICAgICAgIHF1YWRSZW5kZXJlci5tYXRlcmlhbC5nYWluTWFwID0gZ2Fpbk1hcDtcbiAgICAgICAgcXVhZFJlbmRlcmVyLm1hdGVyaWFsLnNkciA9IHNkcjtcbiAgICAgICAgcXVhZFJlbmRlcmVyLm1hdGVyaWFsLmdhaW5NYXBNaW4gPSBtZXRhZGF0YS5nYWluTWFwTWluO1xuICAgICAgICBxdWFkUmVuZGVyZXIubWF0ZXJpYWwuZ2Fpbk1hcE1heCA9IG1ldGFkYXRhLmdhaW5NYXBNYXg7XG4gICAgICAgIHF1YWRSZW5kZXJlci5tYXRlcmlhbC5vZmZzZXRIZHIgPSBtZXRhZGF0YS5vZmZzZXRIZHI7XG4gICAgICAgIHF1YWRSZW5kZXJlci5tYXRlcmlhbC5vZmZzZXRTZHIgPSBtZXRhZGF0YS5vZmZzZXRTZHI7XG4gICAgICAgIHF1YWRSZW5kZXJlci5tYXRlcmlhbC5nYW1tYSA9IG1ldGFkYXRhLmdhbW1hO1xuICAgICAgICBxdWFkUmVuZGVyZXIubWF0ZXJpYWwuaGRyQ2FwYWNpdHlNaW4gPSBtZXRhZGF0YS5oZHJDYXBhY2l0eU1pbjtcbiAgICAgICAgcXVhZFJlbmRlcmVyLm1hdGVyaWFsLmhkckNhcGFjaXR5TWF4ID0gbWV0YWRhdGEuaGRyQ2FwYWNpdHlNYXg7XG4gICAgICAgIHF1YWRSZW5kZXJlci5tYXRlcmlhbC5tYXhEaXNwbGF5Qm9vc3QgPSBNYXRoLnBvdygyLCBtZXRhZGF0YS5oZHJDYXBhY2l0eU1heCk7XG4gICAgICAgIHF1YWRSZW5kZXJlci5tYXRlcmlhbC5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgfVxufVxuXG5leHBvcnQgeyBHYWluTWFwTm90Rm91bmRFcnJvciBhcyBHLCBMb2FkZXJCYXNlU2hhcmVkIGFzIEwsIE1QRkV4dHJhY3RvciBhcyBNLCBYTVBNZXRhZGF0YU5vdEZvdW5kRXJyb3IgYXMgWCwgZXh0cmFjdFhNUCBhcyBhLCBjcmVhdGVEZWNvZGVGdW5jdGlvbiBhcyBjLCBleHRyYWN0R2Fpbm1hcEZyb21KUEVHIGFzIGUgfTtcbiJdLCJuYW1lcyI6WyJTUkdCQ29sb3JTcGFjZSIsIkxpbmVhclNSR0JDb2xvclNwYWNlIiwiSGFsZkZsb2F0VHlwZSIsIkxvYWRlciIsIkxvYWRpbmdNYW5hZ2VyIiwiVGV4dHVyZSIsIlVWTWFwcGluZyIsIkNsYW1wVG9FZGdlV3JhcHBpbmciLCJMaW5lYXJGaWx0ZXIiLCJMaW5lYXJNaXBNYXBMaW5lYXJGaWx0ZXIiLCJSR0JBRm9ybWF0IiwiVW5zaWduZWRCeXRlVHlwZSIsImNyZWF0ZURlY29kZUZ1bmN0aW9uIiwiY29uZmlnIiwicGFyYW1zIiwic2RyIiwiZ2Fpbk1hcCIsInJlbmRlcmVyIiwiY29sb3JTcGFjZSIsImNvbnNvbGUiLCJ3YXJuIiwibmVlZHNVcGRhdGUiLCJtYXRlcmlhbCIsImNyZWF0ZU1hdGVyaWFsIiwicXVhZFJlbmRlcmVyIiwiY3JlYXRlUXVhZFJlbmRlcmVyIiwid2lkdGgiLCJpbWFnZSIsImhlaWdodCIsInR5cGUiLCJyZW5kZXJUYXJnZXRPcHRpb25zIiwiR2Fpbk1hcE5vdEZvdW5kRXJyb3IiLCJFcnJvciIsIlhNUE1ldGFkYXRhTm90Rm91bmRFcnJvciIsImdldFhNTFZhbHVlIiwieG1sIiwidGFnIiwiZGVmYXVsdFZhbHVlIiwiYXR0cmlidXRlTWF0Y2giLCJSZWdFeHAiLCJleGVjIiwidGFnTWF0Y2giLCJsaVZhbHVlcyIsIm1hdGNoIiwibGVuZ3RoIiwibWFwIiwidiIsInJlcGxhY2UiLCJ0cmltIiwidW5kZWZpbmVkIiwiZXh0cmFjdFhNUCIsImlucHV0Iiwic3RyIiwiVGV4dERlY29kZXIiLCJkZWNvZGUiLCJ0b1N0cmluZyIsInN0YXJ0IiwiaW5kZXhPZiIsImVuZCIsInhtcEJsb2NrIiwic2xpY2UiLCJnYWluTWFwTWluIiwiZ2Fpbk1hcE1heCIsImdhbW1hIiwib2Zmc2V0U0RSIiwib2Zmc2V0SERSIiwiaGRyQ2FwYWNpdHlNaW5NYXRjaCIsImhkckNhcGFjaXR5TWluIiwiaGRyQ2FwYWNpdHlNYXhNYXRjaCIsImhkckNhcGFjaXR5TWF4IiwiQXJyYXkiLCJpc0FycmF5IiwicGFyc2VGbG9hdCIsIm9mZnNldFNkciIsIm9mZnNldEhkciIsImUiLCJNUEZFeHRyYWN0b3IiLCJjb25zdHJ1Y3RvciIsIm9wdGlvbnMiLCJkZWJ1ZyIsImV4dHJhY3RGSUkiLCJleHRyYWN0Tm9uRklJIiwiZXh0cmFjdCIsImltYWdlQXJyYXlCdWZmZXIiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsImRhdGFWaWV3IiwiRGF0YVZpZXciLCJidWZmZXIiLCJnZXRVaW50MTYiLCJieXRlTGVuZ3RoIiwib2Zmc2V0IiwibG9vcHMiLCJtYXJrZXIiLCJnZXRVaW50OCIsImxvZyIsImZvcm1hdFB0IiwiZ2V0VWludDMyIiwidGlmZk9mZnNldCIsImJpZ0VuZCIsImZpcnN0SUZET2Zmc2V0IiwiZGlyU3RhcnQiLCJjb3VudCIsImVudHJpZXNTdGFydCIsIm51bWJlck9mSW1hZ2VzIiwiaSIsIm5leHRJRkRPZmZzZXRMZW4iLCJNUEltYWdlTGlzdFZhbFB0IiwiaW1hZ2VzIiwiTVBUeXBlIiwic2l6ZSIsImRhdGFPZmZzZXQiLCJkZXBlbmRhbnRJbWFnZXMiLCJpc0ZJSSIsInB1c2giLCJidWZmZXJCbG9iIiwiQmxvYiIsImltZ3MiLCJpbWFnZUJsb2IiLCJleHRyYWN0R2Fpbm1hcEZyb21KUEVHIiwianBlZ0ZpbGUiLCJtZXRhZGF0YSIsIm1wZkV4dHJhY3RvciIsIlVpbnQ4QXJyYXkiLCJhcnJheUJ1ZmZlciIsImdldEhUTUxJbWFnZUZyb21CbG9iIiwiYmxvYiIsImltZyIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsIm9ubG9hZCIsIm9uZXJyb3IiLCJzcmMiLCJVUkwiLCJjcmVhdGVPYmplY3RVUkwiLCJMb2FkZXJCYXNlU2hhcmVkIiwibWFuYWdlciIsIl9jb25maWciLCJfcmVuZGVyZXIiLCJfaW50ZXJuYWxMb2FkaW5nTWFuYWdlciIsInNldFJlbmRlcmVyIiwic2V0UmVuZGVyVGFyZ2V0T3B0aW9ucyIsIl9yZW5kZXJUYXJnZXRPcHRpb25zIiwicHJlcGFyZVF1YWRSZW5kZXJlciIsIm1heERpc3BsYXlCb29zdCIsInByb2Nlc3NJbWFnZXMiLCJzZHJCdWZmZXIiLCJnYWluTWFwQnVmZmVyIiwiaW1hZ2VPcmllbnRhdGlvbiIsImdhaW5NYXBCbG9iIiwic2RyQmxvYiIsInNkckltYWdlIiwiZ2Fpbk1hcEltYWdlIiwibmVlZHNGbGlwIiwiY3JlYXRlSW1hZ2VCaXRtYXAiLCJyZXMiLCJhbGwiLCJjcmVhdGVUZXh0dXJlcyIsIkltYWdlRGF0YSIsImZsaXBZIiwidXBkYXRlUXVhZFJlbmRlcmVyIiwiTWF0aCIsInBvdyIsIkciLCJMIiwiTSIsIlgiLCJhIiwiYyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@monogrid/gainmap-js/dist/Loader-DLI-_JDP.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@monogrid/gainmap-js/dist/QuadRenderer-Bj1xl_EK.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@monogrid/gainmap-js/dist/QuadRenderer-Bj1xl_EK.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Q: () => (/* binding */ QuadRenderer)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n/**\n * @monogrid/gainmap-js v3.4.0\n * With ‚ù§Ô∏è, by MONOGRID <gainmap@monogrid.com>\n */ \nconst getBufferForType = (type, width, height)=>{\n    let out;\n    switch(type){\n        case three__WEBPACK_IMPORTED_MODULE_0__.UnsignedByteType:\n            out = new Uint8ClampedArray(width * height * 4);\n            break;\n        case three__WEBPACK_IMPORTED_MODULE_0__.HalfFloatType:\n            out = new Uint16Array(width * height * 4);\n            break;\n        case three__WEBPACK_IMPORTED_MODULE_0__.UnsignedIntType:\n            out = new Uint32Array(width * height * 4);\n            break;\n        case three__WEBPACK_IMPORTED_MODULE_0__.ByteType:\n            out = new Int8Array(width * height * 4);\n            break;\n        case three__WEBPACK_IMPORTED_MODULE_0__.ShortType:\n            out = new Int16Array(width * height * 4);\n            break;\n        case three__WEBPACK_IMPORTED_MODULE_0__.IntType:\n            out = new Int32Array(width * height * 4);\n            break;\n        case three__WEBPACK_IMPORTED_MODULE_0__.FloatType:\n            out = new Float32Array(width * height * 4);\n            break;\n        default:\n            throw new Error(\"Unsupported data type\");\n    }\n    return out;\n};\nlet _canReadPixelsResult;\n/**\n * Test if this browser implementation can correctly read pixels from the specified\n * Render target type.\n *\n * Runs only once\n *\n * @param type\n * @param renderer\n * @param camera\n * @param renderTargetOptions\n * @returns\n */ const canReadPixels = (type, renderer, camera, renderTargetOptions)=>{\n    if (_canReadPixelsResult !== undefined) return _canReadPixelsResult;\n    const testRT = new three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderTarget(1, 1, renderTargetOptions);\n    renderer.setRenderTarget(testRT);\n    const mesh = new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(new three__WEBPACK_IMPORTED_MODULE_0__.PlaneGeometry(), new three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial({\n        color: 0xffffff\n    }));\n    renderer.render(mesh, camera);\n    renderer.setRenderTarget(null);\n    const out = getBufferForType(type, testRT.width, testRT.height);\n    renderer.readRenderTargetPixels(testRT, 0, 0, testRT.width, testRT.height, out);\n    testRT.dispose();\n    mesh.geometry.dispose();\n    mesh.material.dispose();\n    _canReadPixelsResult = out[0] !== 0;\n    return _canReadPixelsResult;\n};\n/**\n * Utility class used for rendering a texture with a material\n *\n * @category Core\n * @group Core\n */ class QuadRenderer {\n    /**\n     * Constructs a new QuadRenderer\n     *\n     * @param options Parameters for this QuadRenderer\n     */ constructor(options){\n        this._rendererIsDisposable = false;\n        this._supportsReadPixels = true;\n        /**\n     * Renders the input texture using the specified material\n     */ this.render = ()=>{\n            this._renderer.setRenderTarget(this._renderTarget);\n            try {\n                this._renderer.render(this._scene, this._camera);\n            } catch (e) {\n                this._renderer.setRenderTarget(null);\n                throw e;\n            }\n            this._renderer.setRenderTarget(null);\n        };\n        this._width = options.width;\n        this._height = options.height;\n        this._type = options.type;\n        this._colorSpace = options.colorSpace;\n        const rtOptions = {\n            // fixed options\n            format: three__WEBPACK_IMPORTED_MODULE_0__.RGBAFormat,\n            depthBuffer: false,\n            stencilBuffer: false,\n            // user options\n            type: this._type,\n            colorSpace: this._colorSpace,\n            anisotropy: options.renderTargetOptions?.anisotropy !== undefined ? options.renderTargetOptions?.anisotropy : 1,\n            generateMipmaps: options.renderTargetOptions?.generateMipmaps !== undefined ? options.renderTargetOptions?.generateMipmaps : false,\n            magFilter: options.renderTargetOptions?.magFilter !== undefined ? options.renderTargetOptions?.magFilter : three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter,\n            minFilter: options.renderTargetOptions?.minFilter !== undefined ? options.renderTargetOptions?.minFilter : three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter,\n            samples: options.renderTargetOptions?.samples !== undefined ? options.renderTargetOptions?.samples : undefined,\n            wrapS: options.renderTargetOptions?.wrapS !== undefined ? options.renderTargetOptions?.wrapS : three__WEBPACK_IMPORTED_MODULE_0__.ClampToEdgeWrapping,\n            wrapT: options.renderTargetOptions?.wrapT !== undefined ? options.renderTargetOptions?.wrapT : three__WEBPACK_IMPORTED_MODULE_0__.ClampToEdgeWrapping\n        };\n        this._material = options.material;\n        if (options.renderer) {\n            this._renderer = options.renderer;\n        } else {\n            this._renderer = QuadRenderer.instantiateRenderer();\n            this._rendererIsDisposable = true;\n        }\n        this._scene = new three__WEBPACK_IMPORTED_MODULE_0__.Scene();\n        this._camera = new three__WEBPACK_IMPORTED_MODULE_0__.OrthographicCamera();\n        this._camera.position.set(0, 0, 10);\n        this._camera.left = -0.5;\n        this._camera.right = 0.5;\n        this._camera.top = 0.5;\n        this._camera.bottom = -0.5;\n        this._camera.updateProjectionMatrix();\n        if (!canReadPixels(this._type, this._renderer, this._camera, rtOptions)) {\n            let alternativeType;\n            switch(this._type){\n                case three__WEBPACK_IMPORTED_MODULE_0__.HalfFloatType:\n                    alternativeType = this._renderer.extensions.has(\"EXT_color_buffer_float\") ? three__WEBPACK_IMPORTED_MODULE_0__.FloatType : undefined;\n                    break;\n            }\n            if (alternativeType !== undefined) {\n                console.warn(`This browser does not support reading pixels from ${this._type} RenderTargets, switching to ${three__WEBPACK_IMPORTED_MODULE_0__.FloatType}`);\n                this._type = alternativeType;\n            } else {\n                this._supportsReadPixels = false;\n                console.warn(\"This browser dos not support toArray or toDataTexture, calls to those methods will result in an error thrown\");\n            }\n        }\n        this._quad = new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(new three__WEBPACK_IMPORTED_MODULE_0__.PlaneGeometry(), this._material);\n        this._quad.geometry.computeBoundingBox();\n        this._scene.add(this._quad);\n        this._renderTarget = new three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderTarget(this.width, this.height, rtOptions);\n        this._renderTarget.texture.mapping = options.renderTargetOptions?.mapping !== undefined ? options.renderTargetOptions?.mapping : three__WEBPACK_IMPORTED_MODULE_0__.UVMapping;\n    }\n    /**\n     * Instantiates a temporary renderer\n     *\n     * @returns\n     */ static instantiateRenderer() {\n        const renderer = new three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderer();\n        renderer.setSize(128, 128);\n        // renderer.outputColorSpace = SRGBColorSpace\n        // renderer.toneMapping = LinearToneMapping\n        // renderer.debug.checkShaderErrors = false\n        // this._rendererIsDisposable = true\n        return renderer;\n    }\n    /**\n     * Obtains a Buffer containing the rendered texture.\n     *\n     * @throws Error if the browser cannot read pixels from this RenderTarget type.\n     * @returns a TypedArray containing RGBA values from this renderer\n     */ toArray() {\n        if (!this._supportsReadPixels) throw new Error(\"Can't read pixels in this browser\");\n        const out = getBufferForType(this._type, this._width, this._height);\n        this._renderer.readRenderTargetPixels(this._renderTarget, 0, 0, this._width, this._height, out);\n        return out;\n    }\n    /**\n     * Performs a readPixel operation in the renderTarget\n     * and returns a DataTexture containing the read data\n     *\n     * @param options options\n     * @returns\n     */ toDataTexture(options) {\n        const returnValue = new three__WEBPACK_IMPORTED_MODULE_0__.DataTexture(// fixed values\n        this.toArray(), this.width, this.height, three__WEBPACK_IMPORTED_MODULE_0__.RGBAFormat, this._type, // user values\n        options?.mapping || three__WEBPACK_IMPORTED_MODULE_0__.UVMapping, options?.wrapS || three__WEBPACK_IMPORTED_MODULE_0__.ClampToEdgeWrapping, options?.wrapT || three__WEBPACK_IMPORTED_MODULE_0__.ClampToEdgeWrapping, options?.magFilter || three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter, options?.minFilter || three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter, options?.anisotropy || 1, // fixed value\n        three__WEBPACK_IMPORTED_MODULE_0__.LinearSRGBColorSpace);\n        // set this afterwards, we can't set it in constructor\n        returnValue.generateMipmaps = options?.generateMipmaps !== undefined ? options?.generateMipmaps : false;\n        return returnValue;\n    }\n    /**\n     * If using a disposable renderer, it will dispose it.\n     */ disposeOnDemandRenderer() {\n        this._renderer.setRenderTarget(null);\n        if (this._rendererIsDisposable) {\n            this._renderer.dispose();\n            this._renderer.forceContextLoss();\n        }\n    }\n    /**\n     * Will dispose of **all** assets used by this renderer.\n     *\n     *\n     * @param disposeRenderTarget will dispose of the renderTarget which will not be usable later\n     * set this to true if you passed the `renderTarget.texture` to a `PMREMGenerator`\n     * or are otherwise done with it.\n     *\n     * @example\n     * ```js\n     * const loader = new HDRJPGLoader(renderer)\n     * const result = await loader.loadAsync('gainmap.jpeg')\n     * const mesh = new Mesh(geometry, new MeshBasicMaterial({ map: result.renderTarget.texture }) )\n     * // DO NOT dispose the renderTarget here,\n     * // it is used directly in the material\n     * result.dispose()\n     * ```\n     *\n     * @example\n     * ```js\n     * const loader = new HDRJPGLoader(renderer)\n     * const pmremGenerator = new PMREMGenerator( renderer );\n     * const result = await loader.loadAsync('gainmap.jpeg')\n     * const envMap = pmremGenerator.fromEquirectangular(result.renderTarget.texture)\n     * const mesh = new Mesh(geometry, new MeshStandardMaterial({ envMap }) )\n     * // renderTarget can be disposed here\n     * // because it was used to generate a PMREM texture\n     * result.dispose(true)\n     * ```\n     */ dispose(disposeRenderTarget) {\n        this.disposeOnDemandRenderer();\n        if (disposeRenderTarget) {\n            this.renderTarget.dispose();\n        }\n        // dispose shader material texture uniforms\n        if (this.material instanceof three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial) {\n            Object.values(this.material.uniforms).forEach((v)=>{\n                if (v.value instanceof three__WEBPACK_IMPORTED_MODULE_0__.Texture) v.value.dispose();\n            });\n        }\n        // dispose other material properties\n        Object.values(this.material).forEach((value)=>{\n            if (value instanceof three__WEBPACK_IMPORTED_MODULE_0__.Texture) value.dispose();\n        });\n        this.material.dispose();\n        this._quad.geometry.dispose();\n    }\n    /**\n     * Width of the texture\n     */ get width() {\n        return this._width;\n    }\n    set width(value) {\n        this._width = value;\n        this._renderTarget.setSize(this._width, this._height);\n    }\n    /**\n     * Height of the texture\n     */ get height() {\n        return this._height;\n    }\n    set height(value) {\n        this._height = value;\n        this._renderTarget.setSize(this._width, this._height);\n    }\n    /**\n     * The renderer used\n     */ get renderer() {\n        return this._renderer;\n    }\n    /**\n     * The `WebGLRenderTarget` used.\n     */ get renderTarget() {\n        return this._renderTarget;\n    }\n    set renderTarget(value) {\n        this._renderTarget = value;\n        this._width = value.width;\n        this._height = value.height;\n    // this._type = value.texture.type\n    }\n    /**\n     * The `Material` used.\n     */ get material() {\n        return this._material;\n    }\n    /**\n     *\n     */ get type() {\n        return this._type;\n    }\n    get colorSpace() {\n        return this._colorSpace;\n    }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1vbm9ncmlkL2dhaW5tYXAtanMvZGlzdC9RdWFkUmVuZGVyZXItQmoxeGxfRUsuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTs7O0NBR0MsR0FFNFU7QUFFN1UsTUFBTXNCLG1CQUFtQixDQUFDQyxNQUFNQyxPQUFPQztJQUNuQyxJQUFJQztJQUNKLE9BQVFIO1FBQ0osS0FBS0YsbURBQWdCQTtZQUNqQkssTUFBTSxJQUFJQyxrQkFBa0JILFFBQVFDLFNBQVM7WUFDN0M7UUFDSixLQUFLckIsZ0RBQWFBO1lBQ2RzQixNQUFNLElBQUlFLFlBQVlKLFFBQVFDLFNBQVM7WUFDdkM7UUFDSixLQUFLTCxrREFBZUE7WUFDaEJNLE1BQU0sSUFBSUcsWUFBWUwsUUFBUUMsU0FBUztZQUN2QztRQUNKLEtBQUtOLDJDQUFRQTtZQUNUTyxNQUFNLElBQUlJLFVBQVVOLFFBQVFDLFNBQVM7WUFDckM7UUFDSixLQUFLUCw0Q0FBU0E7WUFDVlEsTUFBTSxJQUFJSyxXQUFXUCxRQUFRQyxTQUFTO1lBQ3RDO1FBQ0osS0FBS1IsMENBQU9BO1lBQ1JTLE1BQU0sSUFBSU0sV0FBV1IsUUFBUUMsU0FBUztZQUN0QztRQUNKLEtBQUtwQiw0Q0FBU0E7WUFDVnFCLE1BQU0sSUFBSU8sYUFBYVQsUUFBUUMsU0FBUztZQUN4QztRQUNKO1lBQ0ksTUFBTSxJQUFJUyxNQUFNO0lBQ3hCO0lBQ0EsT0FBT1I7QUFDWDtBQUNBLElBQUlTO0FBQ0o7Ozs7Ozs7Ozs7O0NBV0MsR0FDRCxNQUFNQyxnQkFBZ0IsQ0FBQ2IsTUFBTWMsVUFBVUMsUUFBUUM7SUFDM0MsSUFBSUoseUJBQXlCSyxXQUN6QixPQUFPTDtJQUNYLE1BQU1NLFNBQVMsSUFBSWpDLG9EQUFpQkEsQ0FBQyxHQUFHLEdBQUcrQjtJQUMzQ0YsU0FBU0ssZUFBZSxDQUFDRDtJQUN6QixNQUFNRSxPQUFPLElBQUlyQyx1Q0FBSUEsQ0FBQyxJQUFJQyxnREFBYUEsSUFBSSxJQUFJUyxvREFBaUJBLENB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Q0QsSUFBSXdCLFdBQVc7UUFBRSxPQUFPLElBQUksQ0FBQzJCLFNBQVM7SUFBRTtJQUN4Qzs7S0FFQyxHQUNELElBQUlyRCxPQUFPO1FBQUUsT0FBTyxJQUFJLENBQUN1QyxLQUFLO0lBQUU7SUFDaEMsSUFBSUUsYUFBYTtRQUFFLE9BQU8sSUFBSSxDQUFDRCxXQUFXO0lBQUU7QUFDaEQ7QUFFNkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ibHVlcHJpbnQtdG8tM2QtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQG1vbm9ncmlkL2dhaW5tYXAtanMvZGlzdC9RdWFkUmVuZGVyZXItQmoxeGxfRUsuanM/MTcwZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBtb25vZ3JpZC9nYWlubWFwLWpzIHYzLjQuMFxuICogV2l0aCDinaTvuI8sIGJ5IE1PTk9HUklEIDxnYWlubWFwQG1vbm9ncmlkLmNvbT5cbiAqL1xuXG5pbXBvcnQgeyBDbGFtcFRvRWRnZVdyYXBwaW5nLCBMaW5lYXJGaWx0ZXIsIFNjZW5lLCBPcnRob2dyYXBoaWNDYW1lcmEsIEhhbGZGbG9hdFR5cGUsIEZsb2F0VHlwZSwgTWVzaCwgUGxhbmVHZW9tZXRyeSwgV2ViR0xSZW5kZXJUYXJnZXQsIFJHQkFGb3JtYXQsIFVWTWFwcGluZywgV2ViR0xSZW5kZXJlciwgRGF0YVRleHR1cmUsIExpbmVhclNSR0JDb2xvclNwYWNlLCBTaGFkZXJNYXRlcmlhbCwgVGV4dHVyZSwgTWVzaEJhc2ljTWF0ZXJpYWwsIEludFR5cGUsIFNob3J0VHlwZSwgQnl0ZVR5cGUsIFVuc2lnbmVkSW50VHlwZSwgVW5zaWduZWRCeXRlVHlwZSB9IGZyb20gJ3RocmVlJztcblxuY29uc3QgZ2V0QnVmZmVyRm9yVHlwZSA9ICh0eXBlLCB3aWR0aCwgaGVpZ2h0KSA9PiB7XG4gICAgbGV0IG91dDtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBVbnNpZ25lZEJ5dGVUeXBlOlxuICAgICAgICAgICAgb3V0ID0gbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KHdpZHRoICogaGVpZ2h0ICogNCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBIYWxmRmxvYXRUeXBlOlxuICAgICAgICAgICAgb3V0ID0gbmV3IFVpbnQxNkFycmF5KHdpZHRoICogaGVpZ2h0ICogNCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBVbnNpZ25lZEludFR5cGU6XG4gICAgICAgICAgICBvdXQgPSBuZXcgVWludDMyQXJyYXkod2lkdGggKiBoZWlnaHQgKiA0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEJ5dGVUeXBlOlxuICAgICAgICAgICAgb3V0ID0gbmV3IEludDhBcnJheSh3aWR0aCAqIGhlaWdodCAqIDQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgU2hvcnRUeXBlOlxuICAgICAgICAgICAgb3V0ID0gbmV3IEludDE2QXJyYXkod2lkdGggKiBoZWlnaHQgKiA0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEludFR5cGU6XG4gICAgICAgICAgICBvdXQgPSBuZXcgSW50MzJBcnJheSh3aWR0aCAqIGhlaWdodCAqIDQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgRmxvYXRUeXBlOlxuICAgICAgICAgICAgb3V0ID0gbmV3IEZsb2F0MzJBcnJheSh3aWR0aCAqIGhlaWdodCAqIDQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIGRhdGEgdHlwZScpO1xuICAgIH1cbiAgICByZXR1cm4gb3V0O1xufTtcbmxldCBfY2FuUmVhZFBpeGVsc1Jlc3VsdDtcbi8qKlxuICogVGVzdCBpZiB0aGlzIGJyb3dzZXIgaW1wbGVtZW50YXRpb24gY2FuIGNvcnJlY3RseSByZWFkIHBpeGVscyBmcm9tIHRoZSBzcGVjaWZpZWRcbiAqIFJlbmRlciB0YXJnZXQgdHlwZS5cbiAqXG4gKiBSdW5zIG9ubHkgb25jZVxuICpcbiAqIEBwYXJhbSB0eXBlXG4gKiBAcGFyYW0gcmVuZGVyZXJcbiAqIEBwYXJhbSBjYW1lcmFcbiAqIEBwYXJhbSByZW5kZXJUYXJnZXRPcHRpb25zXG4gKiBAcmV0dXJuc1xuICovXG5jb25zdCBjYW5SZWFkUGl4ZWxzID0gKHR5cGUsIHJlbmRlcmVyLCBjYW1lcmEsIHJlbmRlclRhcmdldE9wdGlvbnMpID0+IHtcbiAgICBpZiAoX2NhblJlYWRQaXhlbHNSZXN1bHQgIT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIF9jYW5SZWFkUGl4ZWxzUmVzdWx0O1xuICAgIGNvbnN0IHRlc3RSVCA9IG5ldyBXZWJHTFJlbmRlclRhcmdldCgxLCAxLCByZW5kZXJUYXJnZXRPcHRpb25zKTtcbiAgICByZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQodGVzdFJUKTtcbiAgICBjb25zdCBtZXNoID0gbmV3IE1lc2gobmV3IFBsYW5lR2VvbWV0cnkoKSwgbmV3IE1lc2hCYXNpY01hdGVyaWFsKHsgY29sb3I6IDB4ZmZmZmZmIH0pKTtcbiAgICByZW5kZXJlci5yZW5kZXIobWVzaCwgY2FtZXJhKTtcbiAgICByZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQobnVsbCk7XG4gICAgY29uc3Qgb3V0ID0gZ2V0QnVmZmVyRm9yVHlwZSh0eXBlLCB0ZXN0UlQud2lkdGgsIHRlc3RSVC5oZWlnaHQpO1xuICAgIHJlbmRlcmVyLnJlYWRSZW5kZXJUYXJnZXRQaXhlbHModGVzdFJULCAwLCAwLCB0ZXN0UlQud2lkdGgsIHRlc3RSVC5oZWlnaHQsIG91dCk7XG4gICAgdGVzdFJULmRpc3Bvc2UoKTtcbiAgICBtZXNoLmdlb21ldHJ5LmRpc3Bvc2UoKTtcbiAgICBtZXNoLm1hdGVyaWFsLmRpc3Bvc2UoKTtcbiAgICBfY2FuUmVhZFBpeGVsc1Jlc3VsdCA9IG91dFswXSAhPT0gMDtcbiAgICByZXR1cm4gX2NhblJlYWRQaXhlbHNSZXN1bHQ7XG59O1xuLyoqXG4gKiBVdGlsaXR5IGNsYXNzIHVzZWQgZm9yIHJlbmRlcmluZyBhIHRleHR1cmUgd2l0aCBhIG1hdGVyaWFsXG4gKlxuICogQGNhdGVnb3J5IENvcmVcbiAqIEBncm91cCBDb3JlXG4gKi9cbmNsYXNzIFF1YWRSZW5kZXJlciB7XG4gICAgX3JlbmRlcmVyO1xuICAgIF9yZW5kZXJlcklzRGlzcG9zYWJsZSA9IGZhbHNlO1xuICAgIF9tYXRlcmlhbDtcbiAgICBfc2NlbmU7XG4gICAgX2NhbWVyYTtcbiAgICBfcXVhZDtcbiAgICBfcmVuZGVyVGFyZ2V0O1xuICAgIF93aWR0aDtcbiAgICBfaGVpZ2h0O1xuICAgIF90eXBlO1xuICAgIF9jb2xvclNwYWNlO1xuICAgIF9zdXBwb3J0c1JlYWRQaXhlbHMgPSB0cnVlO1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdHMgYSBuZXcgUXVhZFJlbmRlcmVyXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBQYXJhbWV0ZXJzIGZvciB0aGlzIFF1YWRSZW5kZXJlclxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5fd2lkdGggPSBvcHRpb25zLndpZHRoO1xuICAgICAgICB0aGlzLl9oZWlnaHQgPSBvcHRpb25zLmhlaWdodDtcbiAgICAgICAgdGhpcy5fdHlwZSA9IG9wdGlvbnMudHlwZTtcbiAgICAgICAgdGhpcy5fY29sb3JTcGFjZSA9IG9wdGlvbnMuY29sb3JTcGFjZTtcbiAgICAgICAgY29uc3QgcnRPcHRpb25zID0ge1xuICAgICAgICAgICAgLy8gZml4ZWQgb3B0aW9uc1xuICAgICAgICAgICAgZm9ybWF0OiBSR0JBRm9ybWF0LFxuICAgICAgICAgICAgZGVwdGhCdWZmZXI6IGZhbHNlLFxuICAgICAgICAgICAgc3RlbmNpbEJ1ZmZlcjogZmFsc2UsXG4gICAgICAgICAgICAvLyB1c2VyIG9wdGlvbnNcbiAgICAgICAgICAgIHR5cGU6IHRoaXMuX3R5cGUsIC8vIHNldCBpbiBjbGFzcyBwcm9wZXJ0eVxuICAgICAgICAgICAgY29sb3JTcGFjZTogdGhpcy5fY29sb3JTcGFjZSwgLy8gc2V0IGluIGNsYXNzIHByb3BlcnR5XG4gICAgICAgICAgICBhbmlzb3Ryb3B5OiBvcHRpb25zLnJlbmRlclRhcmdldE9wdGlvbnM/LmFuaXNvdHJvcHkgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMucmVuZGVyVGFyZ2V0T3B0aW9ucz8uYW5pc290cm9weSA6IDEsXG4gICAgICAgICAgICBnZW5lcmF0ZU1pcG1hcHM6IG9wdGlvbnMucmVuZGVyVGFyZ2V0T3B0aW9ucz8uZ2VuZXJhdGVNaXBtYXBzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnJlbmRlclRhcmdldE9wdGlvbnM/LmdlbmVyYXRlTWlwbWFwcyA6IGZhbHNlLFxuICAgICAgICAgICAgbWFnRmlsdGVyOiBvcHRpb25zLnJlbmRlclRhcmdldE9wdGlvbnM/Lm1hZ0ZpbHRlciAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5yZW5kZXJUYXJnZXRPcHRpb25zPy5tYWdGaWx0ZXIgOiBMaW5lYXJGaWx0ZXIsXG4gICAgICAgICAgICBtaW5GaWx0ZXI6IG9wdGlvbnMucmVuZGVyVGFyZ2V0T3B0aW9ucz8ubWluRmlsdGVyICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnJlbmRlclRhcmdldE9wdGlvbnM/Lm1pbkZpbHRlciA6IExpbmVhckZpbHRlcixcbiAgICAgICAgICAgIHNhbXBsZXM6IG9wdGlvbnMucmVuZGVyVGFyZ2V0T3B0aW9ucz8uc2FtcGxlcyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5yZW5kZXJUYXJnZXRPcHRpb25zPy5zYW1wbGVzIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgd3JhcFM6IG9wdGlvbnMucmVuZGVyVGFyZ2V0T3B0aW9ucz8ud3JhcFMgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMucmVuZGVyVGFyZ2V0T3B0aW9ucz8ud3JhcFMgOiBDbGFtcFRvRWRnZVdyYXBwaW5nLFxuICAgICAgICAgICAgd3JhcFQ6IG9wdGlvbnMucmVuZGVyVGFyZ2V0T3B0aW9ucz8ud3JhcFQgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMucmVuZGVyVGFyZ2V0T3B0aW9ucz8ud3JhcFQgOiBDbGFtcFRvRWRnZVdyYXBwaW5nXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX21hdGVyaWFsID0gb3B0aW9ucy5tYXRlcmlhbDtcbiAgICAgICAgaWYgKG9wdGlvbnMucmVuZGVyZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyID0gb3B0aW9ucy5yZW5kZXJlcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyID0gUXVhZFJlbmRlcmVyLmluc3RhbnRpYXRlUmVuZGVyZXIoKTtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVySXNEaXNwb3NhYmxlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zY2VuZSA9IG5ldyBTY2VuZSgpO1xuICAgICAgICB0aGlzLl9jYW1lcmEgPSBuZXcgT3J0aG9ncmFwaGljQ2FtZXJhKCk7XG4gICAgICAgIHRoaXMuX2NhbWVyYS5wb3NpdGlvbi5zZXQoMCwgMCwgMTApO1xuICAgICAgICB0aGlzLl9jYW1lcmEubGVmdCA9IC0wLjU7XG4gICAgICAgIHRoaXMuX2NhbWVyYS5yaWdodCA9IDAuNTtcbiAgICAgICAgdGhpcy5fY2FtZXJhLnRvcCA9IDAuNTtcbiAgICAgICAgdGhpcy5fY2FtZXJhLmJvdHRvbSA9IC0wLjU7XG4gICAgICAgIHRoaXMuX2NhbWVyYS51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XG4gICAgICAgIGlmICghY2FuUmVhZFBpeGVscyh0aGlzLl90eXBlLCB0aGlzLl9yZW5kZXJlciwgdGhpcy5fY2FtZXJhLCBydE9wdGlvbnMpKSB7XG4gICAgICAgICAgICBsZXQgYWx0ZXJuYXRpdmVUeXBlO1xuICAgICAgICAgICAgc3dpdGNoICh0aGlzLl90eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBIYWxmRmxvYXRUeXBlOlxuICAgICAgICAgICAgICAgICAgICBhbHRlcm5hdGl2ZVR5cGUgPSB0aGlzLl9yZW5kZXJlci5leHRlbnNpb25zLmhhcygnRVhUX2NvbG9yX2J1ZmZlcl9mbG9hdCcpID8gRmxvYXRUeXBlIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhbHRlcm5hdGl2ZVR5cGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgVGhpcyBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgcmVhZGluZyBwaXhlbHMgZnJvbSAke3RoaXMuX3R5cGV9IFJlbmRlclRhcmdldHMsIHN3aXRjaGluZyB0byAke0Zsb2F0VHlwZX1gKTtcbiAgICAgICAgICAgICAgICB0aGlzLl90eXBlID0gYWx0ZXJuYXRpdmVUeXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3VwcG9ydHNSZWFkUGl4ZWxzID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdUaGlzIGJyb3dzZXIgZG9zIG5vdCBzdXBwb3J0IHRvQXJyYXkgb3IgdG9EYXRhVGV4dHVyZSwgY2FsbHMgdG8gdGhvc2UgbWV0aG9kcyB3aWxsIHJlc3VsdCBpbiBhbiBlcnJvciB0aHJvd24nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9xdWFkID0gbmV3IE1lc2gobmV3IFBsYW5lR2VvbWV0cnkoKSwgdGhpcy5fbWF0ZXJpYWwpO1xuICAgICAgICB0aGlzLl9xdWFkLmdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ0JveCgpO1xuICAgICAgICB0aGlzLl9zY2VuZS5hZGQodGhpcy5fcXVhZCk7XG4gICAgICAgIHRoaXMuX3JlbmRlclRhcmdldCA9IG5ldyBXZWJHTFJlbmRlclRhcmdldCh0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgcnRPcHRpb25zKTtcbiAgICAgICAgdGhpcy5fcmVuZGVyVGFyZ2V0LnRleHR1cmUubWFwcGluZyA9IG9wdGlvbnMucmVuZGVyVGFyZ2V0T3B0aW9ucz8ubWFwcGluZyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5yZW5kZXJUYXJnZXRPcHRpb25zPy5tYXBwaW5nIDogVVZNYXBwaW5nO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnN0YW50aWF0ZXMgYSB0ZW1wb3JhcnkgcmVuZGVyZXJcbiAgICAgKlxuICAgICAqIEByZXR1cm5zXG4gICAgICovXG4gICAgc3RhdGljIGluc3RhbnRpYXRlUmVuZGVyZXIoKSB7XG4gICAgICAgIGNvbnN0IHJlbmRlcmVyID0gbmV3IFdlYkdMUmVuZGVyZXIoKTtcbiAgICAgICAgcmVuZGVyZXIuc2V0U2l6ZSgxMjgsIDEyOCk7XG4gICAgICAgIC8vIHJlbmRlcmVyLm91dHB1dENvbG9yU3BhY2UgPSBTUkdCQ29sb3JTcGFjZVxuICAgICAgICAvLyByZW5kZXJlci50b25lTWFwcGluZyA9IExpbmVhclRvbmVNYXBwaW5nXG4gICAgICAgIC8vIHJlbmRlcmVyLmRlYnVnLmNoZWNrU2hhZGVyRXJyb3JzID0gZmFsc2VcbiAgICAgICAgLy8gdGhpcy5fcmVuZGVyZXJJc0Rpc3Bvc2FibGUgPSB0cnVlXG4gICAgICAgIHJldHVybiByZW5kZXJlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVuZGVycyB0aGUgaW5wdXQgdGV4dHVyZSB1c2luZyB0aGUgc3BlY2lmaWVkIG1hdGVyaWFsXG4gICAgICovXG4gICAgcmVuZGVyID0gKCkgPT4ge1xuICAgICAgICB0aGlzLl9yZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQodGhpcy5fcmVuZGVyVGFyZ2V0KTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLnJlbmRlcih0aGlzLl9zY2VuZSwgdGhpcy5fY2FtZXJhKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KG51bGwpO1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9yZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQobnVsbCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBPYnRhaW5zIGEgQnVmZmVyIGNvbnRhaW5pbmcgdGhlIHJlbmRlcmVkIHRleHR1cmUuXG4gICAgICpcbiAgICAgKiBAdGhyb3dzIEVycm9yIGlmIHRoZSBicm93c2VyIGNhbm5vdCByZWFkIHBpeGVscyBmcm9tIHRoaXMgUmVuZGVyVGFyZ2V0IHR5cGUuXG4gICAgICogQHJldHVybnMgYSBUeXBlZEFycmF5IGNvbnRhaW5pbmcgUkdCQSB2YWx1ZXMgZnJvbSB0aGlzIHJlbmRlcmVyXG4gICAgICovXG4gICAgdG9BcnJheSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9zdXBwb3J0c1JlYWRQaXhlbHMpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhblxcJ3QgcmVhZCBwaXhlbHMgaW4gdGhpcyBicm93c2VyJyk7XG4gICAgICAgIGNvbnN0IG91dCA9IGdldEJ1ZmZlckZvclR5cGUodGhpcy5fdHlwZSwgdGhpcy5fd2lkdGgsIHRoaXMuX2hlaWdodCk7XG4gICAgICAgIHRoaXMuX3JlbmRlcmVyLnJlYWRSZW5kZXJUYXJnZXRQaXhlbHModGhpcy5fcmVuZGVyVGFyZ2V0LCAwLCAwLCB0aGlzLl93aWR0aCwgdGhpcy5faGVpZ2h0LCBvdXQpO1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtcyBhIHJlYWRQaXhlbCBvcGVyYXRpb24gaW4gdGhlIHJlbmRlclRhcmdldFxuICAgICAqIGFuZCByZXR1cm5zIGEgRGF0YVRleHR1cmUgY29udGFpbmluZyB0aGUgcmVhZCBkYXRhXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBvcHRpb25zXG4gICAgICogQHJldHVybnNcbiAgICAgKi9cbiAgICB0b0RhdGFUZXh0dXJlKG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgcmV0dXJuVmFsdWUgPSBuZXcgRGF0YVRleHR1cmUoXG4gICAgICAgIC8vIGZpeGVkIHZhbHVlc1xuICAgICAgICB0aGlzLnRvQXJyYXkoKSwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQsIFJHQkFGb3JtYXQsIHRoaXMuX3R5cGUsIFxuICAgICAgICAvLyB1c2VyIHZhbHVlc1xuICAgICAgICBvcHRpb25zPy5tYXBwaW5nIHx8IFVWTWFwcGluZywgb3B0aW9ucz8ud3JhcFMgfHwgQ2xhbXBUb0VkZ2VXcmFwcGluZywgb3B0aW9ucz8ud3JhcFQgfHwgQ2xhbXBUb0VkZ2VXcmFwcGluZywgb3B0aW9ucz8ubWFnRmlsdGVyIHx8IExpbmVhckZpbHRlciwgb3B0aW9ucz8ubWluRmlsdGVyIHx8IExpbmVhckZpbHRlciwgb3B0aW9ucz8uYW5pc290cm9weSB8fCAxLCBcbiAgICAgICAgLy8gZml4ZWQgdmFsdWVcbiAgICAgICAgTGluZWFyU1JHQkNvbG9yU3BhY2UpO1xuICAgICAgICAvLyBzZXQgdGhpcyBhZnRlcndhcmRzLCB3ZSBjYW4ndCBzZXQgaXQgaW4gY29uc3RydWN0b3JcbiAgICAgICAgcmV0dXJuVmFsdWUuZ2VuZXJhdGVNaXBtYXBzID0gb3B0aW9ucz8uZ2VuZXJhdGVNaXBtYXBzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zPy5nZW5lcmF0ZU1pcG1hcHMgOiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHJldHVyblZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJZiB1c2luZyBhIGRpc3Bvc2FibGUgcmVuZGVyZXIsIGl0IHdpbGwgZGlzcG9zZSBpdC5cbiAgICAgKi9cbiAgICBkaXNwb3NlT25EZW1hbmRSZW5kZXJlcigpIHtcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KG51bGwpO1xuICAgICAgICBpZiAodGhpcy5fcmVuZGVyZXJJc0Rpc3Bvc2FibGUpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLmZvcmNlQ29udGV4dExvc3MoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBXaWxsIGRpc3Bvc2Ugb2YgKiphbGwqKiBhc3NldHMgdXNlZCBieSB0aGlzIHJlbmRlcmVyLlxuICAgICAqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZGlzcG9zZVJlbmRlclRhcmdldCB3aWxsIGRpc3Bvc2Ugb2YgdGhlIHJlbmRlclRhcmdldCB3aGljaCB3aWxsIG5vdCBiZSB1c2FibGUgbGF0ZXJcbiAgICAgKiBzZXQgdGhpcyB0byB0cnVlIGlmIHlvdSBwYXNzZWQgdGhlIGByZW5kZXJUYXJnZXQudGV4dHVyZWAgdG8gYSBgUE1SRU1HZW5lcmF0b3JgXG4gICAgICogb3IgYXJlIG90aGVyd2lzZSBkb25lIHdpdGggaXQuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGpzXG4gICAgICogY29uc3QgbG9hZGVyID0gbmV3IEhEUkpQR0xvYWRlcihyZW5kZXJlcilcbiAgICAgKiBjb25zdCByZXN1bHQgPSBhd2FpdCBsb2FkZXIubG9hZEFzeW5jKCdnYWlubWFwLmpwZWcnKVxuICAgICAqIGNvbnN0IG1lc2ggPSBuZXcgTWVzaChnZW9tZXRyeSwgbmV3IE1lc2hCYXNpY01hdGVyaWFsKHsgbWFwOiByZXN1bHQucmVuZGVyVGFyZ2V0LnRleHR1cmUgfSkgKVxuICAgICAqIC8vIERPIE5PVCBkaXNwb3NlIHRoZSByZW5kZXJUYXJnZXQgaGVyZSxcbiAgICAgKiAvLyBpdCBpcyB1c2VkIGRpcmVjdGx5IGluIHRoZSBtYXRlcmlhbFxuICAgICAqIHJlc3VsdC5kaXNwb3NlKClcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBganNcbiAgICAgKiBjb25zdCBsb2FkZXIgPSBuZXcgSERSSlBHTG9hZGVyKHJlbmRlcmVyKVxuICAgICAqIGNvbnN0IHBtcmVtR2VuZXJhdG9yID0gbmV3IFBNUkVNR2VuZXJhdG9yKCByZW5kZXJlciApO1xuICAgICAqIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGxvYWRlci5sb2FkQXN5bmMoJ2dhaW5tYXAuanBlZycpXG4gICAgICogY29uc3QgZW52TWFwID0gcG1yZW1HZW5lcmF0b3IuZnJvbUVxdWlyZWN0YW5ndWxhcihyZXN1bHQucmVuZGVyVGFyZ2V0LnRleHR1cmUpXG4gICAgICogY29uc3QgbWVzaCA9IG5ldyBNZXNoKGdlb21ldHJ5LCBuZXcgTWVzaFN0YW5kYXJkTWF0ZXJpYWwoeyBlbnZNYXAgfSkgKVxuICAgICAqIC8vIHJlbmRlclRhcmdldCBjYW4gYmUgZGlzcG9zZWQgaGVyZVxuICAgICAqIC8vIGJlY2F1c2UgaXQgd2FzIHVzZWQgdG8gZ2VuZXJhdGUgYSBQTVJFTSB0ZXh0dXJlXG4gICAgICogcmVzdWx0LmRpc3Bvc2UodHJ1ZSlcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBkaXNwb3NlKGRpc3Bvc2VSZW5kZXJUYXJnZXQpIHtcbiAgICAgICAgdGhpcy5kaXNwb3NlT25EZW1hbmRSZW5kZXJlcigpO1xuICAgICAgICBpZiAoZGlzcG9zZVJlbmRlclRhcmdldCkge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJUYXJnZXQuZGlzcG9zZSgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGRpc3Bvc2Ugc2hhZGVyIG1hdGVyaWFsIHRleHR1cmUgdW5pZm9ybXNcbiAgICAgICAgaWYgKHRoaXMubWF0ZXJpYWwgaW5zdGFuY2VvZiBTaGFkZXJNYXRlcmlhbCkge1xuICAgICAgICAgICAgT2JqZWN0LnZhbHVlcyh0aGlzLm1hdGVyaWFsLnVuaWZvcm1zKS5mb3JFYWNoKHYgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh2LnZhbHVlIGluc3RhbmNlb2YgVGV4dHVyZSlcbiAgICAgICAgICAgICAgICAgICAgdi52YWx1ZS5kaXNwb3NlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBkaXNwb3NlIG90aGVyIG1hdGVyaWFsIHByb3BlcnRpZXNcbiAgICAgICAgT2JqZWN0LnZhbHVlcyh0aGlzLm1hdGVyaWFsKS5mb3JFYWNoKHZhbHVlID0+IHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFRleHR1cmUpXG4gICAgICAgICAgICAgICAgdmFsdWUuZGlzcG9zZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5tYXRlcmlhbC5kaXNwb3NlKCk7XG4gICAgICAgIHRoaXMuX3F1YWQuZ2VvbWV0cnkuZGlzcG9zZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXaWR0aCBvZiB0aGUgdGV4dHVyZVxuICAgICAqL1xuICAgIGdldCB3aWR0aCgpIHsgcmV0dXJuIHRoaXMuX3dpZHRoOyB9XG4gICAgc2V0IHdpZHRoKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX3dpZHRoID0gdmFsdWU7XG4gICAgICAgIHRoaXMuX3JlbmRlclRhcmdldC5zZXRTaXplKHRoaXMuX3dpZHRoLCB0aGlzLl9oZWlnaHQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIZWlnaHQgb2YgdGhlIHRleHR1cmVcbiAgICAgKi9cbiAgICBnZXQgaGVpZ2h0KCkgeyByZXR1cm4gdGhpcy5faGVpZ2h0OyB9XG4gICAgc2V0IGhlaWdodCh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9oZWlnaHQgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5fcmVuZGVyVGFyZ2V0LnNldFNpemUodGhpcy5fd2lkdGgsIHRoaXMuX2hlaWdodCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSByZW5kZXJlciB1c2VkXG4gICAgICovXG4gICAgZ2V0IHJlbmRlcmVyKCkgeyByZXR1cm4gdGhpcy5fcmVuZGVyZXI7IH1cbiAgICAvKipcbiAgICAgKiBUaGUgYFdlYkdMUmVuZGVyVGFyZ2V0YCB1c2VkLlxuICAgICAqL1xuICAgIGdldCByZW5kZXJUYXJnZXQoKSB7IHJldHVybiB0aGlzLl9yZW5kZXJUYXJnZXQ7IH1cbiAgICBzZXQgcmVuZGVyVGFyZ2V0KHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX3JlbmRlclRhcmdldCA9IHZhbHVlO1xuICAgICAgICB0aGlzLl93aWR0aCA9IHZhbHVlLndpZHRoO1xuICAgICAgICB0aGlzLl9oZWlnaHQgPSB2YWx1ZS5oZWlnaHQ7XG4gICAgICAgIC8vIHRoaXMuX3R5cGUgPSB2YWx1ZS50ZXh0dXJlLnR5cGVcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGBNYXRlcmlhbGAgdXNlZC5cbiAgICAgKi9cbiAgICBnZXQgbWF0ZXJpYWwoKSB7IHJldHVybiB0aGlzLl9tYXRlcmlhbDsgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgZ2V0IHR5cGUoKSB7IHJldHVybiB0aGlzLl90eXBlOyB9XG4gICAgZ2V0IGNvbG9yU3BhY2UoKSB7IHJldHVybiB0aGlzLl9jb2xvclNwYWNlOyB9XG59XG5cbmV4cG9ydCB7IFF1YWRSZW5kZXJlciBhcyBRIH07XG4iXSwibmFtZXMiOlsiQ2xhbXBUb0VkZ2VXcmFwcGluZyIsIkxpbmVhckZpbHRlciIsIlNjZW5lIiwiT3J0aG9ncmFwaGljQ2FtZXJhIiwiSGFsZkZsb2F0VHlwZSIsIkZsb2F0VHlwZSIsIk1lc2giLCJQbGFuZUdlb21ldHJ5IiwiV2ViR0xSZW5kZXJUYXJnZXQiLCJSR0JBRm9ybWF0IiwiVVZNYXBwaW5nIiwiV2ViR0xSZW5kZXJlciIsIkRhdGFUZXh0dXJlIiwiTGluZWFyU1JHQkNvbG9yU3BhY2UiLCJTaGFkZXJNYXRlcmlhbCIsIlRleHR1cmUiLCJNZXNoQmFzaWNNYXRlcmlhbCIsIkludFR5cGUiLCJTaG9ydFR5cGUiLCJCeXRlVHlwZSIsIlVuc2lnbmVkSW50VHlwZSIsIlVuc2lnbmVkQnl0ZVR5cGUiLCJnZXRCdWZmZXJGb3JUeXBlIiwidHlwZSIsIndpZHRoIiwiaGVpZ2h0Iiwib3V0IiwiVWludDhDbGFtcGVkQXJyYXkiLCJVaW50MTZBcnJheSIsIlVpbnQzMkFycmF5IiwiSW50OEFycmF5IiwiSW50MTZBcnJheSIsIkludDMyQXJyYXkiLCJGbG9hdDMyQXJyYXkiLCJFcnJvciIsIl9jYW5SZWFkUGl4ZWxzUmVzdWx0IiwiY2FuUmVhZFBpeGVscyIsInJlbmRlcmVyIiwiY2FtZXJhIiwicmVuZGVyVGFyZ2V0T3B0aW9ucyIsInVuZGVmaW5lZCIsInRlc3RSVCIsInNldFJlbmRlclRhcmdldCIsIm1lc2giLCJjb2xvciIsInJlbmRlciIsInJlYWRSZW5kZXJUYXJnZXRQaXhlbHMiLCJkaXNwb3NlIiwiZ2VvbWV0cnkiLCJtYXRlcmlhbCIsIlF1YWRSZW5kZXJlciIsImNvbnN0cnVjdG9yIiwib3B0aW9ucyIsIl9yZW5kZXJlcklzRGlzcG9zYWJsZSIsIl9zdXBwb3J0c1JlYWRQaXhlbHMiLCJfcmVuZGVyZXIiLCJfcmVuZGVyVGFyZ2V0IiwiX3NjZW5lIiwiX2NhbWVyYSIsImUiLCJfd2lkdGgiLCJfaGVpZ2h0IiwiX3R5cGUiLCJfY29sb3JTcGFjZSIsImNvbG9yU3BhY2UiLCJydE9wdGlvbnMiLCJmb3JtYXQiLCJkZXB0aEJ1ZmZlciIsInN0ZW5jaWxCdWZmZXIiLCJhbmlzb3Ryb3B5IiwiZ2VuZXJhdGVNaXBtYXBzIiwibWFnRmlsdGVyIiwibWluRmlsdGVyIiwic2FtcGxlcyIsIndyYXBTIiwid3JhcFQiLCJfbWF0ZXJpYWwiLCJpbnN0YW50aWF0ZVJlbmRlcmVyIiwicG9zaXRpb24iLCJzZXQiLCJsZWZ0IiwicmlnaHQiLCJ0b3AiLCJib3R0b20iLCJ1cGRhdGVQcm9qZWN0aW9uTWF0cml4IiwiYWx0ZXJuYXRpdmVUeXBlIiwiZXh0ZW5zaW9ucyIsImhhcyIsImNvbnNvbGUiLCJ3YXJuIiwiX3F1YWQiLCJjb21wdXRlQm91bmRpbmdCb3giLCJhZGQiLCJ0ZXh0dXJlIiwibWFwcGluZyIsInNldFNpemUiLCJ0b0FycmF5IiwidG9EYXRhVGV4dHVyZSIsInJldHVyblZhbHVlIiwiZGlzcG9zZU9uRGVtYW5kUmVuZGVyZXIiLCJmb3JjZUNvbnRleHRMb3NzIiwiZGlzcG9zZVJlbmRlclRhcmdldCIsInJlbmRlclRhcmdldCIsIk9iamVjdCIsInZhbHVlcyIsInVuaWZvcm1zIiwiZm9yRWFjaCIsInYiLCJ2YWx1ZSIsIlEiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@monogrid/gainmap-js/dist/QuadRenderer-Bj1xl_EK.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@monogrid/gainmap-js/dist/decode.js":
/*!**********************************************************!*\
  !*** ./node_modules/@monogrid/gainmap-js/dist/decode.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GainMapDecoderMaterial: () => (/* binding */ GainMapDecoderMaterial),\n/* harmony export */   GainMapLoader: () => (/* binding */ GainMapLoader),\n/* harmony export */   GainMapNotFoundError: () => (/* reexport safe */ _Loader_DLI_JDP_js__WEBPACK_IMPORTED_MODULE_0__.G),\n/* harmony export */   HDRJPGLoader: () => (/* binding */ HDRJPGLoader),\n/* harmony export */   JPEGRLoader: () => (/* binding */ HDRJPGLoader),\n/* harmony export */   LoaderBaseShared: () => (/* reexport safe */ _Loader_DLI_JDP_js__WEBPACK_IMPORTED_MODULE_0__.L),\n/* harmony export */   MPFExtractor: () => (/* reexport safe */ _Loader_DLI_JDP_js__WEBPACK_IMPORTED_MODULE_0__.M),\n/* harmony export */   QuadRenderer: () => (/* reexport safe */ _QuadRenderer_Bj1xl_EK_js__WEBPACK_IMPORTED_MODULE_2__.Q),\n/* harmony export */   XMPMetadataNotFoundError: () => (/* reexport safe */ _Loader_DLI_JDP_js__WEBPACK_IMPORTED_MODULE_0__.X),\n/* harmony export */   createDecodeFunction: () => (/* reexport safe */ _Loader_DLI_JDP_js__WEBPACK_IMPORTED_MODULE_0__.c),\n/* harmony export */   decode: () => (/* binding */ decode),\n/* harmony export */   extractGainmapFromJPEG: () => (/* reexport safe */ _Loader_DLI_JDP_js__WEBPACK_IMPORTED_MODULE_0__.e),\n/* harmony export */   extractXMP: () => (/* reexport safe */ _Loader_DLI_JDP_js__WEBPACK_IMPORTED_MODULE_0__.a)\n/* harmony export */ });\n/* harmony import */ var _QuadRenderer_Bj1xl_EK_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./QuadRenderer-Bj1xl_EK.js */ \"(ssr)/./node_modules/@monogrid/gainmap-js/dist/QuadRenderer-Bj1xl_EK.js\");\n/* harmony import */ var _Loader_DLI_JDP_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Loader-DLI-_JDP.js */ \"(ssr)/./node_modules/@monogrid/gainmap-js/dist/Loader-DLI-_JDP.js\");\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n/**\n * @monogrid/gainmap-js v3.4.0\n * With ‚ù§Ô∏è, by MONOGRID <gainmap@monogrid.com>\n */ \n\n\n\nconst vertexShader = /* glsl */ `\nvarying vec2 vUv;\n\nvoid main() {\n  vUv = uv;\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n`;\nconst fragmentShader = /* glsl */ `\n// min half float value\n#define HALF_FLOAT_MIN vec3( -65504, -65504, -65504 )\n// max half float value\n#define HALF_FLOAT_MAX vec3( 65504, 65504, 65504 )\n\nuniform sampler2D sdr;\nuniform sampler2D gainMap;\nuniform vec3 gamma;\nuniform vec3 offsetHdr;\nuniform vec3 offsetSdr;\nuniform vec3 gainMapMin;\nuniform vec3 gainMapMax;\nuniform float weightFactor;\n\nvarying vec2 vUv;\n\nvoid main() {\n  vec3 rgb = texture2D( sdr, vUv ).rgb;\n  vec3 recovery = texture2D( gainMap, vUv ).rgb;\n  vec3 logRecovery = pow( recovery, gamma );\n  vec3 logBoost = gainMapMin * ( 1.0 - logRecovery ) + gainMapMax * logRecovery;\n  vec3 hdrColor = (rgb + offsetSdr) * exp2( logBoost * weightFactor ) - offsetHdr;\n  vec3 clampedHdrColor = max( HALF_FLOAT_MIN, min( HALF_FLOAT_MAX, hdrColor ));\n  gl_FragColor = vec4( clampedHdrColor , 1.0 );\n}\n`;\n/**\n * A Material which is able to decode the Gainmap into a full HDR Representation\n *\n * @category Materials\n * @group Materials\n */ class GainMapDecoderMaterial extends three__WEBPACK_IMPORTED_MODULE_1__.ShaderMaterial {\n    /**\n     *\n     * @param params\n     */ constructor({ gamma, offsetHdr, offsetSdr, gainMapMin, gainMapMax, maxDisplayBoost, hdrCapacityMin, hdrCapacityMax, sdr, gainMap }){\n        super({\n            name: \"GainMapDecoderMaterial\",\n            vertexShader,\n            fragmentShader,\n            uniforms: {\n                sdr: {\n                    value: sdr\n                },\n                gainMap: {\n                    value: gainMap\n                },\n                gamma: {\n                    value: new three__WEBPACK_IMPORTED_MODULE_1__.Vector3(1.0 / gamma[0], 1.0 / gamma[1], 1.0 / gamma[2])\n                },\n                offsetHdr: {\n                    value: new three__WEBPACK_IMPORTED_MODULE_1__.Vector3().fromArray(offsetHdr)\n                },\n                offsetSdr: {\n                    value: new three__WEBPACK_IMPORTED_MODULE_1__.Vector3().fromArray(offsetSdr)\n                },\n                gainMapMin: {\n                    value: new three__WEBPACK_IMPORTED_MODULE_1__.Vector3().fromArray(gainMapMin)\n                },\n                gainMapMax: {\n                    value: new three__WEBPACK_IMPORTED_MODULE_1__.Vector3().fromArray(gainMapMax)\n                },\n                weightFactor: {\n                    value: (Math.log2(maxDisplayBoost) - hdrCapacityMin) / (hdrCapacityMax - hdrCapacityMin)\n                }\n            },\n            blending: three__WEBPACK_IMPORTED_MODULE_1__.NoBlending,\n            depthTest: false,\n            depthWrite: false\n        });\n        this._maxDisplayBoost = maxDisplayBoost;\n        this._hdrCapacityMin = hdrCapacityMin;\n        this._hdrCapacityMax = hdrCapacityMax;\n        this.needsUpdate = true;\n        this.uniformsNeedUpdate = true;\n    }\n    get sdr() {\n        return this.uniforms.sdr.value;\n    }\n    set sdr(value) {\n        this.uniforms.sdr.value = value;\n    }\n    get gainMap() {\n        return this.uniforms.gainMap.value;\n    }\n    set gainMap(value) {\n        this.uniforms.gainMap.value = value;\n    }\n    /**\n     * @see {@link GainMapMetadata.offsetHdr}\n     */ get offsetHdr() {\n        return this.uniforms.offsetHdr.value.toArray();\n    }\n    set offsetHdr(value) {\n        this.uniforms.offsetHdr.value.fromArray(value);\n    }\n    /**\n     * @see {@link GainMapMetadata.offsetSdr}\n     */ get offsetSdr() {\n        return this.uniforms.offsetSdr.value.toArray();\n    }\n    set offsetSdr(value) {\n        this.uniforms.offsetSdr.value.fromArray(value);\n    }\n    /**\n     * @see {@link GainMapMetadata.gainMapMin}\n     */ get gainMapMin() {\n        return this.uniforms.gainMapMin.value.toArray();\n    }\n    set gainMapMin(value) {\n        this.uniforms.gainMapMin.value.fromArray(value);\n    }\n    /**\n     * @see {@link GainMapMetadata.gainMapMax}\n     */ get gainMapMax() {\n        return this.uniforms.gainMapMax.value.toArray();\n    }\n    set gainMapMax(value) {\n        this.uniforms.gainMapMax.value.fromArray(value);\n    }\n    /**\n     * @see {@link GainMapMetadata.gamma}\n     */ get gamma() {\n        const g = this.uniforms.gamma.value;\n        return [\n            1 / g.x,\n            1 / g.y,\n            1 / g.z\n        ];\n    }\n    set gamma(value) {\n        const g = this.uniforms.gamma.value;\n        g.x = 1.0 / value[0];\n        g.y = 1.0 / value[1];\n        g.z = 1.0 / value[2];\n    }\n    /**\n     * @see {@link GainMapMetadata.hdrCapacityMin}\n     * @remarks Logarithmic space\n     */ get hdrCapacityMin() {\n        return this._hdrCapacityMin;\n    }\n    set hdrCapacityMin(value) {\n        this._hdrCapacityMin = value;\n        this.calculateWeight();\n    }\n    /**\n     * @see {@link GainMapMetadata.hdrCapacityMin}\n     * @remarks Logarithmic space\n     */ get hdrCapacityMax() {\n        return this._hdrCapacityMax;\n    }\n    set hdrCapacityMax(value) {\n        this._hdrCapacityMax = value;\n        this.calculateWeight();\n    }\n    /**\n     * @see {@link GainmapDecodingParameters.maxDisplayBoost}\n     * @remarks Non Logarithmic space\n     */ get maxDisplayBoost() {\n        return this._maxDisplayBoost;\n    }\n    set maxDisplayBoost(value) {\n        this._maxDisplayBoost = Math.max(1, Math.min(65504, value));\n        this.calculateWeight();\n    }\n    calculateWeight() {\n        const val = (Math.log2(this._maxDisplayBoost) - this._hdrCapacityMin) / (this._hdrCapacityMax - this._hdrCapacityMin);\n        this.uniforms.weightFactor.value = Math.max(0, Math.min(1, val));\n    }\n}\nconst decodeImpl = (0,_Loader_DLI_JDP_js__WEBPACK_IMPORTED_MODULE_0__.c)({\n    renderer: three__WEBPACK_IMPORTED_MODULE_1__.WebGLRenderer,\n    createMaterial: (params)=>new GainMapDecoderMaterial(params),\n    createQuadRenderer: (params)=>new _QuadRenderer_Bj1xl_EK_js__WEBPACK_IMPORTED_MODULE_2__.Q(params)\n});\n/**\n * Decodes a gain map using a WebGL RenderTarget\n *\n * @category Decoding Functions\n * @group Decoding Functions\n * @example\n * import { decode } from '@monogrid/gainmap-js'\n * import {\n *   Mesh,\n *   MeshBasicMaterial,\n *   PerspectiveCamera,\n *   PlaneGeometry,\n *   Scene,\n *   TextureLoader,\n *   WebGLRenderer\n * } from 'three'\n *\n * const renderer = new WebGLRenderer()\n *\n * const textureLoader = new TextureLoader()\n *\n * // load SDR Representation\n * const sdr = await textureLoader.loadAsync('sdr.jpg')\n * // load Gain map recovery image\n * const gainMap = await textureLoader.loadAsync('gainmap.jpg')\n * // load metadata\n * const metadata = await (await fetch('metadata.json')).json()\n *\n * const result = decode({\n *   sdr,\n *   gainMap,\n *   // this allows to use `result.renderTarget.texture` directly\n *   renderer,\n *   // this will restore the full HDR range\n *   maxDisplayBoost: Math.pow(2, metadata.hdrCapacityMax),\n *   ...metadata\n * })\n *\n * const scene = new Scene()\n * // `result` can be used to populate a Texture\n * const mesh = new Mesh(\n *   new PlaneGeometry(),\n *   new MeshBasicMaterial({ map: result.renderTarget.texture })\n * )\n * scene.add(mesh)\n * renderer.render(scene, new PerspectiveCamera())\n *\n * // result must be manually disposed\n * // when you are done using it\n * result.dispose()\n *\n * @param params\n * @returns\n * @throws {Error} if the WebGLRenderer fails to render the gain map\n */ const decode = (params)=>{\n    // Ensure renderer is defined for the base function\n    if (!params.renderer) {\n        throw new Error(\"Renderer is required for decode function\");\n    }\n    const quadRenderer = decodeImpl({\n        ...params,\n        renderer: params.renderer\n    });\n    try {\n        quadRenderer.render();\n    } catch (e) {\n        quadRenderer.disposeOnDemandRenderer();\n        throw e;\n    }\n    return quadRenderer;\n};\n/**\n * Base class for WebGL loaders\n * @template TUrl - The type of URL used to load resources\n */ class LoaderBaseWebGL extends _Loader_DLI_JDP_js__WEBPACK_IMPORTED_MODULE_0__.L {\n    constructor(renderer, manager){\n        super({\n            renderer,\n            createMaterial: (params)=>new GainMapDecoderMaterial(params),\n            createQuadRenderer: (params)=>new _QuadRenderer_Bj1xl_EK_js__WEBPACK_IMPORTED_MODULE_2__.Q(params)\n        }, manager);\n    }\n    /**\n     * @private\n     * @param quadRenderer\n     * @param metadata\n     * @param sdrBuffer\n     * @param gainMapBuffer\n     */ async render(quadRenderer, metadata, sdrBuffer, gainMapBuffer) {\n        const { sdrImage, gainMapImage, needsFlip } = await this.processImages(sdrBuffer, gainMapBuffer, \"flipY\");\n        const { gainMap, sdr } = this.createTextures(sdrImage, gainMapImage, needsFlip);\n        this.updateQuadRenderer(quadRenderer, sdrImage, gainMap, sdr, metadata);\n        quadRenderer.render();\n    }\n}\n/**\n * A Three.js Loader for the gain map format.\n *\n * @category Loaders\n * @group Loaders\n *\n * @example\n * import { GainMapLoader } from '@monogrid/gainmap-js'\n * import {\n *   EquirectangularReflectionMapping,\n *   Mesh,\n *   MeshBasicMaterial,\n *   PerspectiveCamera,\n *   PlaneGeometry,\n *   Scene,\n *   WebGLRenderer\n * } from 'three'\n *\n * const renderer = new WebGLRenderer()\n *\n * const loader = new GainMapLoader(renderer)\n *   .setRenderTargetOptions({ mapping: EquirectangularReflectionMapping })\n *\n * const result = await loader.loadAsync(['sdr.jpeg', 'gainmap.jpeg', 'metadata.json'])\n * // `result` can be used to populate a Texture\n *\n * const scene = new Scene()\n * const mesh = new Mesh(\n *   new PlaneGeometry(),\n *   new MeshBasicMaterial({ map: result.renderTarget.texture })\n * )\n * scene.add(mesh)\n * renderer.render(scene, new PerspectiveCamera())\n *\n * // Starting from three.js r159\n * // `result.renderTarget.texture` can\n * // also be used as Equirectangular scene background\n * //\n * // it was previously needed to convert it\n * // to a DataTexture with `result.toDataTexture()`\n * scene.background = result.renderTarget.texture\n *\n * // result must be manually disposed\n * // when you are done using it\n * result.dispose()\n *\n */ class GainMapLoader extends LoaderBaseWebGL {\n    /**\n     * Loads a gainmap using separate data\n     * * sdr image\n     * * gain map image\n     * * metadata json\n     *\n     * useful for webp gain maps\n     *\n     * @param urls An array in the form of [sdr.jpg, gainmap.jpg, metadata.json]\n     * @param onLoad Load complete callback, will receive the result\n     * @param onProgress Progress callback, will receive a `ProgressEvent`\n     * @param onError Error callback\n     * @returns\n     */ load([sdrUrl, gainMapUrl, metadataUrl], onLoad, onProgress, onError) {\n        const quadRenderer = this.prepareQuadRenderer();\n        let sdr;\n        let gainMap;\n        let metadata;\n        const loadCheck = async ()=>{\n            if (sdr && gainMap && metadata) {\n                // solves #16\n                try {\n                    await this.render(quadRenderer, metadata, sdr, gainMap);\n                } catch (error) {\n                    this.manager.itemError(sdrUrl);\n                    this.manager.itemError(gainMapUrl);\n                    this.manager.itemError(metadataUrl);\n                    if (typeof onError === \"function\") onError(error);\n                    quadRenderer.disposeOnDemandRenderer();\n                    return;\n                }\n                if (typeof onLoad === \"function\") onLoad(quadRenderer);\n                this.manager.itemEnd(sdrUrl);\n                this.manager.itemEnd(gainMapUrl);\n                this.manager.itemEnd(metadataUrl);\n                quadRenderer.disposeOnDemandRenderer();\n            }\n        };\n        let sdrLengthComputable = true;\n        let sdrTotal = 0;\n        let sdrLoaded = 0;\n        let gainMapLengthComputable = true;\n        let gainMapTotal = 0;\n        let gainMapLoaded = 0;\n        let metadataLengthComputable = true;\n        let metadataTotal = 0;\n        let metadataLoaded = 0;\n        const progressHandler = ()=>{\n            if (typeof onProgress === \"function\") {\n                const total = sdrTotal + gainMapTotal + metadataTotal;\n                const loaded = sdrLoaded + gainMapLoaded + metadataLoaded;\n                const lengthComputable = sdrLengthComputable && gainMapLengthComputable && metadataLengthComputable;\n                onProgress(new ProgressEvent(\"progress\", {\n                    lengthComputable,\n                    loaded,\n                    total\n                }));\n            }\n        };\n        this.manager.itemStart(sdrUrl);\n        this.manager.itemStart(gainMapUrl);\n        this.manager.itemStart(metadataUrl);\n        const sdrLoader = new three__WEBPACK_IMPORTED_MODULE_1__.FileLoader(this._internalLoadingManager);\n        sdrLoader.setResponseType(\"arraybuffer\");\n        sdrLoader.setRequestHeader(this.requestHeader);\n        sdrLoader.setPath(this.path);\n        sdrLoader.setWithCredentials(this.withCredentials);\n        sdrLoader.load(sdrUrl, async (buffer)=>{\n            /* istanbul ignore if\n             this condition exists only because of three.js types + strict mode\n            */ if (typeof buffer === \"string\") throw new Error(\"Invalid sdr buffer\");\n            sdr = buffer;\n            await loadCheck();\n        }, (e)=>{\n            sdrLengthComputable = e.lengthComputable;\n            sdrLoaded = e.loaded;\n            sdrTotal = e.total;\n            progressHandler();\n        }, (error)=>{\n            this.manager.itemError(sdrUrl);\n            if (typeof onError === \"function\") onError(error);\n        });\n        const gainMapLoader = new three__WEBPACK_IMPORTED_MODULE_1__.FileLoader(this._internalLoadingManager);\n        gainMapLoader.setResponseType(\"arraybuffer\");\n        gainMapLoader.setRequestHeader(this.requestHeader);\n        gainMapLoader.setPath(this.path);\n        gainMapLoader.setWithCredentials(this.withCredentials);\n        gainMapLoader.load(gainMapUrl, async (buffer)=>{\n            /* istanbul ignore if\n             this condition exists only because of three.js types + strict mode\n            */ if (typeof buffer === \"string\") throw new Error(\"Invalid gainmap buffer\");\n            gainMap = buffer;\n            await loadCheck();\n        }, (e)=>{\n            gainMapLengthComputable = e.lengthComputable;\n            gainMapLoaded = e.loaded;\n            gainMapTotal = e.total;\n            progressHandler();\n        }, (error)=>{\n            this.manager.itemError(gainMapUrl);\n            if (typeof onError === \"function\") onError(error);\n        });\n        const metadataLoader = new three__WEBPACK_IMPORTED_MODULE_1__.FileLoader(this._internalLoadingManager);\n        // metadataLoader.setResponseType('json')\n        metadataLoader.setRequestHeader(this.requestHeader);\n        metadataLoader.setPath(this.path);\n        metadataLoader.setWithCredentials(this.withCredentials);\n        metadataLoader.load(metadataUrl, async (json)=>{\n            /* istanbul ignore if\n             this condition exists only because of three.js types + strict mode\n            */ if (typeof json !== \"string\") throw new Error(\"Invalid metadata string\");\n            // TODO: implement check on JSON file and remove this eslint disable\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n            metadata = JSON.parse(json);\n            await loadCheck();\n        }, (e)=>{\n            metadataLengthComputable = e.lengthComputable;\n            metadataLoaded = e.loaded;\n            metadataTotal = e.total;\n            progressHandler();\n        }, (error)=>{\n            this.manager.itemError(metadataUrl);\n            if (typeof onError === \"function\") onError(error);\n        });\n        return quadRenderer;\n    }\n}\n/**\n * A Three.js Loader for a JPEG with embedded gainmap metadata.\n *\n * @category Loaders\n * @group Loaders\n *\n * @example\n * import { HDRJPGLoader } from '@monogrid/gainmap-js'\n * import {\n *   EquirectangularReflectionMapping,\n *   Mesh,\n *   MeshBasicMaterial,\n *   PerspectiveCamera,\n *   PlaneGeometry,\n *   Scene,\n *   WebGLRenderer\n * } from 'three'\n *\n * const renderer = new WebGLRenderer()\n *\n * const loader = new HDRJPGLoader(renderer)\n *   .setRenderTargetOptions({ mapping: EquirectangularReflectionMapping })\n *\n * const result = await loader.loadAsync('gainmap.jpeg')\n * // `result` can be used to populate a Texture\n *\n * const scene = new Scene()\n * const mesh = new Mesh(\n *   new PlaneGeometry(),\n *   new MeshBasicMaterial({ map: result.renderTarget.texture })\n * )\n * scene.add(mesh)\n * renderer.render(scene, new PerspectiveCamera())\n *\n * // Starting from three.js r159\n * // `result.renderTarget.texture` can\n * // also be used as Equirectangular scene background\n * //\n * // it was previously needed to convert it\n * // to a DataTexture with `result.toDataTexture()`\n * scene.background = result.renderTarget.texture\n *\n * // result must be manually disposed\n * // when you are done using it\n * result.dispose()\n *\n */ class HDRJPGLoader extends LoaderBaseWebGL {\n    /**\n     * Loads a JPEG containing gain map metadata\n     * Renders a normal SDR image if gainmap data is not found\n     *\n     * @param url Path to a JPEG file containing embedded gain map metadata\n     * @param onLoad Load complete callback, will receive the result\n     * @param onProgress Progress callback, will receive a `ProgressEvent`\n     * @param onError Error callback\n     * @returns\n     */ load(url, onLoad, onProgress, onError) {\n        const quadRenderer = this.prepareQuadRenderer();\n        const loader = new three__WEBPACK_IMPORTED_MODULE_1__.FileLoader(this._internalLoadingManager);\n        loader.setResponseType(\"arraybuffer\");\n        loader.setRequestHeader(this.requestHeader);\n        loader.setPath(this.path);\n        loader.setWithCredentials(this.withCredentials);\n        this.manager.itemStart(url);\n        loader.load(url, async (jpeg)=>{\n            /* istanbul ignore if\n             this condition exists only because of three.js types + strict mode\n            */ if (typeof jpeg === \"string\") throw new Error(\"Invalid buffer, received [string], was expecting [ArrayBuffer]\");\n            const jpegBuffer = new Uint8Array(jpeg);\n            let sdrJPEG;\n            let gainMapJPEG;\n            let metadata;\n            try {\n                const extractionResult = await (0,_Loader_DLI_JDP_js__WEBPACK_IMPORTED_MODULE_0__.e)(jpegBuffer);\n                // gain map is successfully reconstructed\n                sdrJPEG = extractionResult.sdr;\n                gainMapJPEG = extractionResult.gainMap;\n                metadata = extractionResult.metadata;\n            } catch (e) {\n                // render the SDR version if this is not a gainmap\n                if (e instanceof _Loader_DLI_JDP_js__WEBPACK_IMPORTED_MODULE_0__.X || e instanceof _Loader_DLI_JDP_js__WEBPACK_IMPORTED_MODULE_0__.G) {\n                    console.warn(`Failure to reconstruct an HDR image from ${url}: Gain map metadata not found in the file, HDRJPGLoader will render the SDR jpeg`);\n                    metadata = {\n                        gainMapMin: [\n                            0,\n                            0,\n                            0\n                        ],\n                        gainMapMax: [\n                            1,\n                            1,\n                            1\n                        ],\n                        gamma: [\n                            1,\n                            1,\n                            1\n                        ],\n                        hdrCapacityMin: 0,\n                        hdrCapacityMax: 1,\n                        offsetHdr: [\n                            0,\n                            0,\n                            0\n                        ],\n                        offsetSdr: [\n                            0,\n                            0,\n                            0\n                        ]\n                    };\n                    sdrJPEG = jpegBuffer;\n                } else {\n                    throw e;\n                }\n            }\n            // solves #16\n            try {\n                await this.render(quadRenderer, metadata, sdrJPEG.buffer, gainMapJPEG?.buffer);\n            } catch (error) {\n                this.manager.itemError(url);\n                if (typeof onError === \"function\") onError(error);\n                quadRenderer.disposeOnDemandRenderer();\n                return;\n            }\n            if (typeof onLoad === \"function\") onLoad(quadRenderer);\n            this.manager.itemEnd(url);\n            quadRenderer.disposeOnDemandRenderer();\n        }, onProgress, (error)=>{\n            this.manager.itemError(url);\n            if (typeof onError === \"function\") onError(error);\n        });\n        return quadRenderer;\n    }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1vbm9ncmlkL2dhaW5tYXAtanMvZGlzdC9kZWNvZGUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOzs7Q0FHQyxHQUU4RDtBQUNnSDtBQUNyRztBQUNhO0FBRXZGLE1BQU1xQixlQUFlLFFBQVEsR0FBRyxDQUFDOzs7Ozs7O0FBT2pDLENBQUM7QUFDRCxNQUFNQyxpQkFBaUIsUUFBUSxHQUFHLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBMEJuQyxDQUFDO0FBQ0Q7Ozs7O0NBS0MsR0FDRCxNQUFNQywrQkFBK0JQLGlEQUFjQTtJQUkvQzs7O0tBR0MsR0FDRFEsWUFBWSxFQUFFQyxLQUFLLEVBQUVDLFNBQVMsRUFBRUMsU0FBUyxFQUFFQyxVQUFVLEVBQUVDLFVBQVUsRUFBRUMsZUFBZSxFQUFFQyxjQUFjLEVBQUVDLGNBQWMsRUFBRUMsR0FBRyxFQUFFQyxPQUFPLEVBQUUsQ0FBRTtRQUNoSSxLQUFLLENBQUM7WUFDRkMsTUFBTTtZQUNOZDtZQUNBQztZQUNBYyxVQUFVO2dCQUNOSCxLQUFLO29CQUFFSSxPQUFPSjtnQkFBSTtnQkFDbEJDLFNBQVM7b0JBQUVHLE9BQU9IO2dCQUFRO2dCQUMxQlQsT0FBTztvQkFBRVksT0FBTyxJQUFJbkIsMENBQU9BLENBQUMsTUFBTU8sS0FBSyxDQUFDLEVBQUUsRUFBRSxNQUFNQSxLQUFLLENBQUMsRUFBRSxFQUFFLE1BQU1BLEtBQUssQ0FBQyxFQUFFO2dCQUFFO2dCQUM1RUMsV0FBVztvQkFBRVcsT0FBTyxJQUFJbkIsMENBQU9BLEdBQUdvQixTQUFTLENBQUNaO2dCQUFXO2dCQUN2REMsV0FBVztvQkFBRVUsT0FBTyxJQUFJbkIsMENBQU9BLEdBQUdvQixTQUFTLENBQUNYO2dCQUFXO2dCQUN2REMsWUFBWTtvQkFBRVMsT0FBTyxJQUFJbkIsMENBQU9BLEdBQUdvQixTQUFTLENBQUNWO2dCQUFZO2dCQUN6REMsWUFBWTtvQkFBRVEsT0FBTyxJ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dG8tM2QtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQG1vbm9ncmlkL2dhaW5tYXAtanMvZGlzdC9kZWNvZGUuanM/YTFmNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBtb25vZ3JpZC9nYWlubWFwLWpzIHYzLjQuMFxuICogV2l0aCDinaTvuI8sIGJ5IE1PTk9HUklEIDxnYWlubWFwQG1vbm9ncmlkLmNvbT5cbiAqL1xuXG5pbXBvcnQgeyBRIGFzIFF1YWRSZW5kZXJlciB9IGZyb20gJy4vUXVhZFJlbmRlcmVyLUJqMXhsX0VLLmpzJztcbmltcG9ydCB7IGMgYXMgY3JlYXRlRGVjb2RlRnVuY3Rpb24sIEwgYXMgTG9hZGVyQmFzZVNoYXJlZCwgZSBhcyBleHRyYWN0R2Fpbm1hcEZyb21KUEVHLCBYIGFzIFhNUE1ldGFkYXRhTm90Rm91bmRFcnJvciwgRyBhcyBHYWluTWFwTm90Rm91bmRFcnJvciB9IGZyb20gJy4vTG9hZGVyLURMSS1fSkRQLmpzJztcbmV4cG9ydCB7IE0gYXMgTVBGRXh0cmFjdG9yLCBhIGFzIGV4dHJhY3RYTVAgfSBmcm9tICcuL0xvYWRlci1ETEktX0pEUC5qcyc7XG5pbXBvcnQgeyBTaGFkZXJNYXRlcmlhbCwgTm9CbGVuZGluZywgVmVjdG9yMywgV2ViR0xSZW5kZXJlciwgRmlsZUxvYWRlciB9IGZyb20gJ3RocmVlJztcblxuY29uc3QgdmVydGV4U2hhZGVyID0gLyogZ2xzbCAqLyBgXG52YXJ5aW5nIHZlYzIgdlV2O1xuXG52b2lkIG1haW4oKSB7XG4gIHZVdiA9IHV2O1xuICBnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KHBvc2l0aW9uLCAxLjApO1xufVxuYDtcbmNvbnN0IGZyYWdtZW50U2hhZGVyID0gLyogZ2xzbCAqLyBgXG4vLyBtaW4gaGFsZiBmbG9hdCB2YWx1ZVxuI2RlZmluZSBIQUxGX0ZMT0FUX01JTiB2ZWMzKCAtNjU1MDQsIC02NTUwNCwgLTY1NTA0IClcbi8vIG1heCBoYWxmIGZsb2F0IHZhbHVlXG4jZGVmaW5lIEhBTEZfRkxPQVRfTUFYIHZlYzMoIDY1NTA0LCA2NTUwNCwgNjU1MDQgKVxuXG51bmlmb3JtIHNhbXBsZXIyRCBzZHI7XG51bmlmb3JtIHNhbXBsZXIyRCBnYWluTWFwO1xudW5pZm9ybSB2ZWMzIGdhbW1hO1xudW5pZm9ybSB2ZWMzIG9mZnNldEhkcjtcbnVuaWZvcm0gdmVjMyBvZmZzZXRTZHI7XG51bmlmb3JtIHZlYzMgZ2Fpbk1hcE1pbjtcbnVuaWZvcm0gdmVjMyBnYWluTWFwTWF4O1xudW5pZm9ybSBmbG9hdCB3ZWlnaHRGYWN0b3I7XG5cbnZhcnlpbmcgdmVjMiB2VXY7XG5cbnZvaWQgbWFpbigpIHtcbiAgdmVjMyByZ2IgPSB0ZXh0dXJlMkQoIHNkciwgdlV2ICkucmdiO1xuICB2ZWMzIHJlY292ZXJ5ID0gdGV4dHVyZTJEKCBnYWluTWFwLCB2VXYgKS5yZ2I7XG4gIHZlYzMgbG9nUmVjb3ZlcnkgPSBwb3coIHJlY292ZXJ5LCBnYW1tYSApO1xuICB2ZWMzIGxvZ0Jvb3N0ID0gZ2Fpbk1hcE1pbiAqICggMS4wIC0gbG9nUmVjb3ZlcnkgKSArIGdhaW5NYXBNYXggKiBsb2dSZWNvdmVyeTtcbiAgdmVjMyBoZHJDb2xvciA9IChyZ2IgKyBvZmZzZXRTZHIpICogZXhwMiggbG9nQm9vc3QgKiB3ZWlnaHRGYWN0b3IgKSAtIG9mZnNldEhkcjtcbiAgdmVjMyBjbGFtcGVkSGRyQ29sb3IgPSBtYXgoIEhBTEZfRkxPQVRfTUlOLCBtaW4oIEhBTEZfRkxPQVRfTUFYLCBoZHJDb2xvciApKTtcbiAgZ2xfRnJhZ0NvbG9yID0gdmVjNCggY2xhbXBlZEhkckNvbG9yICwgMS4wICk7XG59XG5gO1xuLyoqXG4gKiBBIE1hdGVyaWFsIHdoaWNoIGlzIGFibGUgdG8gZGVjb2RlIHRoZSBHYWlubWFwIGludG8gYSBmdWxsIEhEUiBSZXByZXNlbnRhdGlvblxuICpcbiAqIEBjYXRlZ29yeSBNYXRlcmlhbHNcbiAqIEBncm91cCBNYXRlcmlhbHNcbiAqL1xuY2xhc3MgR2Fpbk1hcERlY29kZXJNYXRlcmlhbCBleHRlbmRzIFNoYWRlck1hdGVyaWFsIHtcbiAgICBfbWF4RGlzcGxheUJvb3N0O1xuICAgIF9oZHJDYXBhY2l0eU1pbjtcbiAgICBfaGRyQ2FwYWNpdHlNYXg7XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFyYW1zXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoeyBnYW1tYSwgb2Zmc2V0SGRyLCBvZmZzZXRTZHIsIGdhaW5NYXBNaW4sIGdhaW5NYXBNYXgsIG1heERpc3BsYXlCb29zdCwgaGRyQ2FwYWNpdHlNaW4sIGhkckNhcGFjaXR5TWF4LCBzZHIsIGdhaW5NYXAgfSkge1xuICAgICAgICBzdXBlcih7XG4gICAgICAgICAgICBuYW1lOiAnR2Fpbk1hcERlY29kZXJNYXRlcmlhbCcsXG4gICAgICAgICAgICB2ZXJ0ZXhTaGFkZXIsXG4gICAgICAgICAgICBmcmFnbWVudFNoYWRlcixcbiAgICAgICAgICAgIHVuaWZvcm1zOiB7XG4gICAgICAgICAgICAgICAgc2RyOiB7IHZhbHVlOiBzZHIgfSxcbiAgICAgICAgICAgICAgICBnYWluTWFwOiB7IHZhbHVlOiBnYWluTWFwIH0sXG4gICAgICAgICAgICAgICAgZ2FtbWE6IHsgdmFsdWU6IG5ldyBWZWN0b3IzKDEuMCAvIGdhbW1hWzBdLCAxLjAgLyBnYW1tYVsxXSwgMS4wIC8gZ2FtbWFbMl0pIH0sXG4gICAgICAgICAgICAgICAgb2Zmc2V0SGRyOiB7IHZhbHVlOiBuZXcgVmVjdG9yMygpLmZyb21BcnJheShvZmZzZXRIZHIpIH0sXG4gICAgICAgICAgICAgICAgb2Zmc2V0U2RyOiB7IHZhbHVlOiBuZXcgVmVjdG9yMygpLmZyb21BcnJheShvZmZzZXRTZHIpIH0sXG4gICAgICAgICAgICAgICAgZ2Fpbk1hcE1pbjogeyB2YWx1ZTogbmV3IFZlY3RvcjMoKS5mcm9tQXJyYXkoZ2Fpbk1hcE1pbikgfSxcbiAgICAgICAgICAgICAgICBnYWluTWFwTWF4OiB7IHZhbHVlOiBuZXcgVmVjdG9yMygpLmZyb21BcnJheShnYWluTWFwTWF4KSB9LFxuICAgICAgICAgICAgICAgIHdlaWdodEZhY3Rvcjoge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogKE1hdGgubG9nMihtYXhEaXNwbGF5Qm9vc3QpIC0gaGRyQ2FwYWNpdHlNaW4pIC8gKGhkckNhcGFjaXR5TWF4IC0gaGRyQ2FwYWNpdHlNaW4pXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGJsZW5kaW5nOiBOb0JsZW5kaW5nLFxuICAgICAgICAgICAgZGVwdGhUZXN0OiBmYWxzZSxcbiAgICAgICAgICAgIGRlcHRoV3JpdGU6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9tYXhEaXNwbGF5Qm9vc3QgPSBtYXhEaXNwbGF5Qm9vc3Q7XG4gICAgICAgIHRoaXMuX2hkckNhcGFjaXR5TWluID0gaGRyQ2FwYWNpdHlNaW47XG4gICAgICAgIHRoaXMuX2hkckNhcGFjaXR5TWF4ID0gaGRyQ2FwYWNpdHlNYXg7XG4gICAgICAgIHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgICB0aGlzLnVuaWZvcm1zTmVlZFVwZGF0ZSA9IHRydWU7XG4gICAgfVxuICAgIGdldCBzZHIoKSB7IHJldHVybiB0aGlzLnVuaWZvcm1zLnNkci52YWx1ZTsgfVxuICAgIHNldCBzZHIodmFsdWUpIHsgdGhpcy51bmlmb3Jtcy5zZHIudmFsdWUgPSB2YWx1ZTsgfVxuICAgIGdldCBnYWluTWFwKCkgeyByZXR1cm4gdGhpcy51bmlmb3Jtcy5nYWluTWFwLnZhbHVlOyB9XG4gICAgc2V0IGdhaW5NYXAodmFsdWUpIHsgdGhpcy51bmlmb3Jtcy5nYWluTWFwLnZhbHVlID0gdmFsdWU7IH1cbiAgICAvKipcbiAgICAgKiBAc2VlIHtAbGluayBHYWluTWFwTWV0YWRhdGEub2Zmc2V0SGRyfVxuICAgICAqL1xuICAgIGdldCBvZmZzZXRIZHIoKSB7IHJldHVybiB0aGlzLnVuaWZvcm1zLm9mZnNldEhkci52YWx1ZS50b0FycmF5KCk7IH1cbiAgICBzZXQgb2Zmc2V0SGRyKHZhbHVlKSB7IHRoaXMudW5pZm9ybXMub2Zmc2V0SGRyLnZhbHVlLmZyb21BcnJheSh2YWx1ZSk7IH1cbiAgICAvKipcbiAgICAgKiBAc2VlIHtAbGluayBHYWluTWFwTWV0YWRhdGEub2Zmc2V0U2RyfVxuICAgICAqL1xuICAgIGdldCBvZmZzZXRTZHIoKSB7IHJldHVybiB0aGlzLnVuaWZvcm1zLm9mZnNldFNkci52YWx1ZS50b0FycmF5KCk7IH1cbiAgICBzZXQgb2Zmc2V0U2RyKHZhbHVlKSB7IHRoaXMudW5pZm9ybXMub2Zmc2V0U2RyLnZhbHVlLmZyb21BcnJheSh2YWx1ZSk7IH1cbiAgICAvKipcbiAgICAgKiBAc2VlIHtAbGluayBHYWluTWFwTWV0YWRhdGEuZ2Fpbk1hcE1pbn1cbiAgICAgKi9cbiAgICBnZXQgZ2Fpbk1hcE1pbigpIHsgcmV0dXJuIHRoaXMudW5pZm9ybXMuZ2Fpbk1hcE1pbi52YWx1ZS50b0FycmF5KCk7IH1cbiAgICBzZXQgZ2Fpbk1hcE1pbih2YWx1ZSkgeyB0aGlzLnVuaWZvcm1zLmdhaW5NYXBNaW4udmFsdWUuZnJvbUFycmF5KHZhbHVlKTsgfVxuICAgIC8qKlxuICAgICAqIEBzZWUge0BsaW5rIEdhaW5NYXBNZXRhZGF0YS5nYWluTWFwTWF4fVxuICAgICAqL1xuICAgIGdldCBnYWluTWFwTWF4KCkgeyByZXR1cm4gdGhpcy51bmlmb3Jtcy5nYWluTWFwTWF4LnZhbHVlLnRvQXJyYXkoKTsgfVxuICAgIHNldCBnYWluTWFwTWF4KHZhbHVlKSB7IHRoaXMudW5pZm9ybXMuZ2Fpbk1hcE1heC52YWx1ZS5mcm9tQXJyYXkodmFsdWUpOyB9XG4gICAgLyoqXG4gICAgICogQHNlZSB7QGxpbmsgR2Fpbk1hcE1ldGFkYXRhLmdhbW1hfVxuICAgICAqL1xuICAgIGdldCBnYW1tYSgpIHtcbiAgICAgICAgY29uc3QgZyA9IHRoaXMudW5pZm9ybXMuZ2FtbWEudmFsdWU7XG4gICAgICAgIHJldHVybiBbMSAvIGcueCwgMSAvIGcueSwgMSAvIGcuel07XG4gICAgfVxuICAgIHNldCBnYW1tYSh2YWx1ZSkge1xuICAgICAgICBjb25zdCBnID0gdGhpcy51bmlmb3Jtcy5nYW1tYS52YWx1ZTtcbiAgICAgICAgZy54ID0gMS4wIC8gdmFsdWVbMF07XG4gICAgICAgIGcueSA9IDEuMCAvIHZhbHVlWzFdO1xuICAgICAgICBnLnogPSAxLjAgLyB2YWx1ZVsyXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHNlZSB7QGxpbmsgR2Fpbk1hcE1ldGFkYXRhLmhkckNhcGFjaXR5TWlufVxuICAgICAqIEByZW1hcmtzIExvZ2FyaXRobWljIHNwYWNlXG4gICAgICovXG4gICAgZ2V0IGhkckNhcGFjaXR5TWluKCkgeyByZXR1cm4gdGhpcy5faGRyQ2FwYWNpdHlNaW47IH1cbiAgICBzZXQgaGRyQ2FwYWNpdHlNaW4odmFsdWUpIHtcbiAgICAgICAgdGhpcy5faGRyQ2FwYWNpdHlNaW4gPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5jYWxjdWxhdGVXZWlnaHQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHNlZSB7QGxpbmsgR2Fpbk1hcE1ldGFkYXRhLmhkckNhcGFjaXR5TWlufVxuICAgICAqIEByZW1hcmtzIExvZ2FyaXRobWljIHNwYWNlXG4gICAgICovXG4gICAgZ2V0IGhkckNhcGFjaXR5TWF4KCkgeyByZXR1cm4gdGhpcy5faGRyQ2FwYWNpdHlNYXg7IH1cbiAgICBzZXQgaGRyQ2FwYWNpdHlNYXgodmFsdWUpIHtcbiAgICAgICAgdGhpcy5faGRyQ2FwYWNpdHlNYXggPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5jYWxjdWxhdGVXZWlnaHQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHNlZSB7QGxpbmsgR2Fpbm1hcERlY29kaW5nUGFyYW1ldGVycy5tYXhEaXNwbGF5Qm9vc3R9XG4gICAgICogQHJlbWFya3MgTm9uIExvZ2FyaXRobWljIHNwYWNlXG4gICAgICovXG4gICAgZ2V0IG1heERpc3BsYXlCb29zdCgpIHsgcmV0dXJuIHRoaXMuX21heERpc3BsYXlCb29zdDsgfVxuICAgIHNldCBtYXhEaXNwbGF5Qm9vc3QodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fbWF4RGlzcGxheUJvb3N0ID0gTWF0aC5tYXgoMSwgTWF0aC5taW4oNjU1MDQsIHZhbHVlKSk7XG4gICAgICAgIHRoaXMuY2FsY3VsYXRlV2VpZ2h0KCk7XG4gICAgfVxuICAgIGNhbGN1bGF0ZVdlaWdodCgpIHtcbiAgICAgICAgY29uc3QgdmFsID0gKE1hdGgubG9nMih0aGlzLl9tYXhEaXNwbGF5Qm9vc3QpIC0gdGhpcy5faGRyQ2FwYWNpdHlNaW4pIC8gKHRoaXMuX2hkckNhcGFjaXR5TWF4IC0gdGhpcy5faGRyQ2FwYWNpdHlNaW4pO1xuICAgICAgICB0aGlzLnVuaWZvcm1zLndlaWdodEZhY3Rvci52YWx1ZSA9IE1hdGgubWF4KDAsIE1hdGgubWluKDEsIHZhbCkpO1xuICAgIH1cbn1cblxuY29uc3QgZGVjb2RlSW1wbCA9IGNyZWF0ZURlY29kZUZ1bmN0aW9uKHtcbiAgICByZW5kZXJlcjogV2ViR0xSZW5kZXJlcixcbiAgICBjcmVhdGVNYXRlcmlhbDogKHBhcmFtcykgPT4gbmV3IEdhaW5NYXBEZWNvZGVyTWF0ZXJpYWwocGFyYW1zKSxcbiAgICBjcmVhdGVRdWFkUmVuZGVyZXI6IChwYXJhbXMpID0+IG5ldyBRdWFkUmVuZGVyZXIocGFyYW1zKVxufSk7XG4vKipcbiAqIERlY29kZXMgYSBnYWluIG1hcCB1c2luZyBhIFdlYkdMIFJlbmRlclRhcmdldFxuICpcbiAqIEBjYXRlZ29yeSBEZWNvZGluZyBGdW5jdGlvbnNcbiAqIEBncm91cCBEZWNvZGluZyBGdW5jdGlvbnNcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgeyBkZWNvZGUgfSBmcm9tICdAbW9ub2dyaWQvZ2Fpbm1hcC1qcydcbiAqIGltcG9ydCB7XG4gKiAgIE1lc2gsXG4gKiAgIE1lc2hCYXNpY01hdGVyaWFsLFxuICogICBQZXJzcGVjdGl2ZUNhbWVyYSxcbiAqICAgUGxhbmVHZW9tZXRyeSxcbiAqICAgU2NlbmUsXG4gKiAgIFRleHR1cmVMb2FkZXIsXG4gKiAgIFdlYkdMUmVuZGVyZXJcbiAqIH0gZnJvbSAndGhyZWUnXG4gKlxuICogY29uc3QgcmVuZGVyZXIgPSBuZXcgV2ViR0xSZW5kZXJlcigpXG4gKlxuICogY29uc3QgdGV4dHVyZUxvYWRlciA9IG5ldyBUZXh0dXJlTG9hZGVyKClcbiAqXG4gKiAvLyBsb2FkIFNEUiBSZXByZXNlbnRhdGlvblxuICogY29uc3Qgc2RyID0gYXdhaXQgdGV4dHVyZUxvYWRlci5sb2FkQXN5bmMoJ3Nkci5qcGcnKVxuICogLy8gbG9hZCBHYWluIG1hcCByZWNvdmVyeSBpbWFnZVxuICogY29uc3QgZ2Fpbk1hcCA9IGF3YWl0IHRleHR1cmVMb2FkZXIubG9hZEFzeW5jKCdnYWlubWFwLmpwZycpXG4gKiAvLyBsb2FkIG1ldGFkYXRhXG4gKiBjb25zdCBtZXRhZGF0YSA9IGF3YWl0IChhd2FpdCBmZXRjaCgnbWV0YWRhdGEuanNvbicpKS5qc29uKClcbiAqXG4gKiBjb25zdCByZXN1bHQgPSBkZWNvZGUoe1xuICogICBzZHIsXG4gKiAgIGdhaW5NYXAsXG4gKiAgIC8vIHRoaXMgYWxsb3dzIHRvIHVzZSBgcmVzdWx0LnJlbmRlclRhcmdldC50ZXh0dXJlYCBkaXJlY3RseVxuICogICByZW5kZXJlcixcbiAqICAgLy8gdGhpcyB3aWxsIHJlc3RvcmUgdGhlIGZ1bGwgSERSIHJhbmdlXG4gKiAgIG1heERpc3BsYXlCb29zdDogTWF0aC5wb3coMiwgbWV0YWRhdGEuaGRyQ2FwYWNpdHlNYXgpLFxuICogICAuLi5tZXRhZGF0YVxuICogfSlcbiAqXG4gKiBjb25zdCBzY2VuZSA9IG5ldyBTY2VuZSgpXG4gKiAvLyBgcmVzdWx0YCBjYW4gYmUgdXNlZCB0byBwb3B1bGF0ZSBhIFRleHR1cmVcbiAqIGNvbnN0IG1lc2ggPSBuZXcgTWVzaChcbiAqICAgbmV3IFBsYW5lR2VvbWV0cnkoKSxcbiAqICAgbmV3IE1lc2hCYXNpY01hdGVyaWFsKHsgbWFwOiByZXN1bHQucmVuZGVyVGFyZ2V0LnRleHR1cmUgfSlcbiAqIClcbiAqIHNjZW5lLmFkZChtZXNoKVxuICogcmVuZGVyZXIucmVuZGVyKHNjZW5lLCBuZXcgUGVyc3BlY3RpdmVDYW1lcmEoKSlcbiAqXG4gKiAvLyByZXN1bHQgbXVzdCBiZSBtYW51YWxseSBkaXNwb3NlZFxuICogLy8gd2hlbiB5b3UgYXJlIGRvbmUgdXNpbmcgaXRcbiAqIHJlc3VsdC5kaXNwb3NlKClcbiAqXG4gKiBAcGFyYW0gcGFyYW1zXG4gKiBAcmV0dXJuc1xuICogQHRocm93cyB7RXJyb3J9IGlmIHRoZSBXZWJHTFJlbmRlcmVyIGZhaWxzIHRvIHJlbmRlciB0aGUgZ2FpbiBtYXBcbiAqL1xuY29uc3QgZGVjb2RlID0gKHBhcmFtcykgPT4ge1xuICAgIC8vIEVuc3VyZSByZW5kZXJlciBpcyBkZWZpbmVkIGZvciB0aGUgYmFzZSBmdW5jdGlvblxuICAgIGlmICghcGFyYW1zLnJlbmRlcmVyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUmVuZGVyZXIgaXMgcmVxdWlyZWQgZm9yIGRlY29kZSBmdW5jdGlvbicpO1xuICAgIH1cbiAgICBjb25zdCBxdWFkUmVuZGVyZXIgPSBkZWNvZGVJbXBsKHtcbiAgICAgICAgLi4ucGFyYW1zLFxuICAgICAgICByZW5kZXJlcjogcGFyYW1zLnJlbmRlcmVyXG4gICAgfSk7XG4gICAgdHJ5IHtcbiAgICAgICAgcXVhZFJlbmRlcmVyLnJlbmRlcigpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBxdWFkUmVuZGVyZXIuZGlzcG9zZU9uRGVtYW5kUmVuZGVyZXIoKTtcbiAgICAgICAgdGhyb3cgZTtcbiAgICB9XG4gICAgcmV0dXJuIHF1YWRSZW5kZXJlcjtcbn07XG5cbi8qKlxuICogQmFzZSBjbGFzcyBmb3IgV2ViR0wgbG9hZGVyc1xuICogQHRlbXBsYXRlIFRVcmwgLSBUaGUgdHlwZSBvZiBVUkwgdXNlZCB0byBsb2FkIHJlc291cmNlc1xuICovXG5jbGFzcyBMb2FkZXJCYXNlV2ViR0wgZXh0ZW5kcyBMb2FkZXJCYXNlU2hhcmVkIHtcbiAgICBjb25zdHJ1Y3RvcihyZW5kZXJlciwgbWFuYWdlcikge1xuICAgICAgICBzdXBlcih7XG4gICAgICAgICAgICByZW5kZXJlcixcbiAgICAgICAgICAgIGNyZWF0ZU1hdGVyaWFsOiAocGFyYW1zKSA9PiBuZXcgR2Fpbk1hcERlY29kZXJNYXRlcmlhbChwYXJhbXMpLFxuICAgICAgICAgICAgY3JlYXRlUXVhZFJlbmRlcmVyOiAocGFyYW1zKSA9PiBuZXcgUXVhZFJlbmRlcmVyKHBhcmFtcylcbiAgICAgICAgfSwgbWFuYWdlcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHF1YWRSZW5kZXJlclxuICAgICAqIEBwYXJhbSBtZXRhZGF0YVxuICAgICAqIEBwYXJhbSBzZHJCdWZmZXJcbiAgICAgKiBAcGFyYW0gZ2Fpbk1hcEJ1ZmZlclxuICAgICAqL1xuICAgIGFzeW5jIHJlbmRlcihxdWFkUmVuZGVyZXIsIG1ldGFkYXRhLCBzZHJCdWZmZXIsIGdhaW5NYXBCdWZmZXIpIHtcbiAgICAgICAgY29uc3QgeyBzZHJJbWFnZSwgZ2Fpbk1hcEltYWdlLCBuZWVkc0ZsaXAgfSA9IGF3YWl0IHRoaXMucHJvY2Vzc0ltYWdlcyhzZHJCdWZmZXIsIGdhaW5NYXBCdWZmZXIsICdmbGlwWScpO1xuICAgICAgICBjb25zdCB7IGdhaW5NYXAsIHNkciB9ID0gdGhpcy5jcmVhdGVUZXh0dXJlcyhzZHJJbWFnZSwgZ2Fpbk1hcEltYWdlLCBuZWVkc0ZsaXApO1xuICAgICAgICB0aGlzLnVwZGF0ZVF1YWRSZW5kZXJlcihxdWFkUmVuZGVyZXIsIHNkckltYWdlLCBnYWluTWFwLCBzZHIsIG1ldGFkYXRhKTtcbiAgICAgICAgcXVhZFJlbmRlcmVyLnJlbmRlcigpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBBIFRocmVlLmpzIExvYWRlciBmb3IgdGhlIGdhaW4gbWFwIGZvcm1hdC5cbiAqXG4gKiBAY2F0ZWdvcnkgTG9hZGVyc1xuICogQGdyb3VwIExvYWRlcnNcbiAqXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IHsgR2Fpbk1hcExvYWRlciB9IGZyb20gJ0Btb25vZ3JpZC9nYWlubWFwLWpzJ1xuICogaW1wb3J0IHtcbiAqICAgRXF1aXJlY3Rhbmd1bGFyUmVmbGVjdGlvbk1hcHBpbmcsXG4gKiAgIE1lc2gsXG4gKiAgIE1lc2hCYXNpY01hdGVyaWFsLFxuICogICBQZXJzcGVjdGl2ZUNhbWVyYSxcbiAqICAgUGxhbmVHZW9tZXRyeSxcbiAqICAgU2NlbmUsXG4gKiAgIFdlYkdMUmVuZGVyZXJcbiAqIH0gZnJvbSAndGhyZWUnXG4gKlxuICogY29uc3QgcmVuZGVyZXIgPSBuZXcgV2ViR0xSZW5kZXJlcigpXG4gKlxuICogY29uc3QgbG9hZGVyID0gbmV3IEdhaW5NYXBMb2FkZXIocmVuZGVyZXIpXG4gKiAgIC5zZXRSZW5kZXJUYXJnZXRPcHRpb25zKHsgbWFwcGluZzogRXF1aXJlY3Rhbmd1bGFyUmVmbGVjdGlvbk1hcHBpbmcgfSlcbiAqXG4gKiBjb25zdCByZXN1bHQgPSBhd2FpdCBsb2FkZXIubG9hZEFzeW5jKFsnc2RyLmpwZWcnLCAnZ2Fpbm1hcC5qcGVnJywgJ21ldGFkYXRhLmpzb24nXSlcbiAqIC8vIGByZXN1bHRgIGNhbiBiZSB1c2VkIHRvIHBvcHVsYXRlIGEgVGV4dHVyZVxuICpcbiAqIGNvbnN0IHNjZW5lID0gbmV3IFNjZW5lKClcbiAqIGNvbnN0IG1lc2ggPSBuZXcgTWVzaChcbiAqICAgbmV3IFBsYW5lR2VvbWV0cnkoKSxcbiAqICAgbmV3IE1lc2hCYXNpY01hdGVyaWFsKHsgbWFwOiByZXN1bHQucmVuZGVyVGFyZ2V0LnRleHR1cmUgfSlcbiAqIClcbiAqIHNjZW5lLmFkZChtZXNoKVxuICogcmVuZGVyZXIucmVuZGVyKHNjZW5lLCBuZXcgUGVyc3BlY3RpdmVDYW1lcmEoKSlcbiAqXG4gKiAvLyBTdGFydGluZyBmcm9tIHRocmVlLmpzIHIxNTlcbiAqIC8vIGByZXN1bHQucmVuZGVyVGFyZ2V0LnRleHR1cmVgIGNhblxuICogLy8gYWxzbyBiZSB1c2VkIGFzIEVxdWlyZWN0YW5ndWxhciBzY2VuZSBiYWNrZ3JvdW5kXG4gKiAvL1xuICogLy8gaXQgd2FzIHByZXZpb3VzbHkgbmVlZGVkIHRvIGNvbnZlcnQgaXRcbiAqIC8vIHRvIGEgRGF0YVRleHR1cmUgd2l0aCBgcmVzdWx0LnRvRGF0YVRleHR1cmUoKWBcbiAqIHNjZW5lLmJhY2tncm91bmQgPSByZXN1bHQucmVuZGVyVGFyZ2V0LnRleHR1cmVcbiAqXG4gKiAvLyByZXN1bHQgbXVzdCBiZSBtYW51YWxseSBkaXNwb3NlZFxuICogLy8gd2hlbiB5b3UgYXJlIGRvbmUgdXNpbmcgaXRcbiAqIHJlc3VsdC5kaXNwb3NlKClcbiAqXG4gKi9cbmNsYXNzIEdhaW5NYXBMb2FkZXIgZXh0ZW5kcyBMb2FkZXJCYXNlV2ViR0wge1xuICAgIC8qKlxuICAgICAqIExvYWRzIGEgZ2Fpbm1hcCB1c2luZyBzZXBhcmF0ZSBkYXRhXG4gICAgICogKiBzZHIgaW1hZ2VcbiAgICAgKiAqIGdhaW4gbWFwIGltYWdlXG4gICAgICogKiBtZXRhZGF0YSBqc29uXG4gICAgICpcbiAgICAgKiB1c2VmdWwgZm9yIHdlYnAgZ2FpbiBtYXBzXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdXJscyBBbiBhcnJheSBpbiB0aGUgZm9ybSBvZiBbc2RyLmpwZywgZ2Fpbm1hcC5qcGcsIG1ldGFkYXRhLmpzb25dXG4gICAgICogQHBhcmFtIG9uTG9hZCBMb2FkIGNvbXBsZXRlIGNhbGxiYWNrLCB3aWxsIHJlY2VpdmUgdGhlIHJlc3VsdFxuICAgICAqIEBwYXJhbSBvblByb2dyZXNzIFByb2dyZXNzIGNhbGxiYWNrLCB3aWxsIHJlY2VpdmUgYSBgUHJvZ3Jlc3NFdmVudGBcbiAgICAgKiBAcGFyYW0gb25FcnJvciBFcnJvciBjYWxsYmFja1xuICAgICAqIEByZXR1cm5zXG4gICAgICovXG4gICAgbG9hZChbc2RyVXJsLCBnYWluTWFwVXJsLCBtZXRhZGF0YVVybF0sIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvcikge1xuICAgICAgICBjb25zdCBxdWFkUmVuZGVyZXIgPSB0aGlzLnByZXBhcmVRdWFkUmVuZGVyZXIoKTtcbiAgICAgICAgbGV0IHNkcjtcbiAgICAgICAgbGV0IGdhaW5NYXA7XG4gICAgICAgIGxldCBtZXRhZGF0YTtcbiAgICAgICAgY29uc3QgbG9hZENoZWNrID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHNkciAmJiBnYWluTWFwICYmIG1ldGFkYXRhKSB7XG4gICAgICAgICAgICAgICAgLy8gc29sdmVzICMxNlxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucmVuZGVyKHF1YWRSZW5kZXJlciwgbWV0YWRhdGEsIHNkciwgZ2Fpbk1hcCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1hbmFnZXIuaXRlbUVycm9yKHNkclVybCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWFuYWdlci5pdGVtRXJyb3IoZ2Fpbk1hcFVybCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWFuYWdlci5pdGVtRXJyb3IobWV0YWRhdGFVcmwpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9uRXJyb3IgPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkVycm9yKGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgcXVhZFJlbmRlcmVyLmRpc3Bvc2VPbkRlbWFuZFJlbmRlcmVyKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvbkxvYWQgPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICAgICAgICAgIG9uTG9hZChxdWFkUmVuZGVyZXIpO1xuICAgICAgICAgICAgICAgIHRoaXMubWFuYWdlci5pdGVtRW5kKHNkclVybCk7XG4gICAgICAgICAgICAgICAgdGhpcy5tYW5hZ2VyLml0ZW1FbmQoZ2Fpbk1hcFVybCk7XG4gICAgICAgICAgICAgICAgdGhpcy5tYW5hZ2VyLml0ZW1FbmQobWV0YWRhdGFVcmwpO1xuICAgICAgICAgICAgICAgIHF1YWRSZW5kZXJlci5kaXNwb3NlT25EZW1hbmRSZW5kZXJlcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBsZXQgc2RyTGVuZ3RoQ29tcHV0YWJsZSA9IHRydWU7XG4gICAgICAgIGxldCBzZHJUb3RhbCA9IDA7XG4gICAgICAgIGxldCBzZHJMb2FkZWQgPSAwO1xuICAgICAgICBsZXQgZ2Fpbk1hcExlbmd0aENvbXB1dGFibGUgPSB0cnVlO1xuICAgICAgICBsZXQgZ2Fpbk1hcFRvdGFsID0gMDtcbiAgICAgICAgbGV0IGdhaW5NYXBMb2FkZWQgPSAwO1xuICAgICAgICBsZXQgbWV0YWRhdGFMZW5ndGhDb21wdXRhYmxlID0gdHJ1ZTtcbiAgICAgICAgbGV0IG1ldGFkYXRhVG90YWwgPSAwO1xuICAgICAgICBsZXQgbWV0YWRhdGFMb2FkZWQgPSAwO1xuICAgICAgICBjb25zdCBwcm9ncmVzc0hhbmRsZXIgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9uUHJvZ3Jlc3MgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0b3RhbCA9IHNkclRvdGFsICsgZ2Fpbk1hcFRvdGFsICsgbWV0YWRhdGFUb3RhbDtcbiAgICAgICAgICAgICAgICBjb25zdCBsb2FkZWQgPSBzZHJMb2FkZWQgKyBnYWluTWFwTG9hZGVkICsgbWV0YWRhdGFMb2FkZWQ7XG4gICAgICAgICAgICAgICAgY29uc3QgbGVuZ3RoQ29tcHV0YWJsZSA9IHNkckxlbmd0aENvbXB1dGFibGUgJiYgZ2Fpbk1hcExlbmd0aENvbXB1dGFibGUgJiYgbWV0YWRhdGFMZW5ndGhDb21wdXRhYmxlO1xuICAgICAgICAgICAgICAgIG9uUHJvZ3Jlc3MobmV3IFByb2dyZXNzRXZlbnQoJ3Byb2dyZXNzJywgeyBsZW5ndGhDb21wdXRhYmxlLCBsb2FkZWQsIHRvdGFsIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5tYW5hZ2VyLml0ZW1TdGFydChzZHJVcmwpO1xuICAgICAgICB0aGlzLm1hbmFnZXIuaXRlbVN0YXJ0KGdhaW5NYXBVcmwpO1xuICAgICAgICB0aGlzLm1hbmFnZXIuaXRlbVN0YXJ0KG1ldGFkYXRhVXJsKTtcbiAgICAgICAgY29uc3Qgc2RyTG9hZGVyID0gbmV3IEZpbGVMb2FkZXIodGhpcy5faW50ZXJuYWxMb2FkaW5nTWFuYWdlcik7XG4gICAgICAgIHNkckxvYWRlci5zZXRSZXNwb25zZVR5cGUoJ2FycmF5YnVmZmVyJyk7XG4gICAgICAgIHNkckxvYWRlci5zZXRSZXF1ZXN0SGVhZGVyKHRoaXMucmVxdWVzdEhlYWRlcik7XG4gICAgICAgIHNkckxvYWRlci5zZXRQYXRoKHRoaXMucGF0aCk7XG4gICAgICAgIHNkckxvYWRlci5zZXRXaXRoQ3JlZGVudGlhbHModGhpcy53aXRoQ3JlZGVudGlhbHMpO1xuICAgICAgICBzZHJMb2FkZXIubG9hZChzZHJVcmwsIGFzeW5jIChidWZmZXIpID0+IHtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZlxuICAgICAgICAgICAgIHRoaXMgY29uZGl0aW9uIGV4aXN0cyBvbmx5IGJlY2F1c2Ugb2YgdGhyZWUuanMgdHlwZXMgKyBzdHJpY3QgbW9kZVxuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmICh0eXBlb2YgYnVmZmVyID09PSAnc3RyaW5nJylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc2RyIGJ1ZmZlcicpO1xuICAgICAgICAgICAgc2RyID0gYnVmZmVyO1xuICAgICAgICAgICAgYXdhaXQgbG9hZENoZWNrKCk7XG4gICAgICAgIH0sIChlKSA9PiB7XG4gICAgICAgICAgICBzZHJMZW5ndGhDb21wdXRhYmxlID0gZS5sZW5ndGhDb21wdXRhYmxlO1xuICAgICAgICAgICAgc2RyTG9hZGVkID0gZS5sb2FkZWQ7XG4gICAgICAgICAgICBzZHJUb3RhbCA9IGUudG90YWw7XG4gICAgICAgICAgICBwcm9ncmVzc0hhbmRsZXIoKTtcbiAgICAgICAgfSwgKGVycm9yKSA9PiB7XG4gICAgICAgICAgICB0aGlzLm1hbmFnZXIuaXRlbUVycm9yKHNkclVybCk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9uRXJyb3IgPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICAgICAgb25FcnJvcihlcnJvcik7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBnYWluTWFwTG9hZGVyID0gbmV3IEZpbGVMb2FkZXIodGhpcy5faW50ZXJuYWxMb2FkaW5nTWFuYWdlcik7XG4gICAgICAgIGdhaW5NYXBMb2FkZXIuc2V0UmVzcG9uc2VUeXBlKCdhcnJheWJ1ZmZlcicpO1xuICAgICAgICBnYWluTWFwTG9hZGVyLnNldFJlcXVlc3RIZWFkZXIodGhpcy5yZXF1ZXN0SGVhZGVyKTtcbiAgICAgICAgZ2Fpbk1hcExvYWRlci5zZXRQYXRoKHRoaXMucGF0aCk7XG4gICAgICAgIGdhaW5NYXBMb2FkZXIuc2V0V2l0aENyZWRlbnRpYWxzKHRoaXMud2l0aENyZWRlbnRpYWxzKTtcbiAgICAgICAgZ2Fpbk1hcExvYWRlci5sb2FkKGdhaW5NYXBVcmwsIGFzeW5jIChidWZmZXIpID0+IHtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZlxuICAgICAgICAgICAgIHRoaXMgY29uZGl0aW9uIGV4aXN0cyBvbmx5IGJlY2F1c2Ugb2YgdGhyZWUuanMgdHlwZXMgKyBzdHJpY3QgbW9kZVxuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmICh0eXBlb2YgYnVmZmVyID09PSAnc3RyaW5nJylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgZ2Fpbm1hcCBidWZmZXInKTtcbiAgICAgICAgICAgIGdhaW5NYXAgPSBidWZmZXI7XG4gICAgICAgICAgICBhd2FpdCBsb2FkQ2hlY2soKTtcbiAgICAgICAgfSwgKGUpID0+IHtcbiAgICAgICAgICAgIGdhaW5NYXBMZW5ndGhDb21wdXRhYmxlID0gZS5sZW5ndGhDb21wdXRhYmxlO1xuICAgICAgICAgICAgZ2Fpbk1hcExvYWRlZCA9IGUubG9hZGVkO1xuICAgICAgICAgICAgZ2Fpbk1hcFRvdGFsID0gZS50b3RhbDtcbiAgICAgICAgICAgIHByb2dyZXNzSGFuZGxlcigpO1xuICAgICAgICB9LCAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgIHRoaXMubWFuYWdlci5pdGVtRXJyb3IoZ2Fpbk1hcFVybCk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9uRXJyb3IgPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICAgICAgb25FcnJvcihlcnJvcik7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBtZXRhZGF0YUxvYWRlciA9IG5ldyBGaWxlTG9hZGVyKHRoaXMuX2ludGVybmFsTG9hZGluZ01hbmFnZXIpO1xuICAgICAgICAvLyBtZXRhZGF0YUxvYWRlci5zZXRSZXNwb25zZVR5cGUoJ2pzb24nKVxuICAgICAgICBtZXRhZGF0YUxvYWRlci5zZXRSZXF1ZXN0SGVhZGVyKHRoaXMucmVxdWVzdEhlYWRlcik7XG4gICAgICAgIG1ldGFkYXRhTG9hZGVyLnNldFBhdGgodGhpcy5wYXRoKTtcbiAgICAgICAgbWV0YWRhdGFMb2FkZXIuc2V0V2l0aENyZWRlbnRpYWxzKHRoaXMud2l0aENyZWRlbnRpYWxzKTtcbiAgICAgICAgbWV0YWRhdGFMb2FkZXIubG9hZChtZXRhZGF0YVVybCwgYXN5bmMgKGpzb24pID0+IHtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZlxuICAgICAgICAgICAgIHRoaXMgY29uZGl0aW9uIGV4aXN0cyBvbmx5IGJlY2F1c2Ugb2YgdGhyZWUuanMgdHlwZXMgKyBzdHJpY3QgbW9kZVxuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmICh0eXBlb2YganNvbiAhPT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG1ldGFkYXRhIHN0cmluZycpO1xuICAgICAgICAgICAgLy8gVE9ETzogaW1wbGVtZW50IGNoZWNrIG9uIEpTT04gZmlsZSBhbmQgcmVtb3ZlIHRoaXMgZXNsaW50IGRpc2FibGVcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFzc2lnbm1lbnRcbiAgICAgICAgICAgIG1ldGFkYXRhID0gSlNPTi5wYXJzZShqc29uKTtcbiAgICAgICAgICAgIGF3YWl0IGxvYWRDaGVjaygpO1xuICAgICAgICB9LCAoZSkgPT4ge1xuICAgICAgICAgICAgbWV0YWRhdGFMZW5ndGhDb21wdXRhYmxlID0gZS5sZW5ndGhDb21wdXRhYmxlO1xuICAgICAgICAgICAgbWV0YWRhdGFMb2FkZWQgPSBlLmxvYWRlZDtcbiAgICAgICAgICAgIG1ldGFkYXRhVG90YWwgPSBlLnRvdGFsO1xuICAgICAgICAgICAgcHJvZ3Jlc3NIYW5kbGVyKCk7XG4gICAgICAgIH0sIChlcnJvcikgPT4ge1xuICAgICAgICAgICAgdGhpcy5tYW5hZ2VyLml0ZW1FcnJvcihtZXRhZGF0YVVybCk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9uRXJyb3IgPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICAgICAgb25FcnJvcihlcnJvcik7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcXVhZFJlbmRlcmVyO1xuICAgIH1cbn1cblxuLyoqXG4gKiBBIFRocmVlLmpzIExvYWRlciBmb3IgYSBKUEVHIHdpdGggZW1iZWRkZWQgZ2Fpbm1hcCBtZXRhZGF0YS5cbiAqXG4gKiBAY2F0ZWdvcnkgTG9hZGVyc1xuICogQGdyb3VwIExvYWRlcnNcbiAqXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IHsgSERSSlBHTG9hZGVyIH0gZnJvbSAnQG1vbm9ncmlkL2dhaW5tYXAtanMnXG4gKiBpbXBvcnQge1xuICogICBFcXVpcmVjdGFuZ3VsYXJSZWZsZWN0aW9uTWFwcGluZyxcbiAqICAgTWVzaCxcbiAqICAgTWVzaEJhc2ljTWF0ZXJpYWwsXG4gKiAgIFBlcnNwZWN0aXZlQ2FtZXJhLFxuICogICBQbGFuZUdlb21ldHJ5LFxuICogICBTY2VuZSxcbiAqICAgV2ViR0xSZW5kZXJlclxuICogfSBmcm9tICd0aHJlZSdcbiAqXG4gKiBjb25zdCByZW5kZXJlciA9IG5ldyBXZWJHTFJlbmRlcmVyKClcbiAqXG4gKiBjb25zdCBsb2FkZXIgPSBuZXcgSERSSlBHTG9hZGVyKHJlbmRlcmVyKVxuICogICAuc2V0UmVuZGVyVGFyZ2V0T3B0aW9ucyh7IG1hcHBpbmc6IEVxdWlyZWN0YW5ndWxhclJlZmxlY3Rpb25NYXBwaW5nIH0pXG4gKlxuICogY29uc3QgcmVzdWx0ID0gYXdhaXQgbG9hZGVyLmxvYWRBc3luYygnZ2Fpbm1hcC5qcGVnJylcbiAqIC8vIGByZXN1bHRgIGNhbiBiZSB1c2VkIHRvIHBvcHVsYXRlIGEgVGV4dHVyZVxuICpcbiAqIGNvbnN0IHNjZW5lID0gbmV3IFNjZW5lKClcbiAqIGNvbnN0IG1lc2ggPSBuZXcgTWVzaChcbiAqICAgbmV3IFBsYW5lR2VvbWV0cnkoKSxcbiAqICAgbmV3IE1lc2hCYXNpY01hdGVyaWFsKHsgbWFwOiByZXN1bHQucmVuZGVyVGFyZ2V0LnRleHR1cmUgfSlcbiAqIClcbiAqIHNjZW5lLmFkZChtZXNoKVxuICogcmVuZGVyZXIucmVuZGVyKHNjZW5lLCBuZXcgUGVyc3BlY3RpdmVDYW1lcmEoKSlcbiAqXG4gKiAvLyBTdGFydGluZyBmcm9tIHRocmVlLmpzIHIxNTlcbiAqIC8vIGByZXN1bHQucmVuZGVyVGFyZ2V0LnRleHR1cmVgIGNhblxuICogLy8gYWxzbyBiZSB1c2VkIGFzIEVxdWlyZWN0YW5ndWxhciBzY2VuZSBiYWNrZ3JvdW5kXG4gKiAvL1xuICogLy8gaXQgd2FzIHByZXZpb3VzbHkgbmVlZGVkIHRvIGNvbnZlcnQgaXRcbiAqIC8vIHRvIGEgRGF0YVRleHR1cmUgd2l0aCBgcmVzdWx0LnRvRGF0YVRleHR1cmUoKWBcbiAqIHNjZW5lLmJhY2tncm91bmQgPSByZXN1bHQucmVuZGVyVGFyZ2V0LnRleHR1cmVcbiAqXG4gKiAvLyByZXN1bHQgbXVzdCBiZSBtYW51YWxseSBkaXNwb3NlZFxuICogLy8gd2hlbiB5b3UgYXJlIGRvbmUgdXNpbmcgaXRcbiAqIHJlc3VsdC5kaXNwb3NlKClcbiAqXG4gKi9cbmNsYXNzIEhEUkpQR0xvYWRlciBleHRlbmRzIExvYWRlckJhc2VXZWJHTCB7XG4gICAgLyoqXG4gICAgICogTG9hZHMgYSBKUEVHIGNvbnRhaW5pbmcgZ2FpbiBtYXAgbWV0YWRhdGFcbiAgICAgKiBSZW5kZXJzIGEgbm9ybWFsIFNEUiBpbWFnZSBpZiBnYWlubWFwIGRhdGEgaXMgbm90IGZvdW5kXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdXJsIFBhdGggdG8gYSBKUEVHIGZpbGUgY29udGFpbmluZyBlbWJlZGRlZCBnYWluIG1hcCBtZXRhZGF0YVxuICAgICAqIEBwYXJhbSBvbkxvYWQgTG9hZCBjb21wbGV0ZSBjYWxsYmFjaywgd2lsbCByZWNlaXZlIHRoZSByZXN1bHRcbiAgICAgKiBAcGFyYW0gb25Qcm9ncmVzcyBQcm9ncmVzcyBjYWxsYmFjaywgd2lsbCByZWNlaXZlIGEgYFByb2dyZXNzRXZlbnRgXG4gICAgICogQHBhcmFtIG9uRXJyb3IgRXJyb3IgY2FsbGJhY2tcbiAgICAgKiBAcmV0dXJuc1xuICAgICAqL1xuICAgIGxvYWQodXJsLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IpIHtcbiAgICAgICAgY29uc3QgcXVhZFJlbmRlcmVyID0gdGhpcy5wcmVwYXJlUXVhZFJlbmRlcmVyKCk7XG4gICAgICAgIGNvbnN0IGxvYWRlciA9IG5ldyBGaWxlTG9hZGVyKHRoaXMuX2ludGVybmFsTG9hZGluZ01hbmFnZXIpO1xuICAgICAgICBsb2FkZXIuc2V0UmVzcG9uc2VUeXBlKCdhcnJheWJ1ZmZlcicpO1xuICAgICAgICBsb2FkZXIuc2V0UmVxdWVzdEhlYWRlcih0aGlzLnJlcXVlc3RIZWFkZXIpO1xuICAgICAgICBsb2FkZXIuc2V0UGF0aCh0aGlzLnBhdGgpO1xuICAgICAgICBsb2FkZXIuc2V0V2l0aENyZWRlbnRpYWxzKHRoaXMud2l0aENyZWRlbnRpYWxzKTtcbiAgICAgICAgdGhpcy5tYW5hZ2VyLml0ZW1TdGFydCh1cmwpO1xuICAgICAgICBsb2FkZXIubG9hZCh1cmwsIGFzeW5jIChqcGVnKSA9PiB7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWZcbiAgICAgICAgICAgICB0aGlzIGNvbmRpdGlvbiBleGlzdHMgb25seSBiZWNhdXNlIG9mIHRocmVlLmpzIHR5cGVzICsgc3RyaWN0IG1vZGVcbiAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAodHlwZW9mIGpwZWcgPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBidWZmZXIsIHJlY2VpdmVkIFtzdHJpbmddLCB3YXMgZXhwZWN0aW5nIFtBcnJheUJ1ZmZlcl0nKTtcbiAgICAgICAgICAgIGNvbnN0IGpwZWdCdWZmZXIgPSBuZXcgVWludDhBcnJheShqcGVnKTtcbiAgICAgICAgICAgIGxldCBzZHJKUEVHO1xuICAgICAgICAgICAgbGV0IGdhaW5NYXBKUEVHO1xuICAgICAgICAgICAgbGV0IG1ldGFkYXRhO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBleHRyYWN0aW9uUmVzdWx0ID0gYXdhaXQgZXh0cmFjdEdhaW5tYXBGcm9tSlBFRyhqcGVnQnVmZmVyKTtcbiAgICAgICAgICAgICAgICAvLyBnYWluIG1hcCBpcyBzdWNjZXNzZnVsbHkgcmVjb25zdHJ1Y3RlZFxuICAgICAgICAgICAgICAgIHNkckpQRUcgPSBleHRyYWN0aW9uUmVzdWx0LnNkcjtcbiAgICAgICAgICAgICAgICBnYWluTWFwSlBFRyA9IGV4dHJhY3Rpb25SZXN1bHQuZ2Fpbk1hcDtcbiAgICAgICAgICAgICAgICBtZXRhZGF0YSA9IGV4dHJhY3Rpb25SZXN1bHQubWV0YWRhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIC8vIHJlbmRlciB0aGUgU0RSIHZlcnNpb24gaWYgdGhpcyBpcyBub3QgYSBnYWlubWFwXG4gICAgICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBYTVBNZXRhZGF0YU5vdEZvdW5kRXJyb3IgfHwgZSBpbnN0YW5jZW9mIEdhaW5NYXBOb3RGb3VuZEVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgRmFpbHVyZSB0byByZWNvbnN0cnVjdCBhbiBIRFIgaW1hZ2UgZnJvbSAke3VybH06IEdhaW4gbWFwIG1ldGFkYXRhIG5vdCBmb3VuZCBpbiB0aGUgZmlsZSwgSERSSlBHTG9hZGVyIHdpbGwgcmVuZGVyIHRoZSBTRFIganBlZ2ApO1xuICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdhaW5NYXBNaW46IFswLCAwLCAwXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdhaW5NYXBNYXg6IFsxLCAxLCAxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdhbW1hOiBbMSwgMSwgMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICBoZHJDYXBhY2l0eU1pbjogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhkckNhcGFjaXR5TWF4OiAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0SGRyOiBbMCwgMCwgMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXRTZHI6IFswLCAwLCAwXVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBzZHJKUEVHID0ganBlZ0J1ZmZlcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gc29sdmVzICMxNlxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnJlbmRlcihxdWFkUmVuZGVyZXIsIG1ldGFkYXRhLCBzZHJKUEVHLmJ1ZmZlciwgZ2Fpbk1hcEpQRUc/LmJ1ZmZlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1hbmFnZXIuaXRlbUVycm9yKHVybCk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvbkVycm9yID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgICAgICAgICBvbkVycm9yKGVycm9yKTtcbiAgICAgICAgICAgICAgICBxdWFkUmVuZGVyZXIuZGlzcG9zZU9uRGVtYW5kUmVuZGVyZXIoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9uTG9hZCA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgICAgICBvbkxvYWQocXVhZFJlbmRlcmVyKTtcbiAgICAgICAgICAgIHRoaXMubWFuYWdlci5pdGVtRW5kKHVybCk7XG4gICAgICAgICAgICBxdWFkUmVuZGVyZXIuZGlzcG9zZU9uRGVtYW5kUmVuZGVyZXIoKTtcbiAgICAgICAgfSwgb25Qcm9ncmVzcywgKGVycm9yKSA9PiB7XG4gICAgICAgICAgICB0aGlzLm1hbmFnZXIuaXRlbUVycm9yKHVybCk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9uRXJyb3IgPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICAgICAgb25FcnJvcihlcnJvcik7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcXVhZFJlbmRlcmVyO1xuICAgIH1cbn1cblxuZXhwb3J0IHsgR2Fpbk1hcERlY29kZXJNYXRlcmlhbCwgR2Fpbk1hcExvYWRlciwgR2Fpbk1hcE5vdEZvdW5kRXJyb3IsIEhEUkpQR0xvYWRlciwgSERSSlBHTG9hZGVyIGFzIEpQRUdSTG9hZGVyLCBMb2FkZXJCYXNlU2hhcmVkLCBRdWFkUmVuZGVyZXIsIFhNUE1ldGFkYXRhTm90Rm91bmRFcnJvciwgY3JlYXRlRGVjb2RlRnVuY3Rpb24sIGRlY29kZSwgZXh0cmFjdEdhaW5tYXBGcm9tSlBFRyB9O1xuIl0sIm5hbWVzIjpbIlEiLCJRdWFkUmVuZGVyZXIiLCJjIiwiY3JlYXRlRGVjb2RlRnVuY3Rpb24iLCJMIiwiTG9hZGVyQmFzZVNoYXJlZCIsImUiLCJleHRyYWN0R2Fpbm1hcEZyb21KUEVHIiwiWCIsIlhNUE1ldGFkYXRhTm90Rm91bmRFcnJvciIsIkciLCJHYWluTWFwTm90Rm91bmRFcnJvciIsIk0iLCJNUEZFeHRyYWN0b3IiLCJhIiwiZXh0cmFjdFhNUCIsIlNoYWRlck1hdGVyaWFsIiwiTm9CbGVuZGluZyIsIlZlY3RvcjMiLCJXZWJHTFJlbmRlcmVyIiwiRmlsZUxvYWRlciIsInZlcnRleFNoYWRlciIsImZyYWdtZW50U2hhZGVyIiwiR2Fpbk1hcERlY29kZXJNYXRlcmlhbCIsImNvbnN0cnVjdG9yIiwiZ2FtbWEiLCJvZmZzZXRIZHIiLCJvZmZzZXRTZHIiLCJnYWluTWFwTWluIiwiZ2Fpbk1hcE1heCIsIm1heERpc3BsYXlCb29zdCIsImhkckNhcGFjaXR5TWluIiwiaGRyQ2FwYWNpdHlNYXgiLCJzZHIiLCJnYWluTWFwIiwibmFtZSIsInVuaWZvcm1zIiwidmFsdWUiLCJmcm9tQXJyYXkiLCJ3ZWlnaHRGYWN0b3IiLCJNYXRoIiwibG9nMiIsImJsZW5kaW5nIiwiZGVwdGhUZXN0IiwiZGVwdGhXcml0ZSIsIl9tYXhEaXNwbGF5Qm9vc3QiLCJfaGRyQ2FwYWNpdHlNaW4iLCJfaGRyQ2FwYWNpdHlNYXgiLCJuZWVkc1VwZGF0ZSIsInVuaWZvcm1zTmVlZFVwZGF0ZSIsInRvQXJyYXkiLCJnIiwieCIsInkiLCJ6IiwiY2FsY3VsYXRlV2VpZ2h0IiwibWF4IiwibWluIiwidmFsIiwiZGVjb2RlSW1wbCIsInJlbmRlcmVyIiwiY3JlYXRlTWF0ZXJpYWwiLCJwYXJhbXMiLCJjcmVhdGVRdWFkUmVuZGVyZXIiLCJkZWNvZGUiLCJFcnJvciIsInF1YWRSZW5kZXJlciIsInJlbmRlciIsImRpc3Bvc2VPbkRlbWFuZFJlbmRlcmVyIiwiTG9hZGVyQmFzZVdlYkdMIiwibWFuYWdlciIsIm1ldGFkYXRhIiwic2RyQnVmZmVyIiwiZ2Fpbk1hcEJ1ZmZlciIsInNkckltYWdlIiwiZ2Fpbk1hcEltYWdlIiwibmVlZHNGbGlwIiwicHJvY2Vzc0ltYWdlcyIsImNyZWF0ZVRleHR1cmVzIiwidXBkYXRlUXVhZFJlbmRlcmVyIiwiR2Fpbk1hcExvYWRlciIsImxvYWQiLCJzZHJVcmwiLCJnYWluTWFwVXJsIiwibWV0YWRhdGFVcmwiLCJvbkxvYWQiLCJvblByb2dyZXNzIiwib25FcnJvciIsInByZXBhcmVRdWFkUmVuZGVyZXIiLCJsb2FkQ2hlY2siLCJlcnJvciIsIml0ZW1FcnJvciIsIml0ZW1FbmQiLCJzZHJMZW5ndGhDb21wdXRhYmxlIiwic2RyVG90YWwiLCJzZHJMb2FkZWQiLCJnYWluTWFwTGVuZ3RoQ29tcHV0YWJsZSIsImdhaW5NYXBUb3RhbCIsImdhaW5NYXBMb2FkZWQiLCJtZXRhZGF0YUxlbmd0aENvbXB1dGFibGUiLCJtZXRhZGF0YVRvdGFsIiwibWV0YWRhdGFMb2FkZWQiLCJwcm9ncmVzc0hhbmRsZXIiLCJ0b3RhbCIsImxvYWRlZCIsImxlbmd0aENvbXB1dGFibGUiLCJQcm9ncmVzc0V2ZW50IiwiaXRlbVN0YXJ0Iiwic2RyTG9hZGVyIiwiX2ludGVybmFsTG9hZGluZ01hbmFnZXIiLCJzZXRSZXNwb25zZVR5cGUiLCJzZXRSZXF1ZXN0SGVhZGVyIiwicmVxdWVzdEhlYWRlciIsInNldFBhdGgiLCJwYXRoIiwic2V0V2l0aENyZWRlbnRpYWxzIiwid2l0aENyZWRlbnRpYWxzIiwiYnVmZmVyIiwiZ2Fpbk1hcExvYWRlciIsIm1ldGFkYXRhTG9hZGVyIiwianNvbiIsIkpTT04iLCJwYXJzZSIsIkhEUkpQR0xvYWRlciIsInVybCIsImxvYWRlciIsImpwZWciLCJqcGVnQnVmZmVyIiwiVWludDhBcnJheSIsInNkckpQRUciLCJnYWluTWFwSlBFRyIsImV4dHJhY3Rpb25SZXN1bHQiLCJjb25zb2xlIiwid2FybiIsIkpQRUdSTG9hZGVyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@monogrid/gainmap-js/dist/decode.js\n");

/***/ })

};
;