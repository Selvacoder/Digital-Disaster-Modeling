"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/three-stdlib";
exports.ids = ["vendor-chunks/three-stdlib"];
exports.modules = {

/***/ "(ssr)/./node_modules/three-stdlib/_polyfill/constants.js":
/*!**********************************************************!*\
  !*** ./node_modules/three-stdlib/_polyfill/constants.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n\nconst version = /* @__PURE__ */ (()=>parseInt(three__WEBPACK_IMPORTED_MODULE_0__.REVISION.replace(/\\D+/g, \"\")))();\n //# sourceMappingURL=constants.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL19wb2x5ZmlsbC9jb25zdGFudHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBaUM7QUFDakMsTUFBTUMsVUFBMEIsYUFBSCxHQUFJLEtBQU1DLFNBQVNGLDJDQUFRQSxDQUFDRyxPQUFPLENBQUMsUUFBUSxJQUFHO0FBRzFFLENBQ0YscUNBQXFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYmx1ZXByaW50LXRvLTNkLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL3RocmVlLXN0ZGxpYi9fcG9seWZpbGwvY29uc3RhbnRzLmpzP2YxN2UiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUkVWSVNJT04gfSBmcm9tIFwidGhyZWVcIjtcbmNvbnN0IHZlcnNpb24gPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IHBhcnNlSW50KFJFVklTSU9OLnJlcGxhY2UoL1xcRCsvZywgXCJcIikpKSgpO1xuZXhwb3J0IHtcbiAgdmVyc2lvblxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbnN0YW50cy5qcy5tYXBcbiJdLCJuYW1lcyI6WyJSRVZJU0lPTiIsInZlcnNpb24iLCJwYXJzZUludCIsInJlcGxhY2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/three-stdlib/_polyfill/constants.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/three-stdlib/controls/EventDispatcher.js":
/*!***************************************************************!*\
  !*** ./node_modules/three-stdlib/controls/EventDispatcher.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EventDispatcher: () => (/* binding */ EventDispatcher)\n/* harmony export */ });\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {\n        enumerable: true,\n        configurable: true,\n        writable: true,\n        value\n    }) : obj[key] = value;\nvar __publicField = (obj, key, value)=>{\n    __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n    return value;\n};\nclass EventDispatcher {\n    constructor(){\n        // not defined in @types/three\n        __publicField(this, \"_listeners\");\n    }\n    /**\n   * Adds a listener to an event type.\n   * @param type The type of event to listen to.\n   * @param listener The function that gets called when the event is fired.\n   */ addEventListener(type, listener) {\n        if (this._listeners === void 0) this._listeners = {};\n        const listeners = this._listeners;\n        if (listeners[type] === void 0) {\n            listeners[type] = [];\n        }\n        if (listeners[type].indexOf(listener) === -1) {\n            listeners[type].push(listener);\n        }\n    }\n    /**\n      * Checks if listener is added to an event type.\n      * @param type The type of event to listen to.\n      * @param listener The function that gets called when the event is fired.\n      */ hasEventListener(type, listener) {\n        if (this._listeners === void 0) return false;\n        const listeners = this._listeners;\n        return listeners[type] !== void 0 && listeners[type].indexOf(listener) !== -1;\n    }\n    /**\n      * Removes a listener from an event type.\n      * @param type The type of the listener that gets removed.\n      * @param listener The listener function that gets removed.\n      */ removeEventListener(type, listener) {\n        if (this._listeners === void 0) return;\n        const listeners = this._listeners;\n        const listenerArray = listeners[type];\n        if (listenerArray !== void 0) {\n            const index = listenerArray.indexOf(listener);\n            if (index !== -1) {\n                listenerArray.splice(index, 1);\n            }\n        }\n    }\n    /**\n      * Fire an event type.\n      * @param event The event that gets fired.\n      */ dispatchEvent(event) {\n        if (this._listeners === void 0) return;\n        const listeners = this._listeners;\n        const listenerArray = listeners[event.type];\n        if (listenerArray !== void 0) {\n            event.target = this;\n            const array = listenerArray.slice(0);\n            for(let i = 0, l = array.length; i < l; i++){\n                array[i].call(this, event);\n            }\n            event.target = null;\n        }\n    }\n}\n //# sourceMappingURL=EventDispatcher.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL2NvbnRyb2xzL0V2ZW50RGlzcGF0Y2hlci5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsSUFBSUEsWUFBWUMsT0FBT0MsY0FBYztBQUNyQyxJQUFJQyxrQkFBa0IsQ0FBQ0MsS0FBS0MsS0FBS0MsUUFBVUQsT0FBT0QsTUFBTUosVUFBVUksS0FBS0MsS0FBSztRQUFFRSxZQUFZO1FBQU1DLGNBQWM7UUFBTUMsVUFBVTtRQUFNSDtJQUFNLEtBQUtGLEdBQUcsQ0FBQ0MsSUFBSSxHQUFHQztBQUMxSixJQUFJSSxnQkFBZ0IsQ0FBQ04sS0FBS0MsS0FBS0M7SUFDN0JILGdCQUFnQkMsS0FBSyxPQUFPQyxRQUFRLFdBQVdBLE1BQU0sS0FBS0EsS0FBS0M7SUFDL0QsT0FBT0E7QUFDVDtBQUNBLE1BQU1LO0lBQ0pDLGFBQWM7UUFDWiw4QkFBOEI7UUFDOUJGLGNBQWMsSUFBSSxFQUFFO0lBQ3RCO0lBQ0E7Ozs7R0FJQyxHQUNERyxpQkFBaUJDLElBQUksRUFBRUMsUUFBUSxFQUFFO1FBQy9CLElBQUksSUFBSSxDQUFDQyxVQUFVLEtBQUssS0FBSyxHQUMzQixJQUFJLENBQUNBLFVBQVUsR0FBRyxDQUFDO1FBQ3JCLE1BQU1DLFlBQVksSUFBSSxDQUFDRCxVQUFVO1FBQ2pDLElBQUlDLFNBQVMsQ0FBQ0gsS0FBSyxLQUFLLEtBQUssR0FBRztZQUM5QkcsU0FBUyxDQUFDSCxLQUFLLEdBQUcsRUFBRTtRQUN0QjtRQUNBLElBQUlHLFNBQVMsQ0FBQ0gsS0FBSyxDQUFDSSxPQUFPLENBQUNILGNBQWMsQ0FBQyxHQUFHO1lBQzVDRSxTQUFTLENBQUNILEtBQUssQ0FBQ0ssSUFBSSxDQUFDSjtRQUN2QjtJQUNGO0lBQ0E7Ozs7TUFJSSxHQUNKSyxpQkFBaUJOLElBQUksRUFBRUMsUUFBUSxFQUFFO1FBQy9CLElBQUksSUFBSSxDQUFDQyxVQUFVLEtBQUssS0FBSyxHQUMzQixPQUFPO1FBQ1QsTUFBTUMsWUFBWSxJQUFJLENBQUNELFVBQVU7UUFDakMsT0FBT0MsU0FBUyxDQUFDSCxLQUFLLEtBQUssS0FBSyxLQUFLRyxTQUFTLENBQUNILEtBQUssQ0FBQ0ksT0FBTyxDQUFDSCxjQUFjLENBQUM7SUFDOUU7SUFDQTs7OztNQUlJLEdBQ0pNLG9CQUFvQlAsSUFBSSxFQUFFQyxRQUFRLEVBQUU7UUFDbEMsSUFBSSxJQUFJLENBQUNDLFVBQVUsS0FBSyxLQUFLLEdBQzNCO1FBQ0YsTUFBTUMsWUFBWSxJQUFJLENBQUNELFVBQVU7UUFDakMsTUFBTU0sZ0JBQWdCTCxTQUFTLENBQUNILEtBQUs7UUFDckMsSUFBSVEsa0JBQWtCLEtBQUssR0FBRztZQUM1QixNQUFNQyxRQUFRRCxjQUFjSixPQUFPLENBQUNIO1lBQ3BDLElBQUlRLFVBQVUsQ0FBQyxHQUFHO2dCQUNoQkQsY0FBY0UsTUFBTSxDQUFDRCxPQUFPO1lBQzlCO1FBQ0Y7SUFDRjtJQUNBOzs7TUFHSSxHQUNKRSxjQUFjQyxLQUFLLEVBQUU7UUFDbkIsSUFBSSxJQUFJLENBQUNWLFVBQVUsS0FBSyxLQUFLLEdBQzNCO1FBQ0YsTUFBTUMsWUFBWSxJQUFJLENBQUNELFVBQVU7UUFDakMsTUFBTU0sZ0JBQWdCTCxTQUFTLENBQUNTLE1BQU1aLElBQUksQ0FBQztRQUMzQyxJQUFJUSxrQkFBa0IsS0FBSyxHQUFHO1lBQzVCSSxNQUFNQyxNQUFNLEdBQUcsSUFBSTtZQUNuQixNQUFNQyxRQUFRTixjQUFjTyxLQUFLLENBQUM7WUFDbEMsSUFBSyxJQUFJQyxJQUFJLEdBQUdDLElBQUlILE1BQU1JLE1BQU0sRUFBRUYsSUFBSUMsR0FBR0QsSUFBSztnQkFDNUNGLEtBQUssQ0FBQ0UsRUFBRSxDQUFDRyxJQUFJLENBQUMsSUFBSSxFQUFFUDtZQUN0QjtZQUNBQSxNQUFNQyxNQUFNLEdBQUc7UUFDakI7SUFDRjtBQUNGO0FBR0UsQ0FDRiwyQ0FBMkMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ibHVlcHJpbnQtdG8tM2QtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL2NvbnRyb2xzL0V2ZW50RGlzcGF0Y2hlci5qcz85NDQyIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19kZWZOb3JtYWxQcm9wID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcChvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19wdWJsaWNGaWVsZCA9IChvYmosIGtleSwgdmFsdWUpID0+IHtcbiAgX19kZWZOb3JtYWxQcm9wKG9iaiwgdHlwZW9mIGtleSAhPT0gXCJzeW1ib2xcIiA/IGtleSArIFwiXCIgOiBrZXksIHZhbHVlKTtcbiAgcmV0dXJuIHZhbHVlO1xufTtcbmNsYXNzIEV2ZW50RGlzcGF0Y2hlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIC8vIG5vdCBkZWZpbmVkIGluIEB0eXBlcy90aHJlZVxuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJfbGlzdGVuZXJzXCIpO1xuICB9XG4gIC8qKlxuICAgKiBBZGRzIGEgbGlzdGVuZXIgdG8gYW4gZXZlbnQgdHlwZS5cbiAgICogQHBhcmFtIHR5cGUgVGhlIHR5cGUgb2YgZXZlbnQgdG8gbGlzdGVuIHRvLlxuICAgKiBAcGFyYW0gbGlzdGVuZXIgVGhlIGZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWQgd2hlbiB0aGUgZXZlbnQgaXMgZmlyZWQuXG4gICAqL1xuICBhZGRFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgaWYgKHRoaXMuX2xpc3RlbmVycyA9PT0gdm9pZCAwKVxuICAgICAgdGhpcy5fbGlzdGVuZXJzID0ge307XG4gICAgY29uc3QgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzO1xuICAgIGlmIChsaXN0ZW5lcnNbdHlwZV0gPT09IHZvaWQgMCkge1xuICAgICAgbGlzdGVuZXJzW3R5cGVdID0gW107XG4gICAgfVxuICAgIGlmIChsaXN0ZW5lcnNbdHlwZV0uaW5kZXhPZihsaXN0ZW5lcikgPT09IC0xKSB7XG4gICAgICBsaXN0ZW5lcnNbdHlwZV0ucHVzaChsaXN0ZW5lcik7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgICAgKiBDaGVja3MgaWYgbGlzdGVuZXIgaXMgYWRkZWQgdG8gYW4gZXZlbnQgdHlwZS5cbiAgICAgICogQHBhcmFtIHR5cGUgVGhlIHR5cGUgb2YgZXZlbnQgdG8gbGlzdGVuIHRvLlxuICAgICAgKiBAcGFyYW0gbGlzdGVuZXIgVGhlIGZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWQgd2hlbiB0aGUgZXZlbnQgaXMgZmlyZWQuXG4gICAgICAqL1xuICBoYXNFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgaWYgKHRoaXMuX2xpc3RlbmVycyA9PT0gdm9pZCAwKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGNvbnN0IGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVycztcbiAgICByZXR1cm4gbGlzdGVuZXJzW3R5cGVdICE9PSB2b2lkIDAgJiYgbGlzdGVuZXJzW3R5cGVdLmluZGV4T2YobGlzdGVuZXIpICE9PSAtMTtcbiAgfVxuICAvKipcbiAgICAgICogUmVtb3ZlcyBhIGxpc3RlbmVyIGZyb20gYW4gZXZlbnQgdHlwZS5cbiAgICAgICogQHBhcmFtIHR5cGUgVGhlIHR5cGUgb2YgdGhlIGxpc3RlbmVyIHRoYXQgZ2V0cyByZW1vdmVkLlxuICAgICAgKiBAcGFyYW0gbGlzdGVuZXIgVGhlIGxpc3RlbmVyIGZ1bmN0aW9uIHRoYXQgZ2V0cyByZW1vdmVkLlxuICAgICAgKi9cbiAgcmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgIGlmICh0aGlzLl9saXN0ZW5lcnMgPT09IHZvaWQgMClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnM7XG4gICAgY29uc3QgbGlzdGVuZXJBcnJheSA9IGxpc3RlbmVyc1t0eXBlXTtcbiAgICBpZiAobGlzdGVuZXJBcnJheSAhPT0gdm9pZCAwKSB7XG4gICAgICBjb25zdCBpbmRleCA9IGxpc3RlbmVyQXJyYXkuaW5kZXhPZihsaXN0ZW5lcik7XG4gICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgIGxpc3RlbmVyQXJyYXkuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXG4gICAgICAqIEZpcmUgYW4gZXZlbnQgdHlwZS5cbiAgICAgICogQHBhcmFtIGV2ZW50IFRoZSBldmVudCB0aGF0IGdldHMgZmlyZWQuXG4gICAgICAqL1xuICBkaXNwYXRjaEV2ZW50KGV2ZW50KSB7XG4gICAgaWYgKHRoaXMuX2xpc3RlbmVycyA9PT0gdm9pZCAwKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVycztcbiAgICBjb25zdCBsaXN0ZW5lckFycmF5ID0gbGlzdGVuZXJzW2V2ZW50LnR5cGVdO1xuICAgIGlmIChsaXN0ZW5lckFycmF5ICE9PSB2b2lkIDApIHtcbiAgICAgIGV2ZW50LnRhcmdldCA9IHRoaXM7XG4gICAgICBjb25zdCBhcnJheSA9IGxpc3RlbmVyQXJyYXkuc2xpY2UoMCk7XG4gICAgICBmb3IgKGxldCBpID0gMCwgbCA9IGFycmF5Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBhcnJheVtpXS5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICAgIH1cbiAgICAgIGV2ZW50LnRhcmdldCA9IG51bGw7XG4gICAgfVxuICB9XG59XG5leHBvcnQge1xuICBFdmVudERpc3BhdGNoZXJcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1FdmVudERpc3BhdGNoZXIuanMubWFwXG4iXSwibmFtZXMiOlsiX19kZWZQcm9wIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJfX2RlZk5vcm1hbFByb3AiLCJvYmoiLCJrZXkiLCJ2YWx1ZSIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsIl9fcHVibGljRmllbGQiLCJFdmVudERpc3BhdGNoZXIiLCJjb25zdHJ1Y3RvciIsImFkZEV2ZW50TGlzdGVuZXIiLCJ0eXBlIiwibGlzdGVuZXIiLCJfbGlzdGVuZXJzIiwibGlzdGVuZXJzIiwiaW5kZXhPZiIsInB1c2giLCJoYXNFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImxpc3RlbmVyQXJyYXkiLCJpbmRleCIsInNwbGljZSIsImRpc3BhdGNoRXZlbnQiLCJldmVudCIsInRhcmdldCIsImFycmF5Iiwic2xpY2UiLCJpIiwibCIsImxlbmd0aCIsImNhbGwiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/three-stdlib/controls/EventDispatcher.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/three-stdlib/controls/OrbitControls.js":
/*!*************************************************************!*\
  !*** ./node_modules/three-stdlib/controls/OrbitControls.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MapControls: () => (/* binding */ MapControls),\n/* harmony export */   OrbitControls: () => (/* binding */ OrbitControls)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var _EventDispatcher_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./EventDispatcher.js */ \"(ssr)/./node_modules/three-stdlib/controls/EventDispatcher.js\");\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {\n        enumerable: true,\n        configurable: true,\n        writable: true,\n        value\n    }) : obj[key] = value;\nvar __publicField = (obj, key, value)=>{\n    __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n    return value;\n};\n\n\nconst _ray = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Ray();\nconst _plane = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Plane();\nconst TILT_LIMIT = Math.cos(70 * (Math.PI / 180));\nconst moduloWrapAround = (offset, capacity)=>(offset % capacity + capacity) % capacity;\nclass OrbitControls extends _EventDispatcher_js__WEBPACK_IMPORTED_MODULE_1__.EventDispatcher {\n    constructor(object, domElement){\n        super();\n        __publicField(this, \"object\");\n        __publicField(this, \"domElement\");\n        // Set to false to disable this control\n        __publicField(this, \"enabled\", true);\n        // \"target\" sets the location of focus, where the object orbits around\n        __publicField(this, \"target\", new three__WEBPACK_IMPORTED_MODULE_0__.Vector3());\n        // How far you can dolly in and out ( PerspectiveCamera only )\n        __publicField(this, \"minDistance\", 0);\n        __publicField(this, \"maxDistance\", Infinity);\n        // How far you can zoom in and out ( OrthographicCamera only )\n        __publicField(this, \"minZoom\", 0);\n        __publicField(this, \"maxZoom\", Infinity);\n        // How far you can orbit vertically, upper and lower limits.\n        // Range is 0 to Math.PI radians.\n        __publicField(this, \"minPolarAngle\", 0);\n        // radians\n        __publicField(this, \"maxPolarAngle\", Math.PI);\n        // radians\n        // How far you can orbit horizontally, upper and lower limits.\n        // If set, the interval [ min, max ] must be a sub-interval of [ - 2 PI, 2 PI ], with ( max - min < 2 PI )\n        __publicField(this, \"minAzimuthAngle\", -Infinity);\n        // radians\n        __publicField(this, \"maxAzimuthAngle\", Infinity);\n        // radians\n        // Set to true to enable damping (inertia)\n        // If damping is enabled, you must call controls.update() in your animation loop\n        __publicField(this, \"enableDamping\", false);\n        __publicField(this, \"dampingFactor\", 0.05);\n        // This option actually enables dollying in and out; left as \"zoom\" for backwards compatibility.\n        // Set to false to disable zooming\n        __publicField(this, \"enableZoom\", true);\n        __publicField(this, \"zoomSpeed\", 1);\n        // Set to false to disable rotating\n        __publicField(this, \"enableRotate\", true);\n        __publicField(this, \"rotateSpeed\", 1);\n        // Set to false to disable panning\n        __publicField(this, \"enablePan\", true);\n        __publicField(this, \"panSpeed\", 1);\n        __publicField(this, \"screenSpacePanning\", true);\n        // if false, pan orthogonal to world-space direction camera.up\n        __publicField(this, \"keyPanSpeed\", 7);\n        // pixels moved per arrow key push\n        __publicField(this, \"zoomToCursor\", false);\n        // Set to true to automatically rotate around the target\n        // If auto-rotate is enabled, you must call controls.update() in your animation loop\n        __publicField(this, \"autoRotate\", false);\n        __publicField(this, \"autoRotateSpeed\", 2);\n        // 30 seconds per orbit when fps is 60\n        __publicField(this, \"reverseOrbit\", false);\n        // true if you want to reverse the orbit to mouse drag from left to right = orbits left\n        __publicField(this, \"reverseHorizontalOrbit\", false);\n        // true if you want to reverse the horizontal orbit direction\n        __publicField(this, \"reverseVerticalOrbit\", false);\n        // true if you want to reverse the vertical orbit direction\n        // The four arrow keys\n        __publicField(this, \"keys\", {\n            LEFT: \"ArrowLeft\",\n            UP: \"ArrowUp\",\n            RIGHT: \"ArrowRight\",\n            BOTTOM: \"ArrowDown\"\n        });\n        // Mouse buttons\n        __publicField(this, \"mouseButtons\", {\n            LEFT: three__WEBPACK_IMPORTED_MODULE_0__.MOUSE.ROTATE,\n            MIDDLE: three__WEBPACK_IMPORTED_MODULE_0__.MOUSE.DOLLY,\n            RIGHT: three__WEBPACK_IMPORTED_MODULE_0__.MOUSE.PAN\n        });\n        // Touch fingers\n        __publicField(this, \"touches\", {\n            ONE: three__WEBPACK_IMPORTED_MODULE_0__.TOUCH.ROTATE,\n            TWO: three__WEBPACK_IMPORTED_MODULE_0__.TOUCH.DOLLY_PAN\n        });\n        __publicField(this, \"target0\");\n        __publicField(this, \"position0\");\n        __publicField(this, \"zoom0\");\n        // the target DOM element for key events\n        __publicField(this, \"_domElementKeyEvents\", null);\n        __publicField(this, \"getPolarAngle\");\n        __publicField(this, \"getAzimuthalAngle\");\n        __publicField(this, \"setPolarAngle\");\n        __publicField(this, \"setAzimuthalAngle\");\n        __publicField(this, \"getDistance\");\n        // Not used in most scenarios, however they can be useful for specific use cases\n        __publicField(this, \"getZoomScale\");\n        __publicField(this, \"listenToKeyEvents\");\n        __publicField(this, \"stopListenToKeyEvents\");\n        __publicField(this, \"saveState\");\n        __publicField(this, \"reset\");\n        __publicField(this, \"update\");\n        __publicField(this, \"connect\");\n        __publicField(this, \"dispose\");\n        // Dolly in programmatically\n        __publicField(this, \"dollyIn\");\n        // Dolly out programmatically\n        __publicField(this, \"dollyOut\");\n        // Get the current scale\n        __publicField(this, \"getScale\");\n        // Set the current scale (these are not used in most scenarios, however they can be useful for specific use cases)\n        __publicField(this, \"setScale\");\n        this.object = object;\n        this.domElement = domElement;\n        this.target0 = this.target.clone();\n        this.position0 = this.object.position.clone();\n        this.zoom0 = this.object.zoom;\n        this.getPolarAngle = ()=>spherical.phi;\n        this.getAzimuthalAngle = ()=>spherical.theta;\n        this.setPolarAngle = (value)=>{\n            let phi = moduloWrapAround(value, 2 * Math.PI);\n            let currentPhi = spherical.phi;\n            if (currentPhi < 0) currentPhi += 2 * Math.PI;\n            if (phi < 0) phi += 2 * Math.PI;\n            let phiDist = Math.abs(phi - currentPhi);\n            if (2 * Math.PI - phiDist < phiDist) {\n                if (phi < currentPhi) {\n                    phi += 2 * Math.PI;\n                } else {\n                    currentPhi += 2 * Math.PI;\n                }\n            }\n            sphericalDelta.phi = phi - currentPhi;\n            scope.update();\n        };\n        this.setAzimuthalAngle = (value)=>{\n            let theta = moduloWrapAround(value, 2 * Math.PI);\n            let currentTheta = spherical.theta;\n            if (currentTheta < 0) currentTheta += 2 * Math.PI;\n            if (theta < 0) theta += 2 * Math.PI;\n            let thetaDist = Math.abs(theta - currentTheta);\n            if (2 * Math.PI - thetaDist < thetaDist) {\n                if (theta < currentTheta) {\n                    theta += 2 * Math.PI;\n                } else {\n                    currentTheta += 2 * Math.PI;\n                }\n            }\n            sphericalDelta.theta = theta - currentTheta;\n            scope.update();\n        };\n        this.getDistance = ()=>scope.object.position.distanceTo(scope.target);\n        this.listenToKeyEvents = (domElement2)=>{\n            domElement2.addEventListener(\"keydown\", onKeyDown);\n            this._domElementKeyEvents = domElement2;\n        };\n        this.stopListenToKeyEvents = ()=>{\n            this._domElementKeyEvents.removeEventListener(\"keydown\", onKeyDown);\n            this._domElementKeyEvents = null;\n        };\n        this.saveState = ()=>{\n            scope.target0.copy(scope.target);\n            scope.position0.copy(scope.object.position);\n            scope.zoom0 = scope.object.zoom;\n        };\n        this.reset = ()=>{\n            scope.target.copy(scope.target0);\n            scope.object.position.copy(scope.position0);\n            scope.object.zoom = scope.zoom0;\n            scope.object.updateProjectionMatrix();\n            scope.dispatchEvent(changeEvent);\n            scope.update();\n            state = STATE.NONE;\n        };\n        this.update = (()=>{\n            const offset = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n            const up = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 1, 0);\n            const quat = new three__WEBPACK_IMPORTED_MODULE_0__.Quaternion().setFromUnitVectors(object.up, up);\n            const quatInverse = quat.clone().invert();\n            const lastPosition = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n            const lastQuaternion = new three__WEBPACK_IMPORTED_MODULE_0__.Quaternion();\n            const twoPI = 2 * Math.PI;\n            return function update() {\n                const position = scope.object.position;\n                quat.setFromUnitVectors(object.up, up);\n                quatInverse.copy(quat).invert();\n                offset.copy(position).sub(scope.target);\n                offset.applyQuaternion(quat);\n                spherical.setFromVector3(offset);\n                if (scope.autoRotate && state === STATE.NONE) {\n                    rotateLeft(getAutoRotationAngle());\n                }\n                if (scope.enableDamping) {\n                    spherical.theta += sphericalDelta.theta * scope.dampingFactor;\n                    spherical.phi += sphericalDelta.phi * scope.dampingFactor;\n                } else {\n                    spherical.theta += sphericalDelta.theta;\n                    spherical.phi += sphericalDelta.phi;\n                }\n                let min = scope.minAzimuthAngle;\n                let max = scope.maxAzimuthAngle;\n                if (isFinite(min) && isFinite(max)) {\n                    if (min < -Math.PI) min += twoPI;\n                    else if (min > Math.PI) min -= twoPI;\n                    if (max < -Math.PI) max += twoPI;\n                    else if (max > Math.PI) max -= twoPI;\n                    if (min <= max) {\n                        spherical.theta = Math.max(min, Math.min(max, spherical.theta));\n                    } else {\n                        spherical.theta = spherical.theta > (min + max) / 2 ? Math.max(min, spherical.theta) : Math.min(max, spherical.theta);\n                    }\n                }\n                spherical.phi = Math.max(scope.minPolarAngle, Math.min(scope.maxPolarAngle, spherical.phi));\n                spherical.makeSafe();\n                if (scope.enableDamping === true) {\n                    scope.target.addScaledVector(panOffset, scope.dampingFactor);\n                } else {\n                    scope.target.add(panOffset);\n                }\n                if (scope.zoomToCursor && performCursorZoom || scope.object.isOrthographicCamera) {\n                    spherical.radius = clampDistance(spherical.radius);\n                } else {\n                    spherical.radius = clampDistance(spherical.radius * scale);\n                }\n                offset.setFromSpherical(spherical);\n                offset.applyQuaternion(quatInverse);\n                position.copy(scope.target).add(offset);\n                if (!scope.object.matrixAutoUpdate) scope.object.updateMatrix();\n                scope.object.lookAt(scope.target);\n                if (scope.enableDamping === true) {\n                    sphericalDelta.theta *= 1 - scope.dampingFactor;\n                    sphericalDelta.phi *= 1 - scope.dampingFactor;\n                    panOffset.multiplyScalar(1 - scope.dampingFactor);\n                } else {\n                    sphericalDelta.set(0, 0, 0);\n                    panOffset.set(0, 0, 0);\n                }\n                let zoomChanged = false;\n                if (scope.zoomToCursor && performCursorZoom) {\n                    let newRadius = null;\n                    if (scope.object instanceof three__WEBPACK_IMPORTED_MODULE_0__.PerspectiveCamera && scope.object.isPerspectiveCamera) {\n                        const prevRadius = offset.length();\n                        newRadius = clampDistance(prevRadius * scale);\n                        const radiusDelta = prevRadius - newRadius;\n                        scope.object.position.addScaledVector(dollyDirection, radiusDelta);\n                        scope.object.updateMatrixWorld();\n                    } else if (scope.object.isOrthographicCamera) {\n                        const mouseBefore = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(mouse.x, mouse.y, 0);\n                        mouseBefore.unproject(scope.object);\n                        scope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom / scale));\n                        scope.object.updateProjectionMatrix();\n                        zoomChanged = true;\n                        const mouseAfter = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(mouse.x, mouse.y, 0);\n                        mouseAfter.unproject(scope.object);\n                        scope.object.position.sub(mouseAfter).add(mouseBefore);\n                        scope.object.updateMatrixWorld();\n                        newRadius = offset.length();\n                    } else {\n                        console.warn(\"WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled.\");\n                        scope.zoomToCursor = false;\n                    }\n                    if (newRadius !== null) {\n                        if (scope.screenSpacePanning) {\n                            scope.target.set(0, 0, -1).transformDirection(scope.object.matrix).multiplyScalar(newRadius).add(scope.object.position);\n                        } else {\n                            _ray.origin.copy(scope.object.position);\n                            _ray.direction.set(0, 0, -1).transformDirection(scope.object.matrix);\n                            if (Math.abs(scope.object.up.dot(_ray.direction)) < TILT_LIMIT) {\n                                object.lookAt(scope.target);\n                            } else {\n                                _plane.setFromNormalAndCoplanarPoint(scope.object.up, scope.target);\n                                _ray.intersectPlane(_plane, scope.target);\n                            }\n                        }\n                    }\n                } else if (scope.object instanceof three__WEBPACK_IMPORTED_MODULE_0__.OrthographicCamera && scope.object.isOrthographicCamera) {\n                    zoomChanged = scale !== 1;\n                    if (zoomChanged) {\n                        scope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom / scale));\n                        scope.object.updateProjectionMatrix();\n                    }\n                }\n                scale = 1;\n                performCursorZoom = false;\n                if (zoomChanged || lastPosition.distanceToSquared(scope.object.position) > EPS || 8 * (1 - lastQuaternion.dot(scope.object.quaternion)) > EPS) {\n                    scope.dispatchEvent(changeEvent);\n                    lastPosition.copy(scope.object.position);\n                    lastQuaternion.copy(scope.object.quaternion);\n                    zoomChanged = false;\n                    return true;\n                }\n                return false;\n            };\n        })();\n        this.connect = (domElement2)=>{\n            scope.domElement = domElement2;\n            scope.domElement.style.touchAction = \"none\";\n            scope.domElement.addEventListener(\"contextmenu\", onContextMenu);\n            scope.domElement.addEventListener(\"pointerdown\", onPointerDown);\n            scope.domElement.addEventListener(\"pointercancel\", onPointerUp);\n            scope.domElement.addEventListener(\"wheel\", onMouseWheel);\n        };\n        this.dispose = ()=>{\n            var _a, _b, _c, _d, _e, _f;\n            if (scope.domElement) {\n                scope.domElement.style.touchAction = \"auto\";\n            }\n            (_a = scope.domElement) == null ? void 0 : _a.removeEventListener(\"contextmenu\", onContextMenu);\n            (_b = scope.domElement) == null ? void 0 : _b.removeEventListener(\"pointerdown\", onPointerDown);\n            (_c = scope.domElement) == null ? void 0 : _c.removeEventListener(\"pointercancel\", onPointerUp);\n            (_d = scope.domElement) == null ? void 0 : _d.removeEventListener(\"wheel\", onMouseWheel);\n            (_e = scope.domElement) == null ? void 0 : _e.ownerDocument.removeEventListener(\"pointermove\", onPointerMove);\n            (_f = scope.domElement) == null ? void 0 : _f.ownerDocument.removeEventListener(\"pointerup\", onPointerUp);\n            if (scope._domElementKeyEvents !== null) {\n                scope._domElementKeyEvents.removeEventListener(\"keydown\", onKeyDown);\n            }\n        };\n        const scope = this;\n        const changeEvent = {\n            type: \"change\"\n        };\n        const startEvent = {\n            type: \"start\"\n        };\n        const endEvent = {\n            type: \"end\"\n        };\n        const STATE = {\n            NONE: -1,\n            ROTATE: 0,\n            DOLLY: 1,\n            PAN: 2,\n            TOUCH_ROTATE: 3,\n            TOUCH_PAN: 4,\n            TOUCH_DOLLY_PAN: 5,\n            TOUCH_DOLLY_ROTATE: 6\n        };\n        let state = STATE.NONE;\n        const EPS = 1e-6;\n        const spherical = new three__WEBPACK_IMPORTED_MODULE_0__.Spherical();\n        const sphericalDelta = new three__WEBPACK_IMPORTED_MODULE_0__.Spherical();\n        let scale = 1;\n        const panOffset = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        const rotateStart = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n        const rotateEnd = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n        const rotateDelta = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n        const panStart = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n        const panEnd = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n        const panDelta = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n        const dollyStart = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n        const dollyEnd = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n        const dollyDelta = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n        const dollyDirection = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        const mouse = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n        let performCursorZoom = false;\n        const pointers = [];\n        const pointerPositions = {};\n        function getAutoRotationAngle() {\n            return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;\n        }\n        function getZoomScale() {\n            return Math.pow(0.95, scope.zoomSpeed);\n        }\n        function rotateLeft(angle) {\n            if (scope.reverseOrbit || scope.reverseHorizontalOrbit) {\n                sphericalDelta.theta += angle;\n            } else {\n                sphericalDelta.theta -= angle;\n            }\n        }\n        function rotateUp(angle) {\n            if (scope.reverseOrbit || scope.reverseVerticalOrbit) {\n                sphericalDelta.phi += angle;\n            } else {\n                sphericalDelta.phi -= angle;\n            }\n        }\n        const panLeft = (()=>{\n            const v = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n            return function panLeft2(distance, objectMatrix) {\n                v.setFromMatrixColumn(objectMatrix, 0);\n                v.multiplyScalar(-distance);\n                panOffset.add(v);\n            };\n        })();\n        const panUp = (()=>{\n            const v = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n            return function panUp2(distance, objectMatrix) {\n                if (scope.screenSpacePanning === true) {\n                    v.setFromMatrixColumn(objectMatrix, 1);\n                } else {\n                    v.setFromMatrixColumn(objectMatrix, 0);\n                    v.crossVectors(scope.object.up, v);\n                }\n                v.multiplyScalar(distance);\n                panOffset.add(v);\n            };\n        })();\n        const pan = (()=>{\n            const offset = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n            return function pan2(deltaX, deltaY) {\n                const element = scope.domElement;\n                if (element && scope.object instanceof three__WEBPACK_IMPORTED_MODULE_0__.PerspectiveCamera && scope.object.isPerspectiveCamera) {\n                    const position = scope.object.position;\n                    offset.copy(position).sub(scope.target);\n                    let targetDistance = offset.length();\n                    targetDistance *= Math.tan(scope.object.fov / 2 * Math.PI / 180);\n                    panLeft(2 * deltaX * targetDistance / element.clientHeight, scope.object.matrix);\n                    panUp(2 * deltaY * targetDistance / element.clientHeight, scope.object.matrix);\n                } else if (element && scope.object instanceof three__WEBPACK_IMPORTED_MODULE_0__.OrthographicCamera && scope.object.isOrthographicCamera) {\n                    panLeft(deltaX * (scope.object.right - scope.object.left) / scope.object.zoom / element.clientWidth, scope.object.matrix);\n                    panUp(deltaY * (scope.object.top - scope.object.bottom) / scope.object.zoom / element.clientHeight, scope.object.matrix);\n                } else {\n                    console.warn(\"WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.\");\n                    scope.enablePan = false;\n                }\n            };\n        })();\n        function setScale(newScale) {\n            if (scope.object instanceof three__WEBPACK_IMPORTED_MODULE_0__.PerspectiveCamera && scope.object.isPerspectiveCamera || scope.object instanceof three__WEBPACK_IMPORTED_MODULE_0__.OrthographicCamera && scope.object.isOrthographicCamera) {\n                scale = newScale;\n            } else {\n                console.warn(\"WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.\");\n                scope.enableZoom = false;\n            }\n        }\n        function dollyOut(dollyScale) {\n            setScale(scale / dollyScale);\n        }\n        function dollyIn(dollyScale) {\n            setScale(scale * dollyScale);\n        }\n        function updateMouseParameters(event) {\n            if (!scope.zoomToCursor || !scope.domElement) {\n                return;\n            }\n            performCursorZoom = true;\n            const rect = scope.domElement.getBoundingClientRect();\n            const x = event.clientX - rect.left;\n            const y = event.clientY - rect.top;\n            const w = rect.width;\n            const h = rect.height;\n            mouse.x = x / w * 2 - 1;\n            mouse.y = -(y / h) * 2 + 1;\n            dollyDirection.set(mouse.x, mouse.y, 1).unproject(scope.object).sub(scope.object.position).normalize();\n        }\n        function clampDistance(dist) {\n            return Math.max(scope.minDistance, Math.min(scope.maxDistance, dist));\n        }\n        function handleMouseDownRotate(event) {\n            rotateStart.set(event.clientX, event.clientY);\n        }\n        function handleMouseDownDolly(event) {\n            updateMouseParameters(event);\n            dollyStart.set(event.clientX, event.clientY);\n        }\n        function handleMouseDownPan(event) {\n            panStart.set(event.clientX, event.clientY);\n        }\n        function handleMouseMoveRotate(event) {\n            rotateEnd.set(event.clientX, event.clientY);\n            rotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(scope.rotateSpeed);\n            const element = scope.domElement;\n            if (element) {\n                rotateLeft(2 * Math.PI * rotateDelta.x / element.clientHeight);\n                rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight);\n            }\n            rotateStart.copy(rotateEnd);\n            scope.update();\n        }\n        function handleMouseMoveDolly(event) {\n            dollyEnd.set(event.clientX, event.clientY);\n            dollyDelta.subVectors(dollyEnd, dollyStart);\n            if (dollyDelta.y > 0) {\n                dollyOut(getZoomScale());\n            } else if (dollyDelta.y < 0) {\n                dollyIn(getZoomScale());\n            }\n            dollyStart.copy(dollyEnd);\n            scope.update();\n        }\n        function handleMouseMovePan(event) {\n            panEnd.set(event.clientX, event.clientY);\n            panDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed);\n            pan(panDelta.x, panDelta.y);\n            panStart.copy(panEnd);\n            scope.update();\n        }\n        function handleMouseWheel(event) {\n            updateMouseParameters(event);\n            if (event.deltaY < 0) {\n                dollyIn(getZoomScale());\n            } else if (event.deltaY > 0) {\n                dollyOut(getZoomScale());\n            }\n            scope.update();\n        }\n        function handleKeyDown(event) {\n            let needsUpdate = false;\n            switch(event.code){\n                case scope.keys.UP:\n                    pan(0, scope.keyPanSpeed);\n                    needsUpdate = true;\n                    break;\n                case scope.keys.BOTTOM:\n                    pan(0, -scope.keyPanSpeed);\n                    needsUpdate = true;\n                    break;\n                case scope.keys.LEFT:\n                    pan(scope.keyPanSpeed, 0);\n                    needsUpdate = true;\n                    break;\n                case scope.keys.RIGHT:\n                    pan(-scope.keyPanSpeed, 0);\n                    needsUpdate = true;\n                    break;\n            }\n            if (needsUpdate) {\n                event.preventDefault();\n                scope.update();\n            }\n        }\n        function handleTouchStartRotate() {\n            if (pointers.length == 1) {\n                rotateStart.set(pointers[0].pageX, pointers[0].pageY);\n            } else {\n                const x = 0.5 * (pointers[0].pageX + pointers[1].pageX);\n                const y = 0.5 * (pointers[0].pageY + pointers[1].pageY);\n                rotateStart.set(x, y);\n            }\n        }\n        function handleTouchStartPan() {\n            if (pointers.length == 1) {\n                panStart.set(pointers[0].pageX, pointers[0].pageY);\n            } else {\n                const x = 0.5 * (pointers[0].pageX + pointers[1].pageX);\n                const y = 0.5 * (pointers[0].pageY + pointers[1].pageY);\n                panStart.set(x, y);\n            }\n        }\n        function handleTouchStartDolly() {\n            const dx = pointers[0].pageX - pointers[1].pageX;\n            const dy = pointers[0].pageY - pointers[1].pageY;\n            const distance = Math.sqrt(dx * dx + dy * dy);\n            dollyStart.set(0, distance);\n        }\n        function handleTouchStartDollyPan() {\n            if (scope.enableZoom) handleTouchStartDolly();\n            if (scope.enablePan) handleTouchStartPan();\n        }\n        function handleTouchStartDollyRotate() {\n            if (scope.enableZoom) handleTouchStartDolly();\n            if (scope.enableRotate) handleTouchStartRotate();\n        }\n        function handleTouchMoveRotate(event) {\n            if (pointers.length == 1) {\n                rotateEnd.set(event.pageX, event.pageY);\n            } else {\n                const position = getSecondPointerPosition(event);\n                const x = 0.5 * (event.pageX + position.x);\n                const y = 0.5 * (event.pageY + position.y);\n                rotateEnd.set(x, y);\n            }\n            rotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(scope.rotateSpeed);\n            const element = scope.domElement;\n            if (element) {\n                rotateLeft(2 * Math.PI * rotateDelta.x / element.clientHeight);\n                rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight);\n            }\n            rotateStart.copy(rotateEnd);\n        }\n        function handleTouchMovePan(event) {\n            if (pointers.length == 1) {\n                panEnd.set(event.pageX, event.pageY);\n            } else {\n                const position = getSecondPointerPosition(event);\n                const x = 0.5 * (event.pageX + position.x);\n                const y = 0.5 * (event.pageY + position.y);\n                panEnd.set(x, y);\n            }\n            panDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed);\n            pan(panDelta.x, panDelta.y);\n            panStart.copy(panEnd);\n        }\n        function handleTouchMoveDolly(event) {\n            const position = getSecondPointerPosition(event);\n            const dx = event.pageX - position.x;\n            const dy = event.pageY - position.y;\n            const distance = Math.sqrt(dx * dx + dy * dy);\n            dollyEnd.set(0, distance);\n            dollyDelta.set(0, Math.pow(dollyEnd.y / dollyStart.y, scope.zoomSpeed));\n            dollyOut(dollyDelta.y);\n            dollyStart.copy(dollyEnd);\n        }\n        function handleTouchMoveDollyPan(event) {\n            if (scope.enableZoom) handleTouchMoveDolly(event);\n            if (scope.enablePan) handleTouchMovePan(event);\n        }\n        function handleTouchMoveDollyRotate(event) {\n            if (scope.enableZoom) handleTouchMoveDolly(event);\n            if (scope.enableRotate) handleTouchMoveRotate(event);\n        }\n        function onPointerDown(event) {\n            var _a, _b;\n            if (scope.enabled === false) return;\n            if (pointers.length === 0) {\n                (_a = scope.domElement) == null ? void 0 : _a.ownerDocument.addEventListener(\"pointermove\", onPointerMove);\n                (_b = scope.domElement) == null ? void 0 : _b.ownerDocument.addEventListener(\"pointerup\", onPointerUp);\n            }\n            addPointer(event);\n            if (event.pointerType === \"touch\") {\n                onTouchStart(event);\n            } else {\n                onMouseDown(event);\n            }\n        }\n        function onPointerMove(event) {\n            if (scope.enabled === false) return;\n            if (event.pointerType === \"touch\") {\n                onTouchMove(event);\n            } else {\n                onMouseMove(event);\n            }\n        }\n        function onPointerUp(event) {\n            var _a, _b, _c;\n            removePointer(event);\n            if (pointers.length === 0) {\n                (_a = scope.domElement) == null ? void 0 : _a.releasePointerCapture(event.pointerId);\n                (_b = scope.domElement) == null ? void 0 : _b.ownerDocument.removeEventListener(\"pointermove\", onPointerMove);\n                (_c = scope.domElement) == null ? void 0 : _c.ownerDocument.removeEventListener(\"pointerup\", onPointerUp);\n            }\n            scope.dispatchEvent(endEvent);\n            state = STATE.NONE;\n        }\n        function onMouseDown(event) {\n            let mouseAction;\n            switch(event.button){\n                case 0:\n                    mouseAction = scope.mouseButtons.LEFT;\n                    break;\n                case 1:\n                    mouseAction = scope.mouseButtons.MIDDLE;\n                    break;\n                case 2:\n                    mouseAction = scope.mouseButtons.RIGHT;\n                    break;\n                default:\n                    mouseAction = -1;\n            }\n            switch(mouseAction){\n                case three__WEBPACK_IMPORTED_MODULE_0__.MOUSE.DOLLY:\n                    if (scope.enableZoom === false) return;\n                    handleMouseDownDolly(event);\n                    state = STATE.DOLLY;\n                    break;\n                case three__WEBPACK_IMPORTED_MODULE_0__.MOUSE.ROTATE:\n                    if (event.ctrlKey || event.metaKey || event.shiftKey) {\n                        if (scope.enablePan === false) return;\n                        handleMouseDownPan(event);\n                        state = STATE.PAN;\n                    } else {\n                        if (scope.enableRotate === false) return;\n                        handleMouseDownRotate(event);\n                        state = STATE.ROTATE;\n                    }\n                    break;\n                case three__WEBPACK_IMPORTED_MODULE_0__.MOUSE.PAN:\n                    if (event.ctrlKey || event.metaKey || event.shiftKey) {\n                        if (scope.enableRotate === false) return;\n                        handleMouseDownRotate(event);\n                        state = STATE.ROTATE;\n                    } else {\n                        if (scope.enablePan === false) return;\n                        handleMouseDownPan(event);\n                        state = STATE.PAN;\n                    }\n                    break;\n                default:\n                    state = STATE.NONE;\n            }\n            if (state !== STATE.NONE) {\n                scope.dispatchEvent(startEvent);\n            }\n        }\n        function onMouseMove(event) {\n            if (scope.enabled === false) return;\n            switch(state){\n                case STATE.ROTATE:\n                    if (scope.enableRotate === false) return;\n                    handleMouseMoveRotate(event);\n                    break;\n                case STATE.DOLLY:\n                    if (scope.enableZoom === false) return;\n                    handleMouseMoveDolly(event);\n                    break;\n                case STATE.PAN:\n                    if (scope.enablePan === false) return;\n                    handleMouseMovePan(event);\n                    break;\n            }\n        }\n        function onMouseWheel(event) {\n            if (scope.enabled === false || scope.enableZoom === false || state !== STATE.NONE && state !== STATE.ROTATE) {\n                return;\n            }\n            event.preventDefault();\n            scope.dispatchEvent(startEvent);\n            handleMouseWheel(event);\n            scope.dispatchEvent(endEvent);\n        }\n        function onKeyDown(event) {\n            if (scope.enabled === false || scope.enablePan === false) return;\n            handleKeyDown(event);\n        }\n        function onTouchStart(event) {\n            trackPointer(event);\n            switch(pointers.length){\n                case 1:\n                    switch(scope.touches.ONE){\n                        case three__WEBPACK_IMPORTED_MODULE_0__.TOUCH.ROTATE:\n                            if (scope.enableRotate === false) return;\n                            handleTouchStartRotate();\n                            state = STATE.TOUCH_ROTATE;\n                            break;\n                        case three__WEBPACK_IMPORTED_MODULE_0__.TOUCH.PAN:\n                            if (scope.enablePan === false) return;\n                            handleTouchStartPan();\n                            state = STATE.TOUCH_PAN;\n                            break;\n                        default:\n                            state = STATE.NONE;\n                    }\n                    break;\n                case 2:\n                    switch(scope.touches.TWO){\n                        case three__WEBPACK_IMPORTED_MODULE_0__.TOUCH.DOLLY_PAN:\n                            if (scope.enableZoom === false && scope.enablePan === false) return;\n                            handleTouchStartDollyPan();\n                            state = STATE.TOUCH_DOLLY_PAN;\n                            break;\n                        case three__WEBPACK_IMPORTED_MODULE_0__.TOUCH.DOLLY_ROTATE:\n                            if (scope.enableZoom === false && scope.enableRotate === false) return;\n                            handleTouchStartDollyRotate();\n                            state = STATE.TOUCH_DOLLY_ROTATE;\n                            break;\n                        default:\n                            state = STATE.NONE;\n                    }\n                    break;\n                default:\n                    state = STATE.NONE;\n            }\n            if (state !== STATE.NONE) {\n                scope.dispatchEvent(startEvent);\n            }\n        }\n        function onTouchMove(event) {\n            trackPointer(event);\n            switch(state){\n                case STATE.TOUCH_ROTATE:\n                    if (scope.enableRotate === false) return;\n                    handleTouchMoveRotate(event);\n                    scope.update();\n                    break;\n                case STATE.TOUCH_PAN:\n                    if (scope.enablePan === false) return;\n                    handleTouchMovePan(event);\n                    scope.update();\n                    break;\n                case STATE.TOUCH_DOLLY_PAN:\n                    if (scope.enableZoom === false && scope.enablePan === false) return;\n                    handleTouchMoveDollyPan(event);\n                    scope.update();\n                    break;\n                case STATE.TOUCH_DOLLY_ROTATE:\n                    if (scope.enableZoom === false && scope.enableRotate === false) return;\n                    handleTouchMoveDollyRotate(event);\n                    scope.update();\n                    break;\n                default:\n                    state = STATE.NONE;\n            }\n        }\n        function onContextMenu(event) {\n            if (scope.enabled === false) return;\n            event.preventDefault();\n        }\n        function addPointer(event) {\n            pointers.push(event);\n        }\n        function removePointer(event) {\n            delete pointerPositions[event.pointerId];\n            for(let i = 0; i < pointers.length; i++){\n                if (pointers[i].pointerId == event.pointerId) {\n                    pointers.splice(i, 1);\n                    return;\n                }\n            }\n        }\n        function trackPointer(event) {\n            let position = pointerPositions[event.pointerId];\n            if (position === void 0) {\n                position = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n                pointerPositions[event.pointerId] = position;\n            }\n            position.set(event.pageX, event.pageY);\n        }\n        function getSecondPointerPosition(event) {\n            const pointer = event.pointerId === pointers[0].pointerId ? pointers[1] : pointers[0];\n            return pointerPositions[pointer.pointerId];\n        }\n        this.dollyIn = (dollyScale = getZoomScale())=>{\n            dollyIn(dollyScale);\n            scope.update();\n        };\n        this.dollyOut = (dollyScale = getZoomScale())=>{\n            dollyOut(dollyScale);\n            scope.update();\n        };\n        this.getScale = ()=>{\n            return scale;\n        };\n        this.setScale = (newScale)=>{\n            setScale(newScale);\n            scope.update();\n        };\n        this.getZoomScale = ()=>{\n            return getZoomScale();\n        };\n        if (domElement !== void 0) this.connect(domElement);\n        this.update();\n    }\n}\nclass MapControls extends OrbitControls {\n    constructor(object, domElement){\n        super(object, domElement);\n        this.screenSpacePanning = false;\n        this.mouseButtons.LEFT = three__WEBPACK_IMPORTED_MODULE_0__.MOUSE.PAN;\n        this.mouseButtons.RIGHT = three__WEBPACK_IMPORTED_MODULE_0__.MOUSE.ROTATE;\n        this.touches.ONE = three__WEBPACK_IMPORTED_MODULE_0__.TOUCH.PAN;\n        this.touches.TWO = three__WEBPACK_IMPORTED_MODULE_0__.TOUCH.DOLLY_ROTATE;\n    }\n}\n //# sourceMappingURL=OrbitControls.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL2NvbnRyb2xzL09yYml0Q29udHJvbHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBLElBQUlBLFlBQVlDLE9BQU9DLGNBQWM7QUFDckMsSUFBSUMsa0JBQWtCLENBQUNDLEtBQUtDLEtBQUtDLFFBQVVELE9BQU9ELE1BQU1KLFVBQVVJLEtBQUtDLEtBQUs7UUFBRUUsWUFBWTtRQUFNQyxjQUFjO1FBQU1DLFVBQVU7UUFBTUg7SUFBTSxLQUFLRixHQUFHLENBQUNDLElBQUksR0FBR0M7QUFDMUosSUFBSUksZ0JBQWdCLENBQUNOLEtBQUtDLEtBQUtDO0lBQzdCSCxnQkFBZ0JDLEtBQUssT0FBT0MsUUFBUSxXQUFXQSxNQUFNLEtBQUtBLEtBQUtDO0lBQy9ELE9BQU9BO0FBQ1Q7QUFDaUk7QUFDMUU7QUFDdkQsTUFBTWdCLE9BQU8sYUFBYSxHQUFHLElBQUlILHNDQUFHQTtBQUNwQyxNQUFNSSxTQUFTLGFBQWEsR0FBRyxJQUFJSCx3Q0FBS0E7QUFDeEMsTUFBTUksYUFBYUMsS0FBS0MsR0FBRyxDQUFDLEtBQU1ELENBQUFBLEtBQUtFLEVBQUUsR0FBRyxHQUFFO0FBQzlDLE1BQU1DLG1CQUFtQixDQUFDQyxRQUFRQyxXQUFhLENBQUNELFNBQVNDLFdBQVdBLFFBQU8sSUFBS0E7QUFDaEYsTUFBTUMsc0JBQXNCVixnRUFBZUE7SUFDekNXLFlBQVlDLE1BQU0sRUFBRUMsVUFBVSxDQUFFO1FBQzlCLEtBQUs7UUFDTHhCLGNBQWMsSUFBSSxFQUFFO1FBQ3BCQSxjQUFjLElBQUksRUFBRTtRQUNwQix1Q0FBdUM7UUFDdkNBLGNBQWMsSUFBSSxFQUFFLFdBQVc7UUFDL0Isc0VBQXNFO1FBQ3RFQSxjQUFjLElBQUksRUFBRSxVQUFVLElBQUlDLDBDQUFPQTtRQUN6Qyw4REFBOEQ7UUFDOURELGNBQWMsSUFBSSxFQUFFLGVBQWU7UUFDbkNBLGNBQWMsSUFBSSxFQUFFLGVBQWV5QjtRQUNuQyw4REFBOEQ7UUFD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O1FBQ0EsSUFBSSxDQUFDeU8sUUFBUSxHQUFHO1lBQ2QsT0FBT25MO1FBQ1Q7UUFDQSxJQUFJLENBQUN1RyxRQUFRLEdBQUcsQ0FBQ0M7WUFDZkQsU0FBU0M7WUFDVC9KLE1BQU1DLE1BQU07UUFDZDtRQUNBLElBQUksQ0FBQzZILFlBQVksR0FBRztZQUNsQixPQUFPQTtRQUNUO1FBQ0EsSUFBSTVKLGVBQWUsS0FBSyxHQUN0QixJQUFJLENBQUN5SCxPQUFPLENBQUN6SDtRQUNmLElBQUksQ0FBQytCLE1BQU07SUFDYjtBQUNGO0FBQ0EsTUFBTTBPLG9CQUFvQjVRO0lBQ3hCQyxZQUFZQyxNQUFNLEVBQUVDLFVBQVUsQ0FBRTtRQUM5QixLQUFLLENBQUNELFFBQVFDO1FBQ2QsSUFBSSxDQUFDOEcsa0JBQWtCLEdBQUc7UUFDMUIsSUFBSSxDQUFDK0ksWUFBWSxDQUFDM1AsSUFBSSxHQUFHeEIsd0NBQUtBLENBQUMrQixHQUFHO1FBQ2xDLElBQUksQ0FBQ29QLFlBQVksQ0FBQ3pQLEtBQUssR0FBRzFCLHdDQUFLQSxDQUFDNEIsTUFBTTtRQUN0QyxJQUFJLENBQUM0UCxPQUFPLENBQUN4UCxHQUFHLEdBQUcvQix3Q0FBS0EsQ0FBQzhCLEdBQUc7UUFDNUIsSUFBSSxDQUFDeVAsT0FBTyxDQUFDdlAsR0FBRyxHQUFHaEMsd0NBQUtBLENBQUN3UixZQUFZO0lBQ3ZDO0FBQ0Y7QUFJRSxDQUNGLHlDQUF5QyIsInNvdXJjZXMiOlsid2VicGFjazovL2JsdWVwcmludC10by0zZC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy90aHJlZS1zdGRsaWIvY29udHJvbHMvT3JiaXRDb250cm9scy5qcz8wZjM5Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19kZWZOb3JtYWxQcm9wID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcChvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19wdWJsaWNGaWVsZCA9IChvYmosIGtleSwgdmFsdWUpID0+IHtcbiAgX19kZWZOb3JtYWxQcm9wKG9iaiwgdHlwZW9mIGtleSAhPT0gXCJzeW1ib2xcIiA/IGtleSArIFwiXCIgOiBrZXksIHZhbHVlKTtcbiAgcmV0dXJuIHZhbHVlO1xufTtcbmltcG9ydCB7IFZlY3RvcjMsIE1PVVNFLCBUT1VDSCwgUXVhdGVybmlvbiwgUGVyc3BlY3RpdmVDYW1lcmEsIE9ydGhvZ3JhcGhpY0NhbWVyYSwgU3BoZXJpY2FsLCBWZWN0b3IyLCBSYXksIFBsYW5lIH0gZnJvbSBcInRocmVlXCI7XG5pbXBvcnQgeyBFdmVudERpc3BhdGNoZXIgfSBmcm9tIFwiLi9FdmVudERpc3BhdGNoZXIuanNcIjtcbmNvbnN0IF9yYXkgPSAvKiBAX19QVVJFX18gKi8gbmV3IFJheSgpO1xuY29uc3QgX3BsYW5lID0gLyogQF9fUFVSRV9fICovIG5ldyBQbGFuZSgpO1xuY29uc3QgVElMVF9MSU1JVCA9IE1hdGguY29zKDcwICogKE1hdGguUEkgLyAxODApKTtcbmNvbnN0IG1vZHVsb1dyYXBBcm91bmQgPSAob2Zmc2V0LCBjYXBhY2l0eSkgPT4gKG9mZnNldCAlIGNhcGFjaXR5ICsgY2FwYWNpdHkpICUgY2FwYWNpdHk7XG5jbGFzcyBPcmJpdENvbnRyb2xzIGV4dGVuZHMgRXZlbnREaXNwYXRjaGVyIHtcbiAgY29uc3RydWN0b3Iob2JqZWN0LCBkb21FbGVtZW50KSB7XG4gICAgc3VwZXIoKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwib2JqZWN0XCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJkb21FbGVtZW50XCIpO1xuICAgIC8vIFNldCB0byBmYWxzZSB0byBkaXNhYmxlIHRoaXMgY29udHJvbFxuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJlbmFibGVkXCIsIHRydWUpO1xuICAgIC8vIFwidGFyZ2V0XCIgc2V0cyB0aGUgbG9jYXRpb24gb2YgZm9jdXMsIHdoZXJlIHRoZSBvYmplY3Qgb3JiaXRzIGFyb3VuZFxuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJ0YXJnZXRcIiwgbmV3IFZlY3RvcjMoKSk7XG4gICAgLy8gSG93IGZhciB5b3UgY2FuIGRvbGx5IGluIGFuZCBvdXQgKCBQZXJzcGVjdGl2ZUNhbWVyYSBvbmx5IClcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwibWluRGlzdGFuY2VcIiwgMCk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIm1heERpc3RhbmNlXCIsIEluZmluaXR5KTtcbiAgICAvLyBIb3cgZmFyIHlvdSBjYW4gem9vbSBpbiBhbmQgb3V0ICggT3J0aG9ncmFwaGljQ2FtZXJhIG9ubHkgKVxuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJtaW5ab29tXCIsIDApO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJtYXhab29tXCIsIEluZmluaXR5KTtcbiAgICAvLyBIb3cgZmFyIHlvdSBjYW4gb3JiaXQgdmVydGljYWxseSwgdXBwZXIgYW5kIGxvd2VyIGxpbWl0cy5cbiAgICAvLyBSYW5nZSBpcyAwIHRvIE1hdGguUEkgcmFkaWFucy5cbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwibWluUG9sYXJBbmdsZVwiLCAwKTtcbiAgICAvLyByYWRpYW5zXG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIm1heFBvbGFyQW5nbGVcIiwgTWF0aC5QSSk7XG4gICAgLy8gcmFkaWFuc1xuICAgIC8vIEhvdyBmYXIgeW91IGNhbiBvcmJpdCBob3Jpem9udGFsbHksIHVwcGVyIGFuZCBsb3dlciBsaW1pdHMuXG4gICAgLy8gSWYgc2V0LCB0aGUgaW50ZXJ2YWwgWyBtaW4sIG1heCBdIG11c3QgYmUgYSBzdWItaW50ZXJ2YWwgb2YgWyAtIDIgUEksIDIgUEkgXSwgd2l0aCAoIG1heCAtIG1pbiA8IDIgUEkgKVxuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJtaW5BemltdXRoQW5nbGVcIiwgLUluZmluaXR5KTtcbiAgICAvLyByYWRpYW5zXG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIm1heEF6aW11dGhBbmdsZVwiLCBJbmZpbml0eSk7XG4gICAgLy8gcmFkaWFuc1xuICAgIC8vIFNldCB0byB0cnVlIHRvIGVuYWJsZSBkYW1waW5nIChpbmVydGlhKVxuICAgIC8vIElmIGRhbXBpbmcgaXMgZW5hYmxlZCwgeW91IG11c3QgY2FsbCBjb250cm9scy51cGRhdGUoKSBpbiB5b3VyIGFuaW1hdGlvbiBsb29wXG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImVuYWJsZURhbXBpbmdcIiwgZmFsc2UpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJkYW1waW5nRmFjdG9yXCIsIDAuMDUpO1xuICAgIC8vIFRoaXMgb3B0aW9uIGFjdHVhbGx5IGVuYWJsZXMgZG9sbHlpbmcgaW4gYW5kIG91dDsgbGVmdCBhcyBcInpvb21cIiBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG4gICAgLy8gU2V0IHRvIGZhbHNlIHRvIGRpc2FibGUgem9vbWluZ1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJlbmFibGVab29tXCIsIHRydWUpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJ6b29tU3BlZWRcIiwgMSk7XG4gICAgLy8gU2V0IHRvIGZhbHNlIHRvIGRpc2FibGUgcm90YXRpbmdcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiZW5hYmxlUm90YXRlXCIsIHRydWUpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJyb3RhdGVTcGVlZFwiLCAxKTtcbiAgICAvLyBTZXQgdG8gZmFsc2UgdG8gZGlzYWJsZSBwYW5uaW5nXG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImVuYWJsZVBhblwiLCB0cnVlKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwicGFuU3BlZWRcIiwgMSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInNjcmVlblNwYWNlUGFubmluZ1wiLCB0cnVlKTtcbiAgICAvLyBpZiBmYWxzZSwgcGFuIG9ydGhvZ29uYWwgdG8gd29ybGQtc3BhY2UgZGlyZWN0aW9uIGNhbWVyYS51cFxuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJrZXlQYW5TcGVlZFwiLCA3KTtcbiAgICAvLyBwaXhlbHMgbW92ZWQgcGVyIGFycm93IGtleSBwdXNoXG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInpvb21Ub0N1cnNvclwiLCBmYWxzZSk7XG4gICAgLy8gU2V0IHRvIHRydWUgdG8gYXV0b21hdGljYWxseSByb3RhdGUgYXJvdW5kIHRoZSB0YXJnZXRcbiAgICAvLyBJZiBhdXRvLXJvdGF0ZSBpcyBlbmFibGVkLCB5b3UgbXVzdCBjYWxsIGNvbnRyb2xzLnVwZGF0ZSgpIGluIHlvdXIgYW5pbWF0aW9uIGxvb3BcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiYXV0b1JvdGF0ZVwiLCBmYWxzZSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImF1dG9Sb3RhdGVTcGVlZFwiLCAyKTtcbiAgICAvLyAzMCBzZWNvbmRzIHBlciBvcmJpdCB3aGVuIGZwcyBpcyA2MFxuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJyZXZlcnNlT3JiaXRcIiwgZmFsc2UpO1xuICAgIC8vIHRydWUgaWYgeW91IHdhbnQgdG8gcmV2ZXJzZSB0aGUgb3JiaXQgdG8gbW91c2UgZHJhZyBmcm9tIGxlZnQgdG8gcmlnaHQgPSBvcmJpdHMgbGVmdFxuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJyZXZlcnNlSG9yaXpvbnRhbE9yYml0XCIsIGZhbHNlKTtcbiAgICAvLyB0cnVlIGlmIHlvdSB3YW50IHRvIHJldmVyc2UgdGhlIGhvcml6b250YWwgb3JiaXQgZGlyZWN0aW9uXG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInJldmVyc2VWZXJ0aWNhbE9yYml0XCIsIGZhbHNlKTtcbiAgICAvLyB0cnVlIGlmIHlvdSB3YW50IHRvIHJldmVyc2UgdGhlIHZlcnRpY2FsIG9yYml0IGRpcmVjdGlvblxuICAgIC8vIFRoZSBmb3VyIGFycm93IGtleXNcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwia2V5c1wiLCB7IExFRlQ6IFwiQXJyb3dMZWZ0XCIsIFVQOiBcIkFycm93VXBcIiwgUklHSFQ6IFwiQXJyb3dSaWdodFwiLCBCT1RUT006IFwiQXJyb3dEb3duXCIgfSk7XG4gICAgLy8gTW91c2UgYnV0dG9uc1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJtb3VzZUJ1dHRvbnNcIiwge1xuICAgICAgTEVGVDogTU9VU0UuUk9UQVRFLFxuICAgICAgTUlERExFOiBNT1VTRS5ET0xMWSxcbiAgICAgIFJJR0hUOiBNT1VTRS5QQU5cbiAgICB9KTtcbiAgICAvLyBUb3VjaCBmaW5nZXJzXG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInRvdWNoZXNcIiwgeyBPTkU6IFRPVUNILlJPVEFURSwgVFdPOiBUT1VDSC5ET0xMWV9QQU4gfSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInRhcmdldDBcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInBvc2l0aW9uMFwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiem9vbTBcIik7XG4gICAgLy8gdGhlIHRhcmdldCBET00gZWxlbWVudCBmb3Iga2V5IGV2ZW50c1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJfZG9tRWxlbWVudEtleUV2ZW50c1wiLCBudWxsKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiZ2V0UG9sYXJBbmdsZVwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiZ2V0QXppbXV0aGFsQW5nbGVcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInNldFBvbGFyQW5nbGVcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInNldEF6aW11dGhhbEFuZ2xlXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJnZXREaXN0YW5jZVwiKTtcbiAgICAvLyBOb3QgdXNlZCBpbiBtb3N0IHNjZW5hcmlvcywgaG93ZXZlciB0aGV5IGNhbiBiZSB1c2VmdWwgZm9yIHNwZWNpZmljIHVzZSBjYXNlc1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJnZXRab29tU2NhbGVcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImxpc3RlblRvS2V5RXZlbnRzXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJzdG9wTGlzdGVuVG9LZXlFdmVudHNcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInNhdmVTdGF0ZVwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwicmVzZXRcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInVwZGF0ZVwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiY29ubmVjdFwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiZGlzcG9zZVwiKTtcbiAgICAvLyBEb2xseSBpbiBwcm9ncmFtbWF0aWNhbGx5XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImRvbGx5SW5cIik7XG4gICAgLy8gRG9sbHkgb3V0IHByb2dyYW1tYXRpY2FsbHlcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiZG9sbHlPdXRcIik7XG4gICAgLy8gR2V0IHRoZSBjdXJyZW50IHNjYWxlXG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImdldFNjYWxlXCIpO1xuICAgIC8vIFNldCB0aGUgY3VycmVudCBzY2FsZSAodGhlc2UgYXJlIG5vdCB1c2VkIGluIG1vc3Qgc2NlbmFyaW9zLCBob3dldmVyIHRoZXkgY2FuIGJlIHVzZWZ1bCBmb3Igc3BlY2lmaWMgdXNlIGNhc2VzKVxuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJzZXRTY2FsZVwiKTtcbiAgICB0aGlzLm9iamVjdCA9IG9iamVjdDtcbiAgICB0aGlzLmRvbUVsZW1lbnQgPSBkb21FbGVtZW50O1xuICAgIHRoaXMudGFyZ2V0MCA9IHRoaXMudGFyZ2V0LmNsb25lKCk7XG4gICAgdGhpcy5wb3NpdGlvbjAgPSB0aGlzLm9iamVjdC5wb3NpdGlvbi5jbG9uZSgpO1xuICAgIHRoaXMuem9vbTAgPSB0aGlzLm9iamVjdC56b29tO1xuICAgIHRoaXMuZ2V0UG9sYXJBbmdsZSA9ICgpID0+IHNwaGVyaWNhbC5waGk7XG4gICAgdGhpcy5nZXRBemltdXRoYWxBbmdsZSA9ICgpID0+IHNwaGVyaWNhbC50aGV0YTtcbiAgICB0aGlzLnNldFBvbGFyQW5nbGUgPSAodmFsdWUpID0+IHtcbiAgICAgIGxldCBwaGkgPSBtb2R1bG9XcmFwQXJvdW5kKHZhbHVlLCAyICogTWF0aC5QSSk7XG4gICAgICBsZXQgY3VycmVudFBoaSA9IHNwaGVyaWNhbC5waGk7XG4gICAgICBpZiAoY3VycmVudFBoaSA8IDApXG4gICAgICAgIGN1cnJlbnRQaGkgKz0gMiAqIE1hdGguUEk7XG4gICAgICBpZiAocGhpIDwgMClcbiAgICAgICAgcGhpICs9IDIgKiBNYXRoLlBJO1xuICAgICAgbGV0IHBoaURpc3QgPSBNYXRoLmFicyhwaGkgLSBjdXJyZW50UGhpKTtcbiAgICAgIGlmICgyICogTWF0aC5QSSAtIHBoaURpc3QgPCBwaGlEaXN0KSB7XG4gICAgICAgIGlmIChwaGkgPCBjdXJyZW50UGhpKSB7XG4gICAgICAgICAgcGhpICs9IDIgKiBNYXRoLlBJO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN1cnJlbnRQaGkgKz0gMiAqIE1hdGguUEk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHNwaGVyaWNhbERlbHRhLnBoaSA9IHBoaSAtIGN1cnJlbnRQaGk7XG4gICAgICBzY29wZS51cGRhdGUoKTtcbiAgICB9O1xuICAgIHRoaXMuc2V0QXppbXV0aGFsQW5nbGUgPSAodmFsdWUpID0+IHtcbiAgICAgIGxldCB0aGV0YSA9IG1vZHVsb1dyYXBBcm91bmQodmFsdWUsIDIgKiBNYXRoLlBJKTtcbiAgICAgIGxldCBjdXJyZW50VGhldGEgPSBzcGhlcmljYWwudGhldGE7XG4gICAgICBpZiAoY3VycmVudFRoZXRhIDwgMClcbiAgICAgICAgY3VycmVudFRoZXRhICs9IDIgKiBNYXRoLlBJO1xuICAgICAgaWYgKHRoZXRhIDwgMClcbiAgICAgICAgdGhldGEgKz0gMiAqIE1hdGguUEk7XG4gICAgICBsZXQgdGhldGFEaXN0ID0gTWF0aC5hYnModGhldGEgLSBjdXJyZW50VGhldGEpO1xuICAgICAgaWYgKDIgKiBNYXRoLlBJIC0gdGhldGFEaXN0IDwgdGhldGFEaXN0KSB7XG4gICAgICAgIGlmICh0aGV0YSA8IGN1cnJlbnRUaGV0YSkge1xuICAgICAgICAgIHRoZXRhICs9IDIgKiBNYXRoLlBJO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN1cnJlbnRUaGV0YSArPSAyICogTWF0aC5QSTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc3BoZXJpY2FsRGVsdGEudGhldGEgPSB0aGV0YSAtIGN1cnJlbnRUaGV0YTtcbiAgICAgIHNjb3BlLnVwZGF0ZSgpO1xuICAgIH07XG4gICAgdGhpcy5nZXREaXN0YW5jZSA9ICgpID0+IHNjb3BlLm9iamVjdC5wb3NpdGlvbi5kaXN0YW5jZVRvKHNjb3BlLnRhcmdldCk7XG4gICAgdGhpcy5saXN0ZW5Ub0tleUV2ZW50cyA9IChkb21FbGVtZW50MikgPT4ge1xuICAgICAgZG9tRWxlbWVudDIuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgb25LZXlEb3duKTtcbiAgICAgIHRoaXMuX2RvbUVsZW1lbnRLZXlFdmVudHMgPSBkb21FbGVtZW50MjtcbiAgICB9O1xuICAgIHRoaXMuc3RvcExpc3RlblRvS2V5RXZlbnRzID0gKCkgPT4ge1xuICAgICAgdGhpcy5fZG9tRWxlbWVudEtleUV2ZW50cy5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBvbktleURvd24pO1xuICAgICAgdGhpcy5fZG9tRWxlbWVudEtleUV2ZW50cyA9IG51bGw7XG4gICAgfTtcbiAgICB0aGlzLnNhdmVTdGF0ZSA9ICgpID0+IHtcbiAgICAgIHNjb3BlLnRhcmdldDAuY29weShzY29wZS50YXJnZXQpO1xuICAgICAgc2NvcGUucG9zaXRpb24wLmNvcHkoc2NvcGUub2JqZWN0LnBvc2l0aW9uKTtcbiAgICAgIHNjb3BlLnpvb20wID0gc2NvcGUub2JqZWN0Lnpvb207XG4gICAgfTtcbiAgICB0aGlzLnJlc2V0ID0gKCkgPT4ge1xuICAgICAgc2NvcGUudGFyZ2V0LmNvcHkoc2NvcGUudGFyZ2V0MCk7XG4gICAgICBzY29wZS5vYmplY3QucG9zaXRpb24uY29weShzY29wZS5wb3NpdGlvbjApO1xuICAgICAgc2NvcGUub2JqZWN0Lnpvb20gPSBzY29wZS56b29tMDtcbiAgICAgIHNjb3BlLm9iamVjdC51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XG4gICAgICBzY29wZS5kaXNwYXRjaEV2ZW50KGNoYW5nZUV2ZW50KTtcbiAgICAgIHNjb3BlLnVwZGF0ZSgpO1xuICAgICAgc3RhdGUgPSBTVEFURS5OT05FO1xuICAgIH07XG4gICAgdGhpcy51cGRhdGUgPSAoKCkgPT4ge1xuICAgICAgY29uc3Qgb2Zmc2V0ID0gbmV3IFZlY3RvcjMoKTtcbiAgICAgIGNvbnN0IHVwID0gbmV3IFZlY3RvcjMoMCwgMSwgMCk7XG4gICAgICBjb25zdCBxdWF0ID0gbmV3IFF1YXRlcm5pb24oKS5zZXRGcm9tVW5pdFZlY3RvcnMob2JqZWN0LnVwLCB1cCk7XG4gICAgICBjb25zdCBxdWF0SW52ZXJzZSA9IHF1YXQuY2xvbmUoKS5pbnZlcnQoKTtcbiAgICAgIGNvbnN0IGxhc3RQb3NpdGlvbiA9IG5ldyBWZWN0b3IzKCk7XG4gICAgICBjb25zdCBsYXN0UXVhdGVybmlvbiA9IG5ldyBRdWF0ZXJuaW9uKCk7XG4gICAgICBjb25zdCB0d29QSSA9IDIgKiBNYXRoLlBJO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZSgpIHtcbiAgICAgICAgY29uc3QgcG9zaXRpb24gPSBzY29wZS5vYmplY3QucG9zaXRpb247XG4gICAgICAgIHF1YXQuc2V0RnJvbVVuaXRWZWN0b3JzKG9iamVjdC51cCwgdXApO1xuICAgICAgICBxdWF0SW52ZXJzZS5jb3B5KHF1YXQpLmludmVydCgpO1xuICAgICAgICBvZmZzZXQuY29weShwb3NpdGlvbikuc3ViKHNjb3BlLnRhcmdldCk7XG4gICAgICAgIG9mZnNldC5hcHBseVF1YXRlcm5pb24ocXVhdCk7XG4gICAgICAgIHNwaGVyaWNhbC5zZXRGcm9tVmVjdG9yMyhvZmZzZXQpO1xuICAgICAgICBpZiAoc2NvcGUuYXV0b1JvdGF0ZSAmJiBzdGF0ZSA9PT0gU1RBVEUuTk9ORSkge1xuICAgICAgICAgIHJvdGF0ZUxlZnQoZ2V0QXV0b1JvdGF0aW9uQW5nbGUoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNjb3BlLmVuYWJsZURhbXBpbmcpIHtcbiAgICAgICAgICBzcGhlcmljYWwudGhldGEgKz0gc3BoZXJpY2FsRGVsdGEudGhldGEgKiBzY29wZS5kYW1waW5nRmFjdG9yO1xuICAgICAgICAgIHNwaGVyaWNhbC5waGkgKz0gc3BoZXJpY2FsRGVsdGEucGhpICogc2NvcGUuZGFtcGluZ0ZhY3RvcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzcGhlcmljYWwudGhldGEgKz0gc3BoZXJpY2FsRGVsdGEudGhldGE7XG4gICAgICAgICAgc3BoZXJpY2FsLnBoaSArPSBzcGhlcmljYWxEZWx0YS5waGk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG1pbiA9IHNjb3BlLm1pbkF6aW11dGhBbmdsZTtcbiAgICAgICAgbGV0IG1heCA9IHNjb3BlLm1heEF6aW11dGhBbmdsZTtcbiAgICAgICAgaWYgKGlzRmluaXRlKG1pbikgJiYgaXNGaW5pdGUobWF4KSkge1xuICAgICAgICAgIGlmIChtaW4gPCAtTWF0aC5QSSlcbiAgICAgICAgICAgIG1pbiArPSB0d29QSTtcbiAgICAgICAgICBlbHNlIGlmIChtaW4gPiBNYXRoLlBJKVxuICAgICAgICAgICAgbWluIC09IHR3b1BJO1xuICAgICAgICAgIGlmIChtYXggPCAtTWF0aC5QSSlcbiAgICAgICAgICAgIG1heCArPSB0d29QSTtcbiAgICAgICAgICBlbHNlIGlmIChtYXggPiBNYXRoLlBJKVxuICAgICAgICAgICAgbWF4IC09IHR3b1BJO1xuICAgICAgICAgIGlmIChtaW4gPD0gbWF4KSB7XG4gICAgICAgICAgICBzcGhlcmljYWwudGhldGEgPSBNYXRoLm1heChtaW4sIE1hdGgubWluKG1heCwgc3BoZXJpY2FsLnRoZXRhKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNwaGVyaWNhbC50aGV0YSA9IHNwaGVyaWNhbC50aGV0YSA+IChtaW4gKyBtYXgpIC8gMiA/IE1hdGgubWF4KG1pbiwgc3BoZXJpY2FsLnRoZXRhKSA6IE1hdGgubWluKG1heCwgc3BoZXJpY2FsLnRoZXRhKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3BoZXJpY2FsLnBoaSA9IE1hdGgubWF4KHNjb3BlLm1pblBvbGFyQW5nbGUsIE1hdGgubWluKHNjb3BlLm1heFBvbGFyQW5nbGUsIHNwaGVyaWNhbC5waGkpKTtcbiAgICAgICAgc3BoZXJpY2FsLm1ha2VTYWZlKCk7XG4gICAgICAgIGlmIChzY29wZS5lbmFibGVEYW1waW5nID09PSB0cnVlKSB7XG4gICAgICAgICAgc2NvcGUudGFyZ2V0LmFkZFNjYWxlZFZlY3RvcihwYW5PZmZzZXQsIHNjb3BlLmRhbXBpbmdGYWN0b3IpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNjb3BlLnRhcmdldC5hZGQocGFuT2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2NvcGUuem9vbVRvQ3Vyc29yICYmIHBlcmZvcm1DdXJzb3Jab29tIHx8IHNjb3BlLm9iamVjdC5pc09ydGhvZ3JhcGhpY0NhbWVyYSkge1xuICAgICAgICAgIHNwaGVyaWNhbC5yYWRpdXMgPSBjbGFtcERpc3RhbmNlKHNwaGVyaWNhbC5yYWRpdXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNwaGVyaWNhbC5yYWRpdXMgPSBjbGFtcERpc3RhbmNlKHNwaGVyaWNhbC5yYWRpdXMgKiBzY2FsZSk7XG4gICAgICAgIH1cbiAgICAgICAgb2Zmc2V0LnNldEZyb21TcGhlcmljYWwoc3BoZXJpY2FsKTtcbiAgICAgICAgb2Zmc2V0LmFwcGx5UXVhdGVybmlvbihxdWF0SW52ZXJzZSk7XG4gICAgICAgIHBvc2l0aW9uLmNvcHkoc2NvcGUudGFyZ2V0KS5hZGQob2Zmc2V0KTtcbiAgICAgICAgaWYgKCFzY29wZS5vYmplY3QubWF0cml4QXV0b1VwZGF0ZSlcbiAgICAgICAgICBzY29wZS5vYmplY3QudXBkYXRlTWF0cml4KCk7XG4gICAgICAgIHNjb3BlLm9iamVjdC5sb29rQXQoc2NvcGUudGFyZ2V0KTtcbiAgICAgICAgaWYgKHNjb3BlLmVuYWJsZURhbXBpbmcgPT09IHRydWUpIHtcbiAgICAgICAgICBzcGhlcmljYWxEZWx0YS50aGV0YSAqPSAxIC0gc2NvcGUuZGFtcGluZ0ZhY3RvcjtcbiAgICAgICAgICBzcGhlcmljYWxEZWx0YS5waGkgKj0gMSAtIHNjb3BlLmRhbXBpbmdGYWN0b3I7XG4gICAgICAgICAgcGFuT2Zmc2V0Lm11bHRpcGx5U2NhbGFyKDEgLSBzY29wZS5kYW1waW5nRmFjdG9yKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzcGhlcmljYWxEZWx0YS5zZXQoMCwgMCwgMCk7XG4gICAgICAgICAgcGFuT2Zmc2V0LnNldCgwLCAwLCAwKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgem9vbUNoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKHNjb3BlLnpvb21Ub0N1cnNvciAmJiBwZXJmb3JtQ3Vyc29yWm9vbSkge1xuICAgICAgICAgIGxldCBuZXdSYWRpdXMgPSBudWxsO1xuICAgICAgICAgIGlmIChzY29wZS5vYmplY3QgaW5zdGFuY2VvZiBQZXJzcGVjdGl2ZUNhbWVyYSAmJiBzY29wZS5vYmplY3QuaXNQZXJzcGVjdGl2ZUNhbWVyYSkge1xuICAgICAgICAgICAgY29uc3QgcHJldlJhZGl1cyA9IG9mZnNldC5sZW5ndGgoKTtcbiAgICAgICAgICAgIG5ld1JhZGl1cyA9IGNsYW1wRGlzdGFuY2UocHJldlJhZGl1cyAqIHNjYWxlKTtcbiAgICAgICAgICAgIGNvbnN0IHJhZGl1c0RlbHRhID0gcHJldlJhZGl1cyAtIG5ld1JhZGl1cztcbiAgICAgICAgICAgIHNjb3BlLm9iamVjdC5wb3NpdGlvbi5hZGRTY2FsZWRWZWN0b3IoZG9sbHlEaXJlY3Rpb24sIHJhZGl1c0RlbHRhKTtcbiAgICAgICAgICAgIHNjb3BlLm9iamVjdC51cGRhdGVNYXRyaXhXb3JsZCgpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoc2NvcGUub2JqZWN0LmlzT3J0aG9ncmFwaGljQ2FtZXJhKSB7XG4gICAgICAgICAgICBjb25zdCBtb3VzZUJlZm9yZSA9IG5ldyBWZWN0b3IzKG1vdXNlLngsIG1vdXNlLnksIDApO1xuICAgICAgICAgICAgbW91c2VCZWZvcmUudW5wcm9qZWN0KHNjb3BlLm9iamVjdCk7XG4gICAgICAgICAgICBzY29wZS5vYmplY3Quem9vbSA9IE1hdGgubWF4KHNjb3BlLm1pblpvb20sIE1hdGgubWluKHNjb3BlLm1heFpvb20sIHNjb3BlLm9iamVjdC56b29tIC8gc2NhbGUpKTtcbiAgICAgICAgICAgIHNjb3BlLm9iamVjdC51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XG4gICAgICAgICAgICB6b29tQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICBjb25zdCBtb3VzZUFmdGVyID0gbmV3IFZlY3RvcjMobW91c2UueCwgbW91c2UueSwgMCk7XG4gICAgICAgICAgICBtb3VzZUFmdGVyLnVucHJvamVjdChzY29wZS5vYmplY3QpO1xuICAgICAgICAgICAgc2NvcGUub2JqZWN0LnBvc2l0aW9uLnN1Yihtb3VzZUFmdGVyKS5hZGQobW91c2VCZWZvcmUpO1xuICAgICAgICAgICAgc2NvcGUub2JqZWN0LnVwZGF0ZU1hdHJpeFdvcmxkKCk7XG4gICAgICAgICAgICBuZXdSYWRpdXMgPSBvZmZzZXQubGVuZ3RoKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIldBUk5JTkc6IE9yYml0Q29udHJvbHMuanMgZW5jb3VudGVyZWQgYW4gdW5rbm93biBjYW1lcmEgdHlwZSAtIHpvb20gdG8gY3Vyc29yIGRpc2FibGVkLlwiKTtcbiAgICAgICAgICAgIHNjb3BlLnpvb21Ub0N1cnNvciA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobmV3UmFkaXVzICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoc2NvcGUuc2NyZWVuU3BhY2VQYW5uaW5nKSB7XG4gICAgICAgICAgICAgIHNjb3BlLnRhcmdldC5zZXQoMCwgMCwgLTEpLnRyYW5zZm9ybURpcmVjdGlvbihzY29wZS5vYmplY3QubWF0cml4KS5tdWx0aXBseVNjYWxhcihuZXdSYWRpdXMpLmFkZChzY29wZS5vYmplY3QucG9zaXRpb24pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgX3JheS5vcmlnaW4uY29weShzY29wZS5vYmplY3QucG9zaXRpb24pO1xuICAgICAgICAgICAgICBfcmF5LmRpcmVjdGlvbi5zZXQoMCwgMCwgLTEpLnRyYW5zZm9ybURpcmVjdGlvbihzY29wZS5vYmplY3QubWF0cml4KTtcbiAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKHNjb3BlLm9iamVjdC51cC5kb3QoX3JheS5kaXJlY3Rpb24pKSA8IFRJTFRfTElNSVQpIHtcbiAgICAgICAgICAgICAgICBvYmplY3QubG9va0F0KHNjb3BlLnRhcmdldCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgX3BsYW5lLnNldEZyb21Ob3JtYWxBbmRDb3BsYW5hclBvaW50KHNjb3BlLm9iamVjdC51cCwgc2NvcGUudGFyZ2V0KTtcbiAgICAgICAgICAgICAgICBfcmF5LmludGVyc2VjdFBsYW5lKF9wbGFuZSwgc2NvcGUudGFyZ2V0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChzY29wZS5vYmplY3QgaW5zdGFuY2VvZiBPcnRob2dyYXBoaWNDYW1lcmEgJiYgc2NvcGUub2JqZWN0LmlzT3J0aG9ncmFwaGljQ2FtZXJhKSB7XG4gICAgICAgICAgem9vbUNoYW5nZWQgPSBzY2FsZSAhPT0gMTtcbiAgICAgICAgICBpZiAoem9vbUNoYW5nZWQpIHtcbiAgICAgICAgICAgIHNjb3BlLm9iamVjdC56b29tID0gTWF0aC5tYXgoc2NvcGUubWluWm9vbSwgTWF0aC5taW4oc2NvcGUubWF4Wm9vbSwgc2NvcGUub2JqZWN0Lnpvb20gLyBzY2FsZSkpO1xuICAgICAgICAgICAgc2NvcGUub2JqZWN0LnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc2NhbGUgPSAxO1xuICAgICAgICBwZXJmb3JtQ3Vyc29yWm9vbSA9IGZhbHNlO1xuICAgICAgICBpZiAoem9vbUNoYW5nZWQgfHwgbGFzdFBvc2l0aW9uLmRpc3RhbmNlVG9TcXVhcmVkKHNjb3BlLm9iamVjdC5wb3NpdGlvbikgPiBFUFMgfHwgOCAqICgxIC0gbGFzdFF1YXRlcm5pb24uZG90KHNjb3BlLm9iamVjdC5xdWF0ZXJuaW9uKSkgPiBFUFMpIHtcbiAgICAgICAgICBzY29wZS5kaXNwYXRjaEV2ZW50KGNoYW5nZUV2ZW50KTtcbiAgICAgICAgICBsYXN0UG9zaXRpb24uY29weShzY29wZS5vYmplY3QucG9zaXRpb24pO1xuICAgICAgICAgIGxhc3RRdWF0ZXJuaW9uLmNvcHkoc2NvcGUub2JqZWN0LnF1YXRlcm5pb24pO1xuICAgICAgICAgIHpvb21DaGFuZ2VkID0gZmFsc2U7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfTtcbiAgICB9KSgpO1xuICAgIHRoaXMuY29ubmVjdCA9IChkb21FbGVtZW50MikgPT4ge1xuICAgICAgc2NvcGUuZG9tRWxlbWVudCA9IGRvbUVsZW1lbnQyO1xuICAgICAgc2NvcGUuZG9tRWxlbWVudC5zdHlsZS50b3VjaEFjdGlvbiA9IFwibm9uZVwiO1xuICAgICAgc2NvcGUuZG9tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiY29udGV4dG1lbnVcIiwgb25Db250ZXh0TWVudSk7XG4gICAgICBzY29wZS5kb21FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVyZG93blwiLCBvblBvaW50ZXJEb3duKTtcbiAgICAgIHNjb3BlLmRvbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJjYW5jZWxcIiwgb25Qb2ludGVyVXApO1xuICAgICAgc2NvcGUuZG9tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwid2hlZWxcIiwgb25Nb3VzZVdoZWVsKTtcbiAgICB9O1xuICAgIHRoaXMuZGlzcG9zZSA9ICgpID0+IHtcbiAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mO1xuICAgICAgaWYgKHNjb3BlLmRvbUVsZW1lbnQpIHtcbiAgICAgICAgc2NvcGUuZG9tRWxlbWVudC5zdHlsZS50b3VjaEFjdGlvbiA9IFwiYXV0b1wiO1xuICAgICAgfVxuICAgICAgKF9hID0gc2NvcGUuZG9tRWxlbWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjb250ZXh0bWVudVwiLCBvbkNvbnRleHRNZW51KTtcbiAgICAgIChfYiA9IHNjb3BlLmRvbUVsZW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfYi5yZW1vdmVFdmVudExpc3RlbmVyKFwicG9pbnRlcmRvd25cIiwgb25Qb2ludGVyRG93bik7XG4gICAgICAoX2MgPSBzY29wZS5kb21FbGVtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2MucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJjYW5jZWxcIiwgb25Qb2ludGVyVXApO1xuICAgICAgKF9kID0gc2NvcGUuZG9tRWxlbWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9kLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ3aGVlbFwiLCBvbk1vdXNlV2hlZWwpO1xuICAgICAgKF9lID0gc2NvcGUuZG9tRWxlbWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9lLm93bmVyRG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJtb3ZlXCIsIG9uUG9pbnRlck1vdmUpO1xuICAgICAgKF9mID0gc2NvcGUuZG9tRWxlbWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9mLm93bmVyRG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJ1cFwiLCBvblBvaW50ZXJVcCk7XG4gICAgICBpZiAoc2NvcGUuX2RvbUVsZW1lbnRLZXlFdmVudHMgIT09IG51bGwpIHtcbiAgICAgICAgc2NvcGUuX2RvbUVsZW1lbnRLZXlFdmVudHMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgb25LZXlEb3duKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHNjb3BlID0gdGhpcztcbiAgICBjb25zdCBjaGFuZ2VFdmVudCA9IHsgdHlwZTogXCJjaGFuZ2VcIiB9O1xuICAgIGNvbnN0IHN0YXJ0RXZlbnQgPSB7IHR5cGU6IFwic3RhcnRcIiB9O1xuICAgIGNvbnN0IGVuZEV2ZW50ID0geyB0eXBlOiBcImVuZFwiIH07XG4gICAgY29uc3QgU1RBVEUgPSB7XG4gICAgICBOT05FOiAtMSxcbiAgICAgIFJPVEFURTogMCxcbiAgICAgIERPTExZOiAxLFxuICAgICAgUEFOOiAyLFxuICAgICAgVE9VQ0hfUk9UQVRFOiAzLFxuICAgICAgVE9VQ0hfUEFOOiA0LFxuICAgICAgVE9VQ0hfRE9MTFlfUEFOOiA1LFxuICAgICAgVE9VQ0hfRE9MTFlfUk9UQVRFOiA2XG4gICAgfTtcbiAgICBsZXQgc3RhdGUgPSBTVEFURS5OT05FO1xuICAgIGNvbnN0IEVQUyA9IDFlLTY7XG4gICAgY29uc3Qgc3BoZXJpY2FsID0gbmV3IFNwaGVyaWNhbCgpO1xuICAgIGNvbnN0IHNwaGVyaWNhbERlbHRhID0gbmV3IFNwaGVyaWNhbCgpO1xuICAgIGxldCBzY2FsZSA9IDE7XG4gICAgY29uc3QgcGFuT2Zmc2V0ID0gbmV3IFZlY3RvcjMoKTtcbiAgICBjb25zdCByb3RhdGVTdGFydCA9IG5ldyBWZWN0b3IyKCk7XG4gICAgY29uc3Qgcm90YXRlRW5kID0gbmV3IFZlY3RvcjIoKTtcbiAgICBjb25zdCByb3RhdGVEZWx0YSA9IG5ldyBWZWN0b3IyKCk7XG4gICAgY29uc3QgcGFuU3RhcnQgPSBuZXcgVmVjdG9yMigpO1xuICAgIGNvbnN0IHBhbkVuZCA9IG5ldyBWZWN0b3IyKCk7XG4gICAgY29uc3QgcGFuRGVsdGEgPSBuZXcgVmVjdG9yMigpO1xuICAgIGNvbnN0IGRvbGx5U3RhcnQgPSBuZXcgVmVjdG9yMigpO1xuICAgIGNvbnN0IGRvbGx5RW5kID0gbmV3IFZlY3RvcjIoKTtcbiAgICBjb25zdCBkb2xseURlbHRhID0gbmV3IFZlY3RvcjIoKTtcbiAgICBjb25zdCBkb2xseURpcmVjdGlvbiA9IG5ldyBWZWN0b3IzKCk7XG4gICAgY29uc3QgbW91c2UgPSBuZXcgVmVjdG9yMigpO1xuICAgIGxldCBwZXJmb3JtQ3Vyc29yWm9vbSA9IGZhbHNlO1xuICAgIGNvbnN0IHBvaW50ZXJzID0gW107XG4gICAgY29uc3QgcG9pbnRlclBvc2l0aW9ucyA9IHt9O1xuICAgIGZ1bmN0aW9uIGdldEF1dG9Sb3RhdGlvbkFuZ2xlKCkge1xuICAgICAgcmV0dXJuIDIgKiBNYXRoLlBJIC8gNjAgLyA2MCAqIHNjb3BlLmF1dG9Sb3RhdGVTcGVlZDtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0Wm9vbVNjYWxlKCkge1xuICAgICAgcmV0dXJuIE1hdGgucG93KDAuOTUsIHNjb3BlLnpvb21TcGVlZCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJvdGF0ZUxlZnQoYW5nbGUpIHtcbiAgICAgIGlmIChzY29wZS5yZXZlcnNlT3JiaXQgfHwgc2NvcGUucmV2ZXJzZUhvcml6b250YWxPcmJpdCkge1xuICAgICAgICBzcGhlcmljYWxEZWx0YS50aGV0YSArPSBhbmdsZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNwaGVyaWNhbERlbHRhLnRoZXRhIC09IGFuZ2xlO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiByb3RhdGVVcChhbmdsZSkge1xuICAgICAgaWYgKHNjb3BlLnJldmVyc2VPcmJpdCB8fCBzY29wZS5yZXZlcnNlVmVydGljYWxPcmJpdCkge1xuICAgICAgICBzcGhlcmljYWxEZWx0YS5waGkgKz0gYW5nbGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzcGhlcmljYWxEZWx0YS5waGkgLT0gYW5nbGU7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHBhbkxlZnQgPSAoKCkgPT4ge1xuICAgICAgY29uc3QgdiA9IG5ldyBWZWN0b3IzKCk7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gcGFuTGVmdDIoZGlzdGFuY2UsIG9iamVjdE1hdHJpeCkge1xuICAgICAgICB2LnNldEZyb21NYXRyaXhDb2x1bW4ob2JqZWN0TWF0cml4LCAwKTtcbiAgICAgICAgdi5tdWx0aXBseVNjYWxhcigtZGlzdGFuY2UpO1xuICAgICAgICBwYW5PZmZzZXQuYWRkKHYpO1xuICAgICAgfTtcbiAgICB9KSgpO1xuICAgIGNvbnN0IHBhblVwID0gKCgpID0+IHtcbiAgICAgIGNvbnN0IHYgPSBuZXcgVmVjdG9yMygpO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIHBhblVwMihkaXN0YW5jZSwgb2JqZWN0TWF0cml4KSB7XG4gICAgICAgIGlmIChzY29wZS5zY3JlZW5TcGFjZVBhbm5pbmcgPT09IHRydWUpIHtcbiAgICAgICAgICB2LnNldEZyb21NYXRyaXhDb2x1bW4ob2JqZWN0TWF0cml4LCAxKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2LnNldEZyb21NYXRyaXhDb2x1bW4ob2JqZWN0TWF0cml4LCAwKTtcbiAgICAgICAgICB2LmNyb3NzVmVjdG9ycyhzY29wZS5vYmplY3QudXAsIHYpO1xuICAgICAgICB9XG4gICAgICAgIHYubXVsdGlwbHlTY2FsYXIoZGlzdGFuY2UpO1xuICAgICAgICBwYW5PZmZzZXQuYWRkKHYpO1xuICAgICAgfTtcbiAgICB9KSgpO1xuICAgIGNvbnN0IHBhbiA9ICgoKSA9PiB7XG4gICAgICBjb25zdCBvZmZzZXQgPSBuZXcgVmVjdG9yMygpO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIHBhbjIoZGVsdGFYLCBkZWx0YVkpIHtcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IHNjb3BlLmRvbUVsZW1lbnQ7XG4gICAgICAgIGlmIChlbGVtZW50ICYmIHNjb3BlLm9iamVjdCBpbnN0YW5jZW9mIFBlcnNwZWN0aXZlQ2FtZXJhICYmIHNjb3BlLm9iamVjdC5pc1BlcnNwZWN0aXZlQ2FtZXJhKSB7XG4gICAgICAgICAgY29uc3QgcG9zaXRpb24gPSBzY29wZS5vYmplY3QucG9zaXRpb247XG4gICAgICAgICAgb2Zmc2V0LmNvcHkocG9zaXRpb24pLnN1YihzY29wZS50YXJnZXQpO1xuICAgICAgICAgIGxldCB0YXJnZXREaXN0YW5jZSA9IG9mZnNldC5sZW5ndGgoKTtcbiAgICAgICAgICB0YXJnZXREaXN0YW5jZSAqPSBNYXRoLnRhbihzY29wZS5vYmplY3QuZm92IC8gMiAqIE1hdGguUEkgLyAxODApO1xuICAgICAgICAgIHBhbkxlZnQoMiAqIGRlbHRhWCAqIHRhcmdldERpc3RhbmNlIC8gZWxlbWVudC5jbGllbnRIZWlnaHQsIHNjb3BlLm9iamVjdC5tYXRyaXgpO1xuICAgICAgICAgIHBhblVwKDIgKiBkZWx0YVkgKiB0YXJnZXREaXN0YW5jZSAvIGVsZW1lbnQuY2xpZW50SGVpZ2h0LCBzY29wZS5vYmplY3QubWF0cml4KTtcbiAgICAgICAgfSBlbHNlIGlmIChlbGVtZW50ICYmIHNjb3BlLm9iamVjdCBpbnN0YW5jZW9mIE9ydGhvZ3JhcGhpY0NhbWVyYSAmJiBzY29wZS5vYmplY3QuaXNPcnRob2dyYXBoaWNDYW1lcmEpIHtcbiAgICAgICAgICBwYW5MZWZ0KFxuICAgICAgICAgICAgZGVsdGFYICogKHNjb3BlLm9iamVjdC5yaWdodCAtIHNjb3BlLm9iamVjdC5sZWZ0KSAvIHNjb3BlLm9iamVjdC56b29tIC8gZWxlbWVudC5jbGllbnRXaWR0aCxcbiAgICAgICAgICAgIHNjb3BlLm9iamVjdC5tYXRyaXhcbiAgICAgICAgICApO1xuICAgICAgICAgIHBhblVwKFxuICAgICAgICAgICAgZGVsdGFZICogKHNjb3BlLm9iamVjdC50b3AgLSBzY29wZS5vYmplY3QuYm90dG9tKSAvIHNjb3BlLm9iamVjdC56b29tIC8gZWxlbWVudC5jbGllbnRIZWlnaHQsXG4gICAgICAgICAgICBzY29wZS5vYmplY3QubWF0cml4XG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oXCJXQVJOSU5HOiBPcmJpdENvbnRyb2xzLmpzIGVuY291bnRlcmVkIGFuIHVua25vd24gY2FtZXJhIHR5cGUgLSBwYW4gZGlzYWJsZWQuXCIpO1xuICAgICAgICAgIHNjb3BlLmVuYWJsZVBhbiA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0pKCk7XG4gICAgZnVuY3Rpb24gc2V0U2NhbGUobmV3U2NhbGUpIHtcbiAgICAgIGlmIChzY29wZS5vYmplY3QgaW5zdGFuY2VvZiBQZXJzcGVjdGl2ZUNhbWVyYSAmJiBzY29wZS5vYmplY3QuaXNQZXJzcGVjdGl2ZUNhbWVyYSB8fCBzY29wZS5vYmplY3QgaW5zdGFuY2VvZiBPcnRob2dyYXBoaWNDYW1lcmEgJiYgc2NvcGUub2JqZWN0LmlzT3J0aG9ncmFwaGljQ2FtZXJhKSB7XG4gICAgICAgIHNjYWxlID0gbmV3U2NhbGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJXQVJOSU5HOiBPcmJpdENvbnRyb2xzLmpzIGVuY291bnRlcmVkIGFuIHVua25vd24gY2FtZXJhIHR5cGUgLSBkb2xseS96b29tIGRpc2FibGVkLlwiKTtcbiAgICAgICAgc2NvcGUuZW5hYmxlWm9vbSA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBkb2xseU91dChkb2xseVNjYWxlKSB7XG4gICAgICBzZXRTY2FsZShzY2FsZSAvIGRvbGx5U2NhbGUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkb2xseUluKGRvbGx5U2NhbGUpIHtcbiAgICAgIHNldFNjYWxlKHNjYWxlICogZG9sbHlTY2FsZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVwZGF0ZU1vdXNlUGFyYW1ldGVycyhldmVudCkge1xuICAgICAgaWYgKCFzY29wZS56b29tVG9DdXJzb3IgfHwgIXNjb3BlLmRvbUVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcGVyZm9ybUN1cnNvclpvb20gPSB0cnVlO1xuICAgICAgY29uc3QgcmVjdCA9IHNjb3BlLmRvbUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBjb25zdCB4ID0gZXZlbnQuY2xpZW50WCAtIHJlY3QubGVmdDtcbiAgICAgIGNvbnN0IHkgPSBldmVudC5jbGllbnRZIC0gcmVjdC50b3A7XG4gICAgICBjb25zdCB3ID0gcmVjdC53aWR0aDtcbiAgICAgIGNvbnN0IGggPSByZWN0LmhlaWdodDtcbiAgICAgIG1vdXNlLnggPSB4IC8gdyAqIDIgLSAxO1xuICAgICAgbW91c2UueSA9IC0oeSAvIGgpICogMiArIDE7XG4gICAgICBkb2xseURpcmVjdGlvbi5zZXQobW91c2UueCwgbW91c2UueSwgMSkudW5wcm9qZWN0KHNjb3BlLm9iamVjdCkuc3ViKHNjb3BlLm9iamVjdC5wb3NpdGlvbikubm9ybWFsaXplKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNsYW1wRGlzdGFuY2UoZGlzdCkge1xuICAgICAgcmV0dXJuIE1hdGgubWF4KHNjb3BlLm1pbkRpc3RhbmNlLCBNYXRoLm1pbihzY29wZS5tYXhEaXN0YW5jZSwgZGlzdCkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBoYW5kbGVNb3VzZURvd25Sb3RhdGUoZXZlbnQpIHtcbiAgICAgIHJvdGF0ZVN0YXJ0LnNldChldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaGFuZGxlTW91c2VEb3duRG9sbHkoZXZlbnQpIHtcbiAgICAgIHVwZGF0ZU1vdXNlUGFyYW1ldGVycyhldmVudCk7XG4gICAgICBkb2xseVN0YXJ0LnNldChldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaGFuZGxlTW91c2VEb3duUGFuKGV2ZW50KSB7XG4gICAgICBwYW5TdGFydC5zZXQoZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhhbmRsZU1vdXNlTW92ZVJvdGF0ZShldmVudCkge1xuICAgICAgcm90YXRlRW5kLnNldChldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZKTtcbiAgICAgIHJvdGF0ZURlbHRhLnN1YlZlY3RvcnMocm90YXRlRW5kLCByb3RhdGVTdGFydCkubXVsdGlwbHlTY2FsYXIoc2NvcGUucm90YXRlU3BlZWQpO1xuICAgICAgY29uc3QgZWxlbWVudCA9IHNjb3BlLmRvbUVsZW1lbnQ7XG4gICAgICBpZiAoZWxlbWVudCkge1xuICAgICAgICByb3RhdGVMZWZ0KDIgKiBNYXRoLlBJICogcm90YXRlRGVsdGEueCAvIGVsZW1lbnQuY2xpZW50SGVpZ2h0KTtcbiAgICAgICAgcm90YXRlVXAoMiAqIE1hdGguUEkgKiByb3RhdGVEZWx0YS55IC8gZWxlbWVudC5jbGllbnRIZWlnaHQpO1xuICAgICAgfVxuICAgICAgcm90YXRlU3RhcnQuY29weShyb3RhdGVFbmQpO1xuICAgICAgc2NvcGUudXBkYXRlKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhhbmRsZU1vdXNlTW92ZURvbGx5KGV2ZW50KSB7XG4gICAgICBkb2xseUVuZC5zZXQoZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSk7XG4gICAgICBkb2xseURlbHRhLnN1YlZlY3RvcnMoZG9sbHlFbmQsIGRvbGx5U3RhcnQpO1xuICAgICAgaWYgKGRvbGx5RGVsdGEueSA+IDApIHtcbiAgICAgICAgZG9sbHlPdXQoZ2V0Wm9vbVNjYWxlKCkpO1xuICAgICAgfSBlbHNlIGlmIChkb2xseURlbHRhLnkgPCAwKSB7XG4gICAgICAgIGRvbGx5SW4oZ2V0Wm9vbVNjYWxlKCkpO1xuICAgICAgfVxuICAgICAgZG9sbHlTdGFydC5jb3B5KGRvbGx5RW5kKTtcbiAgICAgIHNjb3BlLnVwZGF0ZSgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBoYW5kbGVNb3VzZU1vdmVQYW4oZXZlbnQpIHtcbiAgICAgIHBhbkVuZC5zZXQoZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSk7XG4gICAgICBwYW5EZWx0YS5zdWJWZWN0b3JzKHBhbkVuZCwgcGFuU3RhcnQpLm11bHRpcGx5U2NhbGFyKHNjb3BlLnBhblNwZWVkKTtcbiAgICAgIHBhbihwYW5EZWx0YS54LCBwYW5EZWx0YS55KTtcbiAgICAgIHBhblN0YXJ0LmNvcHkocGFuRW5kKTtcbiAgICAgIHNjb3BlLnVwZGF0ZSgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBoYW5kbGVNb3VzZVdoZWVsKGV2ZW50KSB7XG4gICAgICB1cGRhdGVNb3VzZVBhcmFtZXRlcnMoZXZlbnQpO1xuICAgICAgaWYgKGV2ZW50LmRlbHRhWSA8IDApIHtcbiAgICAgICAgZG9sbHlJbihnZXRab29tU2NhbGUoKSk7XG4gICAgICB9IGVsc2UgaWYgKGV2ZW50LmRlbHRhWSA+IDApIHtcbiAgICAgICAgZG9sbHlPdXQoZ2V0Wm9vbVNjYWxlKCkpO1xuICAgICAgfVxuICAgICAgc2NvcGUudXBkYXRlKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhhbmRsZUtleURvd24oZXZlbnQpIHtcbiAgICAgIGxldCBuZWVkc1VwZGF0ZSA9IGZhbHNlO1xuICAgICAgc3dpdGNoIChldmVudC5jb2RlKSB7XG4gICAgICAgIGNhc2Ugc2NvcGUua2V5cy5VUDpcbiAgICAgICAgICBwYW4oMCwgc2NvcGUua2V5UGFuU3BlZWQpO1xuICAgICAgICAgIG5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBzY29wZS5rZXlzLkJPVFRPTTpcbiAgICAgICAgICBwYW4oMCwgLXNjb3BlLmtleVBhblNwZWVkKTtcbiAgICAgICAgICBuZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2Ugc2NvcGUua2V5cy5MRUZUOlxuICAgICAgICAgIHBhbihzY29wZS5rZXlQYW5TcGVlZCwgMCk7XG4gICAgICAgICAgbmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIHNjb3BlLmtleXMuUklHSFQ6XG4gICAgICAgICAgcGFuKC1zY29wZS5rZXlQYW5TcGVlZCwgMCk7XG4gICAgICAgICAgbmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKG5lZWRzVXBkYXRlKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHNjb3BlLnVwZGF0ZSgpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBoYW5kbGVUb3VjaFN0YXJ0Um90YXRlKCkge1xuICAgICAgaWYgKHBvaW50ZXJzLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgIHJvdGF0ZVN0YXJ0LnNldChwb2ludGVyc1swXS5wYWdlWCwgcG9pbnRlcnNbMF0ucGFnZVkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgeCA9IDAuNSAqIChwb2ludGVyc1swXS5wYWdlWCArIHBvaW50ZXJzWzFdLnBhZ2VYKTtcbiAgICAgICAgY29uc3QgeSA9IDAuNSAqIChwb2ludGVyc1swXS5wYWdlWSArIHBvaW50ZXJzWzFdLnBhZ2VZKTtcbiAgICAgICAgcm90YXRlU3RhcnQuc2V0KHgsIHkpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBoYW5kbGVUb3VjaFN0YXJ0UGFuKCkge1xuICAgICAgaWYgKHBvaW50ZXJzLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgIHBhblN0YXJ0LnNldChwb2ludGVyc1swXS5wYWdlWCwgcG9pbnRlcnNbMF0ucGFnZVkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgeCA9IDAuNSAqIChwb2ludGVyc1swXS5wYWdlWCArIHBvaW50ZXJzWzFdLnBhZ2VYKTtcbiAgICAgICAgY29uc3QgeSA9IDAuNSAqIChwb2ludGVyc1swXS5wYWdlWSArIHBvaW50ZXJzWzFdLnBhZ2VZKTtcbiAgICAgICAgcGFuU3RhcnQuc2V0KHgsIHkpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBoYW5kbGVUb3VjaFN0YXJ0RG9sbHkoKSB7XG4gICAgICBjb25zdCBkeCA9IHBvaW50ZXJzWzBdLnBhZ2VYIC0gcG9pbnRlcnNbMV0ucGFnZVg7XG4gICAgICBjb25zdCBkeSA9IHBvaW50ZXJzWzBdLnBhZ2VZIC0gcG9pbnRlcnNbMV0ucGFnZVk7XG4gICAgICBjb25zdCBkaXN0YW5jZSA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gICAgICBkb2xseVN0YXJ0LnNldCgwLCBkaXN0YW5jZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhhbmRsZVRvdWNoU3RhcnREb2xseVBhbigpIHtcbiAgICAgIGlmIChzY29wZS5lbmFibGVab29tKVxuICAgICAgICBoYW5kbGVUb3VjaFN0YXJ0RG9sbHkoKTtcbiAgICAgIGlmIChzY29wZS5lbmFibGVQYW4pXG4gICAgICAgIGhhbmRsZVRvdWNoU3RhcnRQYW4oKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaGFuZGxlVG91Y2hTdGFydERvbGx5Um90YXRlKCkge1xuICAgICAgaWYgKHNjb3BlLmVuYWJsZVpvb20pXG4gICAgICAgIGhhbmRsZVRvdWNoU3RhcnREb2xseSgpO1xuICAgICAgaWYgKHNjb3BlLmVuYWJsZVJvdGF0ZSlcbiAgICAgICAgaGFuZGxlVG91Y2hTdGFydFJvdGF0ZSgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBoYW5kbGVUb3VjaE1vdmVSb3RhdGUoZXZlbnQpIHtcbiAgICAgIGlmIChwb2ludGVycy5sZW5ndGggPT0gMSkge1xuICAgICAgICByb3RhdGVFbmQuc2V0KGV2ZW50LnBhZ2VYLCBldmVudC5wYWdlWSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBwb3NpdGlvbiA9IGdldFNlY29uZFBvaW50ZXJQb3NpdGlvbihldmVudCk7XG4gICAgICAgIGNvbnN0IHggPSAwLjUgKiAoZXZlbnQucGFnZVggKyBwb3NpdGlvbi54KTtcbiAgICAgICAgY29uc3QgeSA9IDAuNSAqIChldmVudC5wYWdlWSArIHBvc2l0aW9uLnkpO1xuICAgICAgICByb3RhdGVFbmQuc2V0KHgsIHkpO1xuICAgICAgfVxuICAgICAgcm90YXRlRGVsdGEuc3ViVmVjdG9ycyhyb3RhdGVFbmQsIHJvdGF0ZVN0YXJ0KS5tdWx0aXBseVNjYWxhcihzY29wZS5yb3RhdGVTcGVlZCk7XG4gICAgICBjb25zdCBlbGVtZW50ID0gc2NvcGUuZG9tRWxlbWVudDtcbiAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgIHJvdGF0ZUxlZnQoMiAqIE1hdGguUEkgKiByb3RhdGVEZWx0YS54IC8gZWxlbWVudC5jbGllbnRIZWlnaHQpO1xuICAgICAgICByb3RhdGVVcCgyICogTWF0aC5QSSAqIHJvdGF0ZURlbHRhLnkgLyBlbGVtZW50LmNsaWVudEhlaWdodCk7XG4gICAgICB9XG4gICAgICByb3RhdGVTdGFydC5jb3B5KHJvdGF0ZUVuZCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhhbmRsZVRvdWNoTW92ZVBhbihldmVudCkge1xuICAgICAgaWYgKHBvaW50ZXJzLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgIHBhbkVuZC5zZXQoZXZlbnQucGFnZVgsIGV2ZW50LnBhZ2VZKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uID0gZ2V0U2Vjb25kUG9pbnRlclBvc2l0aW9uKGV2ZW50KTtcbiAgICAgICAgY29uc3QgeCA9IDAuNSAqIChldmVudC5wYWdlWCArIHBvc2l0aW9uLngpO1xuICAgICAgICBjb25zdCB5ID0gMC41ICogKGV2ZW50LnBhZ2VZICsgcG9zaXRpb24ueSk7XG4gICAgICAgIHBhbkVuZC5zZXQoeCwgeSk7XG4gICAgICB9XG4gICAgICBwYW5EZWx0YS5zdWJWZWN0b3JzKHBhbkVuZCwgcGFuU3RhcnQpLm11bHRpcGx5U2NhbGFyKHNjb3BlLnBhblNwZWVkKTtcbiAgICAgIHBhbihwYW5EZWx0YS54LCBwYW5EZWx0YS55KTtcbiAgICAgIHBhblN0YXJ0LmNvcHkocGFuRW5kKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaGFuZGxlVG91Y2hNb3ZlRG9sbHkoZXZlbnQpIHtcbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gZ2V0U2Vjb25kUG9pbnRlclBvc2l0aW9uKGV2ZW50KTtcbiAgICAgIGNvbnN0IGR4ID0gZXZlbnQucGFnZVggLSBwb3NpdGlvbi54O1xuICAgICAgY29uc3QgZHkgPSBldmVudC5wYWdlWSAtIHBvc2l0aW9uLnk7XG4gICAgICBjb25zdCBkaXN0YW5jZSA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gICAgICBkb2xseUVuZC5zZXQoMCwgZGlzdGFuY2UpO1xuICAgICAgZG9sbHlEZWx0YS5zZXQoMCwgTWF0aC5wb3coZG9sbHlFbmQueSAvIGRvbGx5U3RhcnQueSwgc2NvcGUuem9vbVNwZWVkKSk7XG4gICAgICBkb2xseU91dChkb2xseURlbHRhLnkpO1xuICAgICAgZG9sbHlTdGFydC5jb3B5KGRvbGx5RW5kKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaGFuZGxlVG91Y2hNb3ZlRG9sbHlQYW4oZXZlbnQpIHtcbiAgICAgIGlmIChzY29wZS5lbmFibGVab29tKVxuICAgICAgICBoYW5kbGVUb3VjaE1vdmVEb2xseShldmVudCk7XG4gICAgICBpZiAoc2NvcGUuZW5hYmxlUGFuKVxuICAgICAgICBoYW5kbGVUb3VjaE1vdmVQYW4oZXZlbnQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBoYW5kbGVUb3VjaE1vdmVEb2xseVJvdGF0ZShldmVudCkge1xuICAgICAgaWYgKHNjb3BlLmVuYWJsZVpvb20pXG4gICAgICAgIGhhbmRsZVRvdWNoTW92ZURvbGx5KGV2ZW50KTtcbiAgICAgIGlmIChzY29wZS5lbmFibGVSb3RhdGUpXG4gICAgICAgIGhhbmRsZVRvdWNoTW92ZVJvdGF0ZShldmVudCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uUG9pbnRlckRvd24oZXZlbnQpIHtcbiAgICAgIHZhciBfYSwgX2I7XG4gICAgICBpZiAoc2NvcGUuZW5hYmxlZCA9PT0gZmFsc2UpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGlmIChwb2ludGVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgKF9hID0gc2NvcGUuZG9tRWxlbWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLm93bmVyRG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJtb3ZlXCIsIG9uUG9pbnRlck1vdmUpO1xuICAgICAgICAoX2IgPSBzY29wZS5kb21FbGVtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2Iub3duZXJEb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcnVwXCIsIG9uUG9pbnRlclVwKTtcbiAgICAgIH1cbiAgICAgIGFkZFBvaW50ZXIoZXZlbnQpO1xuICAgICAgaWYgKGV2ZW50LnBvaW50ZXJUeXBlID09PSBcInRvdWNoXCIpIHtcbiAgICAgICAgb25Ub3VjaFN0YXJ0KGV2ZW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9uTW91c2VEb3duKGV2ZW50KTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gb25Qb2ludGVyTW92ZShldmVudCkge1xuICAgICAgaWYgKHNjb3BlLmVuYWJsZWQgPT09IGZhbHNlKVxuICAgICAgICByZXR1cm47XG4gICAgICBpZiAoZXZlbnQucG9pbnRlclR5cGUgPT09IFwidG91Y2hcIikge1xuICAgICAgICBvblRvdWNoTW92ZShldmVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvbk1vdXNlTW92ZShldmVudCk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uUG9pbnRlclVwKGV2ZW50KSB7XG4gICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgIHJlbW92ZVBvaW50ZXIoZXZlbnQpO1xuICAgICAgaWYgKHBvaW50ZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAoX2EgPSBzY29wZS5kb21FbGVtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2EucmVsZWFzZVBvaW50ZXJDYXB0dXJlKGV2ZW50LnBvaW50ZXJJZCk7XG4gICAgICAgIChfYiA9IHNjb3BlLmRvbUVsZW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfYi5vd25lckRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJwb2ludGVybW92ZVwiLCBvblBvaW50ZXJNb3ZlKTtcbiAgICAgICAgKF9jID0gc2NvcGUuZG9tRWxlbWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9jLm93bmVyRG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJ1cFwiLCBvblBvaW50ZXJVcCk7XG4gICAgICB9XG4gICAgICBzY29wZS5kaXNwYXRjaEV2ZW50KGVuZEV2ZW50KTtcbiAgICAgIHN0YXRlID0gU1RBVEUuTk9ORTtcbiAgICB9XG4gICAgZnVuY3Rpb24gb25Nb3VzZURvd24oZXZlbnQpIHtcbiAgICAgIGxldCBtb3VzZUFjdGlvbjtcbiAgICAgIHN3aXRjaCAoZXZlbnQuYnV0dG9uKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICBtb3VzZUFjdGlvbiA9IHNjb3BlLm1vdXNlQnV0dG9ucy5MRUZUO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgbW91c2VBY3Rpb24gPSBzY29wZS5tb3VzZUJ1dHRvbnMuTUlERExFO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgbW91c2VBY3Rpb24gPSBzY29wZS5tb3VzZUJ1dHRvbnMuUklHSFQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgbW91c2VBY3Rpb24gPSAtMTtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAobW91c2VBY3Rpb24pIHtcbiAgICAgICAgY2FzZSBNT1VTRS5ET0xMWTpcbiAgICAgICAgICBpZiAoc2NvcGUuZW5hYmxlWm9vbSA9PT0gZmFsc2UpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgaGFuZGxlTW91c2VEb3duRG9sbHkoZXZlbnQpO1xuICAgICAgICAgIHN0YXRlID0gU1RBVEUuRE9MTFk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgTU9VU0UuUk9UQVRFOlxuICAgICAgICAgIGlmIChldmVudC5jdHJsS2V5IHx8IGV2ZW50Lm1ldGFLZXkgfHwgZXZlbnQuc2hpZnRLZXkpIHtcbiAgICAgICAgICAgIGlmIChzY29wZS5lbmFibGVQYW4gPT09IGZhbHNlKVxuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBoYW5kbGVNb3VzZURvd25QYW4oZXZlbnQpO1xuICAgICAgICAgICAgc3RhdGUgPSBTVEFURS5QQU47XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChzY29wZS5lbmFibGVSb3RhdGUgPT09IGZhbHNlKVxuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBoYW5kbGVNb3VzZURvd25Sb3RhdGUoZXZlbnQpO1xuICAgICAgICAgICAgc3RhdGUgPSBTVEFURS5ST1RBVEU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIE1PVVNFLlBBTjpcbiAgICAgICAgICBpZiAoZXZlbnQuY3RybEtleSB8fCBldmVudC5tZXRhS2V5IHx8IGV2ZW50LnNoaWZ0S2V5KSB7XG4gICAgICAgICAgICBpZiAoc2NvcGUuZW5hYmxlUm90YXRlID09PSBmYWxzZSlcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgaGFuZGxlTW91c2VEb3duUm90YXRlKGV2ZW50KTtcbiAgICAgICAgICAgIHN0YXRlID0gU1RBVEUuUk9UQVRFO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoc2NvcGUuZW5hYmxlUGFuID09PSBmYWxzZSlcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgaGFuZGxlTW91c2VEb3duUGFuKGV2ZW50KTtcbiAgICAgICAgICAgIHN0YXRlID0gU1RBVEUuUEFOO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBzdGF0ZSA9IFNUQVRFLk5PTkU7XG4gICAgICB9XG4gICAgICBpZiAoc3RhdGUgIT09IFNUQVRFLk5PTkUpIHtcbiAgICAgICAgc2NvcGUuZGlzcGF0Y2hFdmVudChzdGFydEV2ZW50KTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gb25Nb3VzZU1vdmUoZXZlbnQpIHtcbiAgICAgIGlmIChzY29wZS5lbmFibGVkID09PSBmYWxzZSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgc3dpdGNoIChzdGF0ZSkge1xuICAgICAgICBjYXNlIFNUQVRFLlJPVEFURTpcbiAgICAgICAgICBpZiAoc2NvcGUuZW5hYmxlUm90YXRlID09PSBmYWxzZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICBoYW5kbGVNb3VzZU1vdmVSb3RhdGUoZXZlbnQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFNUQVRFLkRPTExZOlxuICAgICAgICAgIGlmIChzY29wZS5lbmFibGVab29tID09PSBmYWxzZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICBoYW5kbGVNb3VzZU1vdmVEb2xseShldmVudCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgU1RBVEUuUEFOOlxuICAgICAgICAgIGlmIChzY29wZS5lbmFibGVQYW4gPT09IGZhbHNlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIGhhbmRsZU1vdXNlTW92ZVBhbihldmVudCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uTW91c2VXaGVlbChldmVudCkge1xuICAgICAgaWYgKHNjb3BlLmVuYWJsZWQgPT09IGZhbHNlIHx8IHNjb3BlLmVuYWJsZVpvb20gPT09IGZhbHNlIHx8IHN0YXRlICE9PSBTVEFURS5OT05FICYmIHN0YXRlICE9PSBTVEFURS5ST1RBVEUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHNjb3BlLmRpc3BhdGNoRXZlbnQoc3RhcnRFdmVudCk7XG4gICAgICBoYW5kbGVNb3VzZVdoZWVsKGV2ZW50KTtcbiAgICAgIHNjb3BlLmRpc3BhdGNoRXZlbnQoZW5kRXZlbnQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBvbktleURvd24oZXZlbnQpIHtcbiAgICAgIGlmIChzY29wZS5lbmFibGVkID09PSBmYWxzZSB8fCBzY29wZS5lbmFibGVQYW4gPT09IGZhbHNlKVxuICAgICAgICByZXR1cm47XG4gICAgICBoYW5kbGVLZXlEb3duKGV2ZW50KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gb25Ub3VjaFN0YXJ0KGV2ZW50KSB7XG4gICAgICB0cmFja1BvaW50ZXIoZXZlbnQpO1xuICAgICAgc3dpdGNoIChwb2ludGVycy5sZW5ndGgpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHN3aXRjaCAoc2NvcGUudG91Y2hlcy5PTkUpIHtcbiAgICAgICAgICAgIGNhc2UgVE9VQ0guUk9UQVRFOlxuICAgICAgICAgICAgICBpZiAoc2NvcGUuZW5hYmxlUm90YXRlID09PSBmYWxzZSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIGhhbmRsZVRvdWNoU3RhcnRSb3RhdGUoKTtcbiAgICAgICAgICAgICAgc3RhdGUgPSBTVEFURS5UT1VDSF9ST1RBVEU7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBUT1VDSC5QQU46XG4gICAgICAgICAgICAgIGlmIChzY29wZS5lbmFibGVQYW4gPT09IGZhbHNlKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgaGFuZGxlVG91Y2hTdGFydFBhbigpO1xuICAgICAgICAgICAgICBzdGF0ZSA9IFNUQVRFLlRPVUNIX1BBTjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICBzdGF0ZSA9IFNUQVRFLk5PTkU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgc3dpdGNoIChzY29wZS50b3VjaGVzLlRXTykge1xuICAgICAgICAgICAgY2FzZSBUT1VDSC5ET0xMWV9QQU46XG4gICAgICAgICAgICAgIGlmIChzY29wZS5lbmFibGVab29tID09PSBmYWxzZSAmJiBzY29wZS5lbmFibGVQYW4gPT09IGZhbHNlKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgaGFuZGxlVG91Y2hTdGFydERvbGx5UGFuKCk7XG4gICAgICAgICAgICAgIHN0YXRlID0gU1RBVEUuVE9VQ0hfRE9MTFlfUEFOO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgVE9VQ0guRE9MTFlfUk9UQVRFOlxuICAgICAgICAgICAgICBpZiAoc2NvcGUuZW5hYmxlWm9vbSA9PT0gZmFsc2UgJiYgc2NvcGUuZW5hYmxlUm90YXRlID09PSBmYWxzZSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIGhhbmRsZVRvdWNoU3RhcnREb2xseVJvdGF0ZSgpO1xuICAgICAgICAgICAgICBzdGF0ZSA9IFNUQVRFLlRPVUNIX0RPTExZX1JPVEFURTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICBzdGF0ZSA9IFNUQVRFLk5PTkU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHN0YXRlID0gU1RBVEUuTk9ORTtcbiAgICAgIH1cbiAgICAgIGlmIChzdGF0ZSAhPT0gU1RBVEUuTk9ORSkge1xuICAgICAgICBzY29wZS5kaXNwYXRjaEV2ZW50KHN0YXJ0RXZlbnQpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBvblRvdWNoTW92ZShldmVudCkge1xuICAgICAgdHJhY2tQb2ludGVyKGV2ZW50KTtcbiAgICAgIHN3aXRjaCAoc3RhdGUpIHtcbiAgICAgICAgY2FzZSBTVEFURS5UT1VDSF9ST1RBVEU6XG4gICAgICAgICAgaWYgKHNjb3BlLmVuYWJsZVJvdGF0ZSA9PT0gZmFsc2UpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgaGFuZGxlVG91Y2hNb3ZlUm90YXRlKGV2ZW50KTtcbiAgICAgICAgICBzY29wZS51cGRhdGUoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBTVEFURS5UT1VDSF9QQU46XG4gICAgICAgICAgaWYgKHNjb3BlLmVuYWJsZVBhbiA9PT0gZmFsc2UpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgaGFuZGxlVG91Y2hNb3ZlUGFuKGV2ZW50KTtcbiAgICAgICAgICBzY29wZS51cGRhdGUoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBTVEFURS5UT1VDSF9ET0xMWV9QQU46XG4gICAgICAgICAgaWYgKHNjb3BlLmVuYWJsZVpvb20gPT09IGZhbHNlICYmIHNjb3BlLmVuYWJsZVBhbiA9PT0gZmFsc2UpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgaGFuZGxlVG91Y2hNb3ZlRG9sbHlQYW4oZXZlbnQpO1xuICAgICAgICAgIHNjb3BlLnVwZGF0ZSgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFNUQVRFLlRPVUNIX0RPTExZX1JPVEFURTpcbiAgICAgICAgICBpZiAoc2NvcGUuZW5hYmxlWm9vbSA9PT0gZmFsc2UgJiYgc2NvcGUuZW5hYmxlUm90YXRlID09PSBmYWxzZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICBoYW5kbGVUb3VjaE1vdmVEb2xseVJvdGF0ZShldmVudCk7XG4gICAgICAgICAgc2NvcGUudXBkYXRlKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgc3RhdGUgPSBTVEFURS5OT05FO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBvbkNvbnRleHRNZW51KGV2ZW50KSB7XG4gICAgICBpZiAoc2NvcGUuZW5hYmxlZCA9PT0gZmFsc2UpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFkZFBvaW50ZXIoZXZlbnQpIHtcbiAgICAgIHBvaW50ZXJzLnB1c2goZXZlbnQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZW1vdmVQb2ludGVyKGV2ZW50KSB7XG4gICAgICBkZWxldGUgcG9pbnRlclBvc2l0aW9uc1tldmVudC5wb2ludGVySWRdO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb2ludGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAocG9pbnRlcnNbaV0ucG9pbnRlcklkID09IGV2ZW50LnBvaW50ZXJJZCkge1xuICAgICAgICAgIHBvaW50ZXJzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gdHJhY2tQb2ludGVyKGV2ZW50KSB7XG4gICAgICBsZXQgcG9zaXRpb24gPSBwb2ludGVyUG9zaXRpb25zW2V2ZW50LnBvaW50ZXJJZF07XG4gICAgICBpZiAocG9zaXRpb24gPT09IHZvaWQgMCkge1xuICAgICAgICBwb3NpdGlvbiA9IG5ldyBWZWN0b3IyKCk7XG4gICAgICAgIHBvaW50ZXJQb3NpdGlvbnNbZXZlbnQucG9pbnRlcklkXSA9IHBvc2l0aW9uO1xuICAgICAgfVxuICAgICAgcG9zaXRpb24uc2V0KGV2ZW50LnBhZ2VYLCBldmVudC5wYWdlWSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldFNlY29uZFBvaW50ZXJQb3NpdGlvbihldmVudCkge1xuICAgICAgY29uc3QgcG9pbnRlciA9IGV2ZW50LnBvaW50ZXJJZCA9PT0gcG9pbnRlcnNbMF0ucG9pbnRlcklkID8gcG9pbnRlcnNbMV0gOiBwb2ludGVyc1swXTtcbiAgICAgIHJldHVybiBwb2ludGVyUG9zaXRpb25zW3BvaW50ZXIucG9pbnRlcklkXTtcbiAgICB9XG4gICAgdGhpcy5kb2xseUluID0gKGRvbGx5U2NhbGUgPSBnZXRab29tU2NhbGUoKSkgPT4ge1xuICAgICAgZG9sbHlJbihkb2xseVNjYWxlKTtcbiAgICAgIHNjb3BlLnVwZGF0ZSgpO1xuICAgIH07XG4gICAgdGhpcy5kb2xseU91dCA9IChkb2xseVNjYWxlID0gZ2V0Wm9vbVNjYWxlKCkpID0+IHtcbiAgICAgIGRvbGx5T3V0KGRvbGx5U2NhbGUpO1xuICAgICAgc2NvcGUudXBkYXRlKCk7XG4gICAgfTtcbiAgICB0aGlzLmdldFNjYWxlID0gKCkgPT4ge1xuICAgICAgcmV0dXJuIHNjYWxlO1xuICAgIH07XG4gICAgdGhpcy5zZXRTY2FsZSA9IChuZXdTY2FsZSkgPT4ge1xuICAgICAgc2V0U2NhbGUobmV3U2NhbGUpO1xuICAgICAgc2NvcGUudXBkYXRlKCk7XG4gICAgfTtcbiAgICB0aGlzLmdldFpvb21TY2FsZSA9ICgpID0+IHtcbiAgICAgIHJldHVybiBnZXRab29tU2NhbGUoKTtcbiAgICB9O1xuICAgIGlmIChkb21FbGVtZW50ICE9PSB2b2lkIDApXG4gICAgICB0aGlzLmNvbm5lY3QoZG9tRWxlbWVudCk7XG4gICAgdGhpcy51cGRhdGUoKTtcbiAgfVxufVxuY2xhc3MgTWFwQ29udHJvbHMgZXh0ZW5kcyBPcmJpdENvbnRyb2xzIHtcbiAgY29uc3RydWN0b3Iob2JqZWN0LCBkb21FbGVtZW50KSB7XG4gICAgc3VwZXIob2JqZWN0LCBkb21FbGVtZW50KTtcbiAgICB0aGlzLnNjcmVlblNwYWNlUGFubmluZyA9IGZhbHNlO1xuICAgIHRoaXMubW91c2VCdXR0b25zLkxFRlQgPSBNT1VTRS5QQU47XG4gICAgdGhpcy5tb3VzZUJ1dHRvbnMuUklHSFQgPSBNT1VTRS5ST1RBVEU7XG4gICAgdGhpcy50b3VjaGVzLk9ORSA9IFRPVUNILlBBTjtcbiAgICB0aGlzLnRvdWNoZXMuVFdPID0gVE9VQ0guRE9MTFlfUk9UQVRFO1xuICB9XG59XG5leHBvcnQge1xuICBNYXBDb250cm9scyxcbiAgT3JiaXRDb250cm9sc1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU9yYml0Q29udHJvbHMuanMubWFwXG4iXSwibmFtZXMiOlsiX19kZWZQcm9wIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJfX2RlZk5vcm1hbFByb3AiLCJvYmoiLCJrZXkiLCJ2YWx1ZSIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsIl9fcHVibGljRmllbGQiLCJWZWN0b3IzIiwiTU9VU0UiLCJUT1VDSCIsIlF1YXRlcm5pb24iLCJQZXJzcGVjdGl2ZUNhbWVyYSIsIk9ydGhvZ3JhcGhpY0NhbWVyYSIsIlNwaGVyaWNhbCIsIlZlY3RvcjIiLCJSYXkiLCJQbGFuZSIsIkV2ZW50RGlzcGF0Y2hlciIsIl9yYXkiLCJfcGxhbmUiLCJUSUxUX0xJTUlUIiwiTWF0aCIsImNvcyIsIlBJIiwibW9kdWxvV3JhcEFyb3VuZCIsIm9mZnNldCIsImNhcGFjaXR5IiwiT3JiaXRDb250cm9scyIsImNvbnN0cnVjdG9yIiwib2JqZWN0IiwiZG9tRWxlbWVudCIsIkluZmluaXR5IiwiTEVGVCIsIlVQIiwiUklHSFQiLCJCT1RUT00iLCJST1RBVEUiLCJNSURETEUiLCJET0xMWSIsIlBBTiIsIk9ORSIsIlRXTyIsIkRPTExZX1BBTiIsInRhcmdldDAiLCJ0YXJnZXQiLCJjbG9uZSIsInBvc2l0aW9uMCIsInBvc2l0aW9uIiwiem9vbTAiLCJ6b29tIiwiZ2V0UG9sYXJBbmdsZSIsInNwaGVyaWNhbCIsInBoaSIsImdldEF6aW11dGhhbEFuZ2xlIiwidGhldGEiLCJzZXRQb2xhckFuZ2xlIiwiY3VycmVudFBoaSIsInBoaURpc3QiLCJhYnMiLCJzcGhlcmljYWxEZWx0YSIsInNjb3BlIiwidXBkYXRlIiwic2V0QXppbXV0aGFsQW5nbGUiLCJjdXJyZW50VGhldGEiLCJ0aGV0YURpc3QiLCJnZXREaXN0YW5jZSIsImRpc3RhbmNlVG8iLCJsaXN0ZW5Ub0tleUV2ZW50cyIsImRvbUVsZW1lbnQyIiwiYWRkRXZlbnRMaXN0ZW5lciIsIm9uS2V5RG93biIsIl9kb21FbGVtZW50S2V5RXZlbnRzIiwic3RvcExpc3RlblRvS2V5RXZlbnRzIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInNhdmVTdGF0ZSIsImNvcHkiLCJyZXNldCIsInVwZGF0ZVByb2plY3Rpb25NYXRyaXgiLCJkaXNwYXRjaEV2ZW50IiwiY2hhbmdlRXZlbnQiLCJzdGF0ZSIsIlNUQVRFIiwiTk9ORSIsInVwIiwicXVhdCIsInNldEZyb21Vbml0VmVjdG9ycyIsInF1YXRJbnZlcnNlIiwiaW52ZXJ0IiwibGFzdFBvc2l0aW9uIiwibGFzdFF1YXRlcm5pb24iLCJ0d29QSSIsInN1YiIsImFwcGx5UXVhdGVybmlvbiIsInNldEZyb21WZWN0b3IzIiwiYXV0b1JvdGF0ZSIsInJvdGF0ZUxlZnQiLCJnZXRBdXRvUm90YXRpb25BbmdsZSIsImVuYWJsZURhbXBpbmciLCJkYW1waW5nRmFjdG9yIiwibWluIiwibWluQXppbXV0aEFuZ2xlIiwibWF4IiwibWF4QXppbXV0aEFuZ2xlIiwiaXNGaW5pdGUiLCJtaW5Qb2xhckFuZ2xlIiwibWF4UG9sYXJBbmdsZSIsIm1ha2VTYWZlIiwiYWRkU2NhbGVkVmVjdG9yIiwicGFuT2Zmc2V0IiwiYWRkIiwiem9vbVRvQ3Vyc29yIiwicGVyZm9ybUN1cnNvclpvb20iLCJpc09ydGhvZ3JhcGhpY0NhbWVyYSIsInJhZGl1cyIsImNsYW1wRGlzdGFuY2UiLCJzY2FsZSIsInNldEZyb21TcGhlcmljYWwiLCJtYXRyaXhBdXRvVXBkYXRlIiwidXBkYXRlTWF0cml4IiwibG9va0F0IiwibXVsdGlwbHlTY2FsYXIiLCJzZXQiLCJ6b29tQ2hhbmdlZCIsIm5ld1JhZGl1cyIsImlzUGVyc3BlY3RpdmVDYW1lcmEiLCJwcmV2UmFkaXVzIiwibGVuZ3RoIiwicmFkaXVzRGVsdGEiLCJkb2xseURpcmVjdGlvbiIsInVwZGF0ZU1hdHJpeFdvcmxkIiwibW91c2VCZWZvcmUiLCJtb3VzZSIsIngiLCJ5IiwidW5wcm9qZWN0IiwibWluWm9vbSIsIm1heFpvb20iLCJtb3VzZUFmdGVyIiwiY29uc29sZSIsIndhcm4iLCJzY3JlZW5TcGFjZVBhbm5pbmciLCJ0cmFuc2Zvcm1EaXJlY3Rpb24iLCJtYXRyaXgiLCJvcmlnaW4iLCJkaXJlY3Rpb24iLCJkb3QiLCJzZXRGcm9tTm9ybWFsQW5kQ29wbGFuYXJQb2ludCIsImludGVyc2VjdFBsYW5lIiwiZGlzdGFuY2VUb1NxdWFyZWQiLCJFUFMiLCJxdWF0ZXJuaW9uIiwiY29ubmVjdCIsInN0eWxlIiwidG91Y2hBY3Rpb24iLCJvbkNvbnRleHRNZW51Iiwib25Qb2ludGVyRG93biIsIm9uUG9pbnRlclVwIiwib25Nb3VzZVdoZWVsIiwiZGlzcG9zZSIsIl9hIiwiX2IiLCJfYyIsIl9kIiwiX2UiLCJfZiIsIm93bmVyRG9jdW1lbnQiLCJvblBvaW50ZXJNb3ZlIiwidHlwZSIsInN0YXJ0RXZlbnQiLCJlbmRFdmVudCIsIlRPVUNIX1JPVEFURSIsIlRPVUNIX1BBTiIsIlRPVUNIX0RPTExZX1BBTiIsIlRPVUNIX0RPTExZX1JPVEFURSIsInJvdGF0ZVN0YXJ0Iiwicm90YXRlRW5kIiwicm90YXRlRGVsdGEiLCJwYW5TdGFydCIsInBhbkVuZCIsInBhbkRlbHRhIiwiZG9sbHlTdGFydCIsImRvbGx5RW5kIiwiZG9sbHlEZWx0YSIsInBvaW50ZXJzIiwicG9pbnRlclBvc2l0aW9ucyIsImF1dG9Sb3RhdGVTcGVlZCIsImdldFpvb21TY2FsZSIsInBvdyIsInpvb21TcGVlZCIsImFuZ2xlIiwicmV2ZXJzZU9yYml0IiwicmV2ZXJzZUhvcml6b250YWxPcmJpdCIsInJvdGF0ZVVwIiwicmV2ZXJzZVZlcnRpY2FsT3JiaXQiLCJwYW5MZWZ0IiwidiIsInBhbkxlZnQyIiwiZGlzdGFuY2UiLCJvYmplY3RNYXRyaXgiLCJzZXRGcm9tTWF0cml4Q29sdW1uIiwicGFuVXAiLCJwYW5VcDIiLCJjcm9zc1ZlY3RvcnMiLCJwYW4iLCJwYW4yIiwiZGVsdGFYIiwiZGVsdGFZIiwiZWxlbWVudCIsInRhcmdldERpc3RhbmNlIiwidGFuIiwiZm92IiwiY2xpZW50SGVpZ2h0IiwicmlnaHQiLCJsZWZ0IiwiY2xpZW50V2lkdGgiLCJ0b3AiLCJib3R0b20iLCJlbmFibGVQYW4iLCJzZXRTY2FsZSIsIm5ld1NjYWxlIiwiZW5hYmxlWm9vbSIsImRvbGx5T3V0IiwiZG9sbHlTY2FsZSIsImRvbGx5SW4iLCJ1cGRhdGVNb3VzZVBhcmFtZXRlcnMiLCJldmVudCIsInJlY3QiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJjbGllbnRYIiwiY2xpZW50WSIsInciLCJ3aWR0aCIsImgiLCJoZWlnaHQiLCJub3JtYWxpemUiLCJkaXN0IiwibWluRGlzdGFuY2UiLCJtYXhEaXN0YW5jZSIsImhhbmRsZU1vdXNlRG93blJvdGF0ZSIsImhhbmRsZU1vdXNlRG93bkRvbGx5IiwiaGFuZGxlTW91c2VEb3duUGFuIiwiaGFuZGxlTW91c2VNb3ZlUm90YXRlIiwic3ViVmVjdG9ycyIsInJvdGF0ZVNwZWVkIiwiaGFuZGxlTW91c2VNb3ZlRG9sbHkiLCJoYW5kbGVNb3VzZU1vdmVQYW4iLCJwYW5TcGVlZCIsImhhbmRsZU1vdXNlV2hlZWwiLCJoYW5kbGVLZXlEb3duIiwibmVlZHNVcGRhdGUiLCJjb2RlIiwia2V5cyIsImtleVBhblNwZWVkIiwicHJldmVudERlZmF1bHQiLCJoYW5kbGVUb3VjaFN0YXJ0Um90YXRlIiwicGFnZVgiLCJwYWdlWSIsImhhbmRsZVRvdWNoU3RhcnRQYW4iLCJoYW5kbGVUb3VjaFN0YXJ0RG9sbHkiLCJkeCIsImR5Iiwic3FydCIsImhhbmRsZVRvdWNoU3RhcnREb2xseVBhbiIsImhhbmRsZVRvdWNoU3RhcnREb2xseVJvdGF0ZSIsImVuYWJsZVJvdGF0ZSIsImhhbmRsZVRvdWNoTW92ZVJvdGF0ZSIsImdldFNlY29uZFBvaW50ZXJQb3NpdGlvbiIsImhhbmRsZVRvdWNoTW92ZVBhbiIsImhhbmRsZVRvdWNoTW92ZURvbGx5IiwiaGFuZGxlVG91Y2hNb3ZlRG9sbHlQYW4iLCJoYW5kbGVUb3VjaE1vdmVEb2xseVJvdGF0ZSIsImVuYWJsZWQiLCJhZGRQb2ludGVyIiwicG9pbnRlclR5cGUiLCJvblRvdWNoU3RhcnQiLCJvbk1vdXNlRG93biIsIm9uVG91Y2hNb3ZlIiwib25Nb3VzZU1vdmUiLCJyZW1vdmVQb2ludGVyIiwicmVsZWFzZVBvaW50ZXJDYXB0dXJlIiwicG9pbnRlcklkIiwibW91c2VBY3Rpb24iLCJidXR0b24iLCJtb3VzZUJ1dHRvbnMiLCJjdHJsS2V5IiwibWV0YUtleSIsInNoaWZ0S2V5IiwidHJhY2tQb2ludGVyIiwidG91Y2hlcyIsIkRPTExZX1JPVEFURSIsInB1c2giLCJpIiwic3BsaWNlIiwicG9pbnRlciIsImdldFNjYWxlIiwiTWFwQ29udHJvbHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/three-stdlib/controls/OrbitControls.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/three-stdlib/loaders/EXRLoader.js":
/*!********************************************************!*\
  !*** ./node_modules/three-stdlib/loaders/EXRLoader.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EXRLoader: () => (/* binding */ EXRLoader)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var fflate__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! fflate */ \"(ssr)/./node_modules/fflate/esm/index.mjs\");\n/* harmony import */ var _polyfill_constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_polyfill/constants.js */ \"(ssr)/./node_modules/three-stdlib/_polyfill/constants.js\");\n\n\n\nconst hasColorSpace = _polyfill_constants_js__WEBPACK_IMPORTED_MODULE_0__.version >= 152;\nclass EXRLoader extends three__WEBPACK_IMPORTED_MODULE_1__.DataTextureLoader {\n    constructor(manager){\n        super(manager);\n        this.type = three__WEBPACK_IMPORTED_MODULE_1__.HalfFloatType;\n    }\n    parse(buffer) {\n        const USHORT_RANGE = 1 << 16;\n        const BITMAP_SIZE = USHORT_RANGE >> 3;\n        const HUF_ENCBITS = 16;\n        const HUF_DECBITS = 14;\n        const HUF_ENCSIZE = (1 << HUF_ENCBITS) + 1;\n        const HUF_DECSIZE = 1 << HUF_DECBITS;\n        const HUF_DECMASK = HUF_DECSIZE - 1;\n        const NBITS = 16;\n        const A_OFFSET = 1 << NBITS - 1;\n        const MOD_MASK = (1 << NBITS) - 1;\n        const SHORT_ZEROCODE_RUN = 59;\n        const LONG_ZEROCODE_RUN = 63;\n        const SHORTEST_LONG_RUN = 2 + LONG_ZEROCODE_RUN - SHORT_ZEROCODE_RUN;\n        const ULONG_SIZE = 8;\n        const FLOAT32_SIZE = 4;\n        const INT32_SIZE = 4;\n        const INT16_SIZE = 2;\n        const INT8_SIZE = 1;\n        const STATIC_HUFFMAN = 0;\n        const DEFLATE = 1;\n        const UNKNOWN = 0;\n        const LOSSY_DCT = 1;\n        const RLE = 2;\n        const logBase = Math.pow(2.7182818, 2.2);\n        function reverseLutFromBitmap(bitmap, lut) {\n            var k = 0;\n            for(var i = 0; i < USHORT_RANGE; ++i){\n                if (i == 0 || bitmap[i >> 3] & 1 << (i & 7)) {\n                    lut[k++] = i;\n                }\n            }\n            var n = k - 1;\n            while(k < USHORT_RANGE)lut[k++] = 0;\n            return n;\n        }\n        function hufClearDecTable(hdec) {\n            for(var i = 0; i < HUF_DECSIZE; i++){\n                hdec[i] = {};\n                hdec[i].len = 0;\n                hdec[i].lit = 0;\n                hdec[i].p = null;\n            }\n        }\n        const getBitsReturn = {\n            l: 0,\n            c: 0,\n            lc: 0\n        };\n        function getBits(nBits, c, lc, uInt8Array2, inOffset) {\n            while(lc < nBits){\n                c = c << 8 | parseUint8Array(uInt8Array2, inOffset);\n                lc += 8;\n            }\n            lc -= nBits;\n            getBitsReturn.l = c >> lc & (1 << nBits) - 1;\n            getBitsReturn.c = c;\n            getBitsReturn.lc = lc;\n        }\n        const hufTableBuffer = new Array(59);\n        function hufCanonicalCodeTable(hcode) {\n            for(var i = 0; i <= 58; ++i)hufTableBuffer[i] = 0;\n            for(var i = 0; i < HUF_ENCSIZE; ++i)hufTableBuffer[hcode[i]] += 1;\n            var c = 0;\n            for(var i = 58; i > 0; --i){\n                var nc = c + hufTableBuffer[i] >> 1;\n                hufTableBuffer[i] = c;\n                c = nc;\n            }\n            for(var i = 0; i < HUF_ENCSIZE; ++i){\n                var l = hcode[i];\n                if (l > 0) hcode[i] = l | hufTableBuffer[l]++ << 6;\n            }\n        }\n        function hufUnpackEncTable(uInt8Array2, inDataView, inOffset, ni, im, iM, hcode) {\n            var p = inOffset;\n            var c = 0;\n            var lc = 0;\n            for(; im <= iM; im++){\n                if (p.value - inOffset.value > ni) return false;\n                getBits(6, c, lc, uInt8Array2, p);\n                var l = getBitsReturn.l;\n                c = getBitsReturn.c;\n                lc = getBitsReturn.lc;\n                hcode[im] = l;\n                if (l == LONG_ZEROCODE_RUN) {\n                    if (p.value - inOffset.value > ni) {\n                        throw \"Something wrong with hufUnpackEncTable\";\n                    }\n                    getBits(8, c, lc, uInt8Array2, p);\n                    var zerun = getBitsReturn.l + SHORTEST_LONG_RUN;\n                    c = getBitsReturn.c;\n                    lc = getBitsReturn.lc;\n                    if (im + zerun > iM + 1) {\n                        throw \"Something wrong with hufUnpackEncTable\";\n                    }\n                    while(zerun--)hcode[im++] = 0;\n                    im--;\n                } else if (l >= SHORT_ZEROCODE_RUN) {\n                    var zerun = l - SHORT_ZEROCODE_RUN + 2;\n                    if (im + zerun > iM + 1) {\n                        throw \"Something wrong with hufUnpackEncTable\";\n                    }\n                    while(zerun--)hcode[im++] = 0;\n                    im--;\n                }\n            }\n            hufCanonicalCodeTable(hcode);\n        }\n        function hufLength(code) {\n            return code & 63;\n        }\n        function hufCode(code) {\n            return code >> 6;\n        }\n        function hufBuildDecTable(hcode, im, iM, hdecod) {\n            for(; im <= iM; im++){\n                var c = hufCode(hcode[im]);\n                var l = hufLength(hcode[im]);\n                if (c >> l) {\n                    throw \"Invalid table entry\";\n                }\n                if (l > HUF_DECBITS) {\n                    var pl = hdecod[c >> l - HUF_DECBITS];\n                    if (pl.len) {\n                        throw \"Invalid table entry\";\n                    }\n                    pl.lit++;\n                    if (pl.p) {\n                        var p = pl.p;\n                        pl.p = new Array(pl.lit);\n                        for(var i = 0; i < pl.lit - 1; ++i){\n                            pl.p[i] = p[i];\n                        }\n                    } else {\n                        pl.p = new Array(1);\n                    }\n                    pl.p[pl.lit - 1] = im;\n                } else if (l) {\n                    var plOffset = 0;\n                    for(var i = 1 << HUF_DECBITS - l; i > 0; i--){\n                        var pl = hdecod[(c << HUF_DECBITS - l) + plOffset];\n                        if (pl.len || pl.p) {\n                            throw \"Invalid table entry\";\n                        }\n                        pl.len = l;\n                        pl.lit = im;\n                        plOffset++;\n                    }\n                }\n            }\n            return true;\n        }\n        const getCharReturn = {\n            c: 0,\n            lc: 0\n        };\n        function getChar(c, lc, uInt8Array2, inOffset) {\n            c = c << 8 | parseUint8Array(uInt8Array2, inOffset);\n            lc += 8;\n            getCharReturn.c = c;\n            getCharReturn.lc = lc;\n        }\n        const getCodeReturn = {\n            c: 0,\n            lc: 0\n        };\n        function getCode(po, rlc, c, lc, uInt8Array2, inDataView, inOffset, outBuffer, outBufferOffset, outBufferEndOffset) {\n            if (po == rlc) {\n                if (lc < 8) {\n                    getChar(c, lc, uInt8Array2, inOffset);\n                    c = getCharReturn.c;\n                    lc = getCharReturn.lc;\n                }\n                lc -= 8;\n                var cs = c >> lc;\n                var cs = new Uint8Array([\n                    cs\n                ])[0];\n                if (outBufferOffset.value + cs > outBufferEndOffset) {\n                    return false;\n                }\n                var s = outBuffer[outBufferOffset.value - 1];\n                while(cs-- > 0){\n                    outBuffer[outBufferOffset.value++] = s;\n                }\n            } else if (outBufferOffset.value < outBufferEndOffset) {\n                outBuffer[outBufferOffset.value++] = po;\n            } else {\n                return false;\n            }\n            getCodeReturn.c = c;\n            getCodeReturn.lc = lc;\n        }\n        function UInt16(value) {\n            return value & 65535;\n        }\n        function Int16(value) {\n            var ref = UInt16(value);\n            return ref > 32767 ? ref - 65536 : ref;\n        }\n        const wdec14Return = {\n            a: 0,\n            b: 0\n        };\n        function wdec14(l, h) {\n            var ls = Int16(l);\n            var hs = Int16(h);\n            var hi = hs;\n            var ai = ls + (hi & 1) + (hi >> 1);\n            var as = ai;\n            var bs = ai - hi;\n            wdec14Return.a = as;\n            wdec14Return.b = bs;\n        }\n        function wdec16(l, h) {\n            var m = UInt16(l);\n            var d = UInt16(h);\n            var bb = m - (d >> 1) & MOD_MASK;\n            var aa = d + bb - A_OFFSET & MOD_MASK;\n            wdec14Return.a = aa;\n            wdec14Return.b = bb;\n        }\n        function wav2Decode(buffer2, j, nx, ox, ny, oy, mx) {\n            var w14 = mx < 1 << 14;\n            var n = nx > ny ? ny : nx;\n            var p = 1;\n            var p2;\n            while(p <= n)p <<= 1;\n            p >>= 1;\n            p2 = p;\n            p >>= 1;\n            while(p >= 1){\n                var py = 0;\n                var ey = py + oy * (ny - p2);\n                var oy1 = oy * p;\n                var oy2 = oy * p2;\n                var ox1 = ox * p;\n                var ox2 = ox * p2;\n                var i00, i01, i10, i11;\n                for(; py <= ey; py += oy2){\n                    var px = py;\n                    var ex = py + ox * (nx - p2);\n                    for(; px <= ex; px += ox2){\n                        var p01 = px + ox1;\n                        var p10 = px + oy1;\n                        var p11 = p10 + ox1;\n                        if (w14) {\n                            wdec14(buffer2[px + j], buffer2[p10 + j]);\n                            i00 = wdec14Return.a;\n                            i10 = wdec14Return.b;\n                            wdec14(buffer2[p01 + j], buffer2[p11 + j]);\n                            i01 = wdec14Return.a;\n                            i11 = wdec14Return.b;\n                            wdec14(i00, i01);\n                            buffer2[px + j] = wdec14Return.a;\n                            buffer2[p01 + j] = wdec14Return.b;\n                            wdec14(i10, i11);\n                            buffer2[p10 + j] = wdec14Return.a;\n                            buffer2[p11 + j] = wdec14Return.b;\n                        } else {\n                            wdec16(buffer2[px + j], buffer2[p10 + j]);\n                            i00 = wdec14Return.a;\n                            i10 = wdec14Return.b;\n                            wdec16(buffer2[p01 + j], buffer2[p11 + j]);\n                            i01 = wdec14Return.a;\n                            i11 = wdec14Return.b;\n                            wdec16(i00, i01);\n                            buffer2[px + j] = wdec14Return.a;\n                            buffer2[p01 + j] = wdec14Return.b;\n                            wdec16(i10, i11);\n                            buffer2[p10 + j] = wdec14Return.a;\n                            buffer2[p11 + j] = wdec14Return.b;\n                        }\n                    }\n                    if (nx & p) {\n                        var p10 = px + oy1;\n                        if (w14) wdec14(buffer2[px + j], buffer2[p10 + j]);\n                        else wdec16(buffer2[px + j], buffer2[p10 + j]);\n                        i00 = wdec14Return.a;\n                        buffer2[p10 + j] = wdec14Return.b;\n                        buffer2[px + j] = i00;\n                    }\n                }\n                if (ny & p) {\n                    var px = py;\n                    var ex = py + ox * (nx - p2);\n                    for(; px <= ex; px += ox2){\n                        var p01 = px + ox1;\n                        if (w14) wdec14(buffer2[px + j], buffer2[p01 + j]);\n                        else wdec16(buffer2[px + j], buffer2[p01 + j]);\n                        i00 = wdec14Return.a;\n                        buffer2[p01 + j] = wdec14Return.b;\n                        buffer2[px + j] = i00;\n                    }\n                }\n                p2 = p;\n                p >>= 1;\n            }\n            return py;\n        }\n        function hufDecode(encodingTable, decodingTable, uInt8Array2, inDataView, inOffset, ni, rlc, no, outBuffer, outOffset) {\n            var c = 0;\n            var lc = 0;\n            var outBufferEndOffset = no;\n            var inOffsetEnd = Math.trunc(inOffset.value + (ni + 7) / 8);\n            while(inOffset.value < inOffsetEnd){\n                getChar(c, lc, uInt8Array2, inOffset);\n                c = getCharReturn.c;\n                lc = getCharReturn.lc;\n                while(lc >= HUF_DECBITS){\n                    var index = c >> lc - HUF_DECBITS & HUF_DECMASK;\n                    var pl = decodingTable[index];\n                    if (pl.len) {\n                        lc -= pl.len;\n                        getCode(pl.lit, rlc, c, lc, uInt8Array2, inDataView, inOffset, outBuffer, outOffset, outBufferEndOffset);\n                        c = getCodeReturn.c;\n                        lc = getCodeReturn.lc;\n                    } else {\n                        if (!pl.p) {\n                            throw \"hufDecode issues\";\n                        }\n                        var j;\n                        for(j = 0; j < pl.lit; j++){\n                            var l = hufLength(encodingTable[pl.p[j]]);\n                            while(lc < l && inOffset.value < inOffsetEnd){\n                                getChar(c, lc, uInt8Array2, inOffset);\n                                c = getCharReturn.c;\n                                lc = getCharReturn.lc;\n                            }\n                            if (lc >= l) {\n                                if (hufCode(encodingTable[pl.p[j]]) == (c >> lc - l & (1 << l) - 1)) {\n                                    lc -= l;\n                                    getCode(pl.p[j], rlc, c, lc, uInt8Array2, inDataView, inOffset, outBuffer, outOffset, outBufferEndOffset);\n                                    c = getCodeReturn.c;\n                                    lc = getCodeReturn.lc;\n                                    break;\n                                }\n                            }\n                        }\n                        if (j == pl.lit) {\n                            throw \"hufDecode issues\";\n                        }\n                    }\n                }\n            }\n            var i = 8 - ni & 7;\n            c >>= i;\n            lc -= i;\n            while(lc > 0){\n                var pl = decodingTable[c << HUF_DECBITS - lc & HUF_DECMASK];\n                if (pl.len) {\n                    lc -= pl.len;\n                    getCode(pl.lit, rlc, c, lc, uInt8Array2, inDataView, inOffset, outBuffer, outOffset, outBufferEndOffset);\n                    c = getCodeReturn.c;\n                    lc = getCodeReturn.lc;\n                } else {\n                    throw \"hufDecode issues\";\n                }\n            }\n            return true;\n        }\n        function hufUncompress(uInt8Array2, inDataView, inOffset, nCompressed, outBuffer, nRaw) {\n            var outOffset = {\n                value: 0\n            };\n            var initialInOffset = inOffset.value;\n            var im = parseUint32(inDataView, inOffset);\n            var iM = parseUint32(inDataView, inOffset);\n            inOffset.value += 4;\n            var nBits = parseUint32(inDataView, inOffset);\n            inOffset.value += 4;\n            if (im < 0 || im >= HUF_ENCSIZE || iM < 0 || iM >= HUF_ENCSIZE) {\n                throw \"Something wrong with HUF_ENCSIZE\";\n            }\n            var freq = new Array(HUF_ENCSIZE);\n            var hdec = new Array(HUF_DECSIZE);\n            hufClearDecTable(hdec);\n            var ni = nCompressed - (inOffset.value - initialInOffset);\n            hufUnpackEncTable(uInt8Array2, inDataView, inOffset, ni, im, iM, freq);\n            if (nBits > 8 * (nCompressed - (inOffset.value - initialInOffset))) {\n                throw \"Something wrong with hufUncompress\";\n            }\n            hufBuildDecTable(freq, im, iM, hdec);\n            hufDecode(freq, hdec, uInt8Array2, inDataView, inOffset, nBits, iM, nRaw, outBuffer, outOffset);\n        }\n        function applyLut(lut, data, nData) {\n            for(var i = 0; i < nData; ++i){\n                data[i] = lut[data[i]];\n            }\n        }\n        function predictor(source) {\n            for(var t = 1; t < source.length; t++){\n                var d = source[t - 1] + source[t] - 128;\n                source[t] = d;\n            }\n        }\n        function interleaveScalar(source, out) {\n            var t1 = 0;\n            var t2 = Math.floor((source.length + 1) / 2);\n            var s = 0;\n            var stop = source.length - 1;\n            while(true){\n                if (s > stop) break;\n                out[s++] = source[t1++];\n                if (s > stop) break;\n                out[s++] = source[t2++];\n            }\n        }\n        function decodeRunLength(source) {\n            var size = source.byteLength;\n            var out = new Array();\n            var p = 0;\n            var reader = new DataView(source);\n            while(size > 0){\n                var l = reader.getInt8(p++);\n                if (l < 0) {\n                    var count = -l;\n                    size -= count + 1;\n                    for(var i = 0; i < count; i++){\n                        out.push(reader.getUint8(p++));\n                    }\n                } else {\n                    var count = l;\n                    size -= 2;\n                    var value = reader.getUint8(p++);\n                    for(var i = 0; i < count + 1; i++){\n                        out.push(value);\n                    }\n                }\n            }\n            return out;\n        }\n        function lossyDctDecode(cscSet, rowPtrs, channelData, acBuffer, dcBuffer, outBuffer) {\n            var dataView = new DataView(outBuffer.buffer);\n            var width = channelData[cscSet.idx[0]].width;\n            var height = channelData[cscSet.idx[0]].height;\n            var numComp = 3;\n            var numFullBlocksX = Math.floor(width / 8);\n            var numBlocksX = Math.ceil(width / 8);\n            var numBlocksY = Math.ceil(height / 8);\n            var leftoverX = width - (numBlocksX - 1) * 8;\n            var leftoverY = height - (numBlocksY - 1) * 8;\n            var currAcComp = {\n                value: 0\n            };\n            var currDcComp = new Array(numComp);\n            var dctData = new Array(numComp);\n            var halfZigBlock = new Array(numComp);\n            var rowBlock = new Array(numComp);\n            var rowOffsets = new Array(numComp);\n            for(let comp2 = 0; comp2 < numComp; ++comp2){\n                rowOffsets[comp2] = rowPtrs[cscSet.idx[comp2]];\n                currDcComp[comp2] = comp2 < 1 ? 0 : currDcComp[comp2 - 1] + numBlocksX * numBlocksY;\n                dctData[comp2] = new Float32Array(64);\n                halfZigBlock[comp2] = new Uint16Array(64);\n                rowBlock[comp2] = new Uint16Array(numBlocksX * 64);\n            }\n            for(let blocky = 0; blocky < numBlocksY; ++blocky){\n                var maxY = 8;\n                if (blocky == numBlocksY - 1) maxY = leftoverY;\n                var maxX = 8;\n                for(let blockx = 0; blockx < numBlocksX; ++blockx){\n                    if (blockx == numBlocksX - 1) maxX = leftoverX;\n                    for(let comp2 = 0; comp2 < numComp; ++comp2){\n                        halfZigBlock[comp2].fill(0);\n                        halfZigBlock[comp2][0] = dcBuffer[currDcComp[comp2]++];\n                        unRleAC(currAcComp, acBuffer, halfZigBlock[comp2]);\n                        unZigZag(halfZigBlock[comp2], dctData[comp2]);\n                        dctInverse(dctData[comp2]);\n                    }\n                    {\n                        csc709Inverse(dctData);\n                    }\n                    for(let comp2 = 0; comp2 < numComp; ++comp2){\n                        convertToHalf(dctData[comp2], rowBlock[comp2], blockx * 64);\n                    }\n                }\n                let offset2 = 0;\n                for(let comp2 = 0; comp2 < numComp; ++comp2){\n                    const type2 = channelData[cscSet.idx[comp2]].type;\n                    for(let y2 = 8 * blocky; y2 < 8 * blocky + maxY; ++y2){\n                        offset2 = rowOffsets[comp2][y2];\n                        for(let blockx = 0; blockx < numFullBlocksX; ++blockx){\n                            const src = blockx * 64 + (y2 & 7) * 8;\n                            dataView.setUint16(offset2 + 0 * INT16_SIZE * type2, rowBlock[comp2][src + 0], true);\n                            dataView.setUint16(offset2 + 1 * INT16_SIZE * type2, rowBlock[comp2][src + 1], true);\n                            dataView.setUint16(offset2 + 2 * INT16_SIZE * type2, rowBlock[comp2][src + 2], true);\n                            dataView.setUint16(offset2 + 3 * INT16_SIZE * type2, rowBlock[comp2][src + 3], true);\n                            dataView.setUint16(offset2 + 4 * INT16_SIZE * type2, rowBlock[comp2][src + 4], true);\n                            dataView.setUint16(offset2 + 5 * INT16_SIZE * type2, rowBlock[comp2][src + 5], true);\n                            dataView.setUint16(offset2 + 6 * INT16_SIZE * type2, rowBlock[comp2][src + 6], true);\n                            dataView.setUint16(offset2 + 7 * INT16_SIZE * type2, rowBlock[comp2][src + 7], true);\n                            offset2 += 8 * INT16_SIZE * type2;\n                        }\n                    }\n                    if (numFullBlocksX != numBlocksX) {\n                        for(let y2 = 8 * blocky; y2 < 8 * blocky + maxY; ++y2){\n                            const offset3 = rowOffsets[comp2][y2] + 8 * numFullBlocksX * INT16_SIZE * type2;\n                            const src = numFullBlocksX * 64 + (y2 & 7) * 8;\n                            for(let x2 = 0; x2 < maxX; ++x2){\n                                dataView.setUint16(offset3 + x2 * INT16_SIZE * type2, rowBlock[comp2][src + x2], true);\n                            }\n                        }\n                    }\n                }\n            }\n            var halfRow = new Uint16Array(width);\n            var dataView = new DataView(outBuffer.buffer);\n            for(var comp = 0; comp < numComp; ++comp){\n                channelData[cscSet.idx[comp]].decoded = true;\n                var type = channelData[cscSet.idx[comp]].type;\n                if (channelData[comp].type != 2) continue;\n                for(var y = 0; y < height; ++y){\n                    const offset2 = rowOffsets[comp][y];\n                    for(var x = 0; x < width; ++x){\n                        halfRow[x] = dataView.getUint16(offset2 + x * INT16_SIZE * type, true);\n                    }\n                    for(var x = 0; x < width; ++x){\n                        dataView.setFloat32(offset2 + x * INT16_SIZE * type, decodeFloat16(halfRow[x]), true);\n                    }\n                }\n            }\n        }\n        function unRleAC(currAcComp, acBuffer, halfZigBlock) {\n            var acValue;\n            var dctComp = 1;\n            while(dctComp < 64){\n                acValue = acBuffer[currAcComp.value];\n                if (acValue == 65280) {\n                    dctComp = 64;\n                } else if (acValue >> 8 == 255) {\n                    dctComp += acValue & 255;\n                } else {\n                    halfZigBlock[dctComp] = acValue;\n                    dctComp++;\n                }\n                currAcComp.value++;\n            }\n        }\n        function unZigZag(src, dst) {\n            dst[0] = decodeFloat16(src[0]);\n            dst[1] = decodeFloat16(src[1]);\n            dst[2] = decodeFloat16(src[5]);\n            dst[3] = decodeFloat16(src[6]);\n            dst[4] = decodeFloat16(src[14]);\n            dst[5] = decodeFloat16(src[15]);\n            dst[6] = decodeFloat16(src[27]);\n            dst[7] = decodeFloat16(src[28]);\n            dst[8] = decodeFloat16(src[2]);\n            dst[9] = decodeFloat16(src[4]);\n            dst[10] = decodeFloat16(src[7]);\n            dst[11] = decodeFloat16(src[13]);\n            dst[12] = decodeFloat16(src[16]);\n            dst[13] = decodeFloat16(src[26]);\n            dst[14] = decodeFloat16(src[29]);\n            dst[15] = decodeFloat16(src[42]);\n            dst[16] = decodeFloat16(src[3]);\n            dst[17] = decodeFloat16(src[8]);\n            dst[18] = decodeFloat16(src[12]);\n            dst[19] = decodeFloat16(src[17]);\n            dst[20] = decodeFloat16(src[25]);\n            dst[21] = decodeFloat16(src[30]);\n            dst[22] = decodeFloat16(src[41]);\n            dst[23] = decodeFloat16(src[43]);\n            dst[24] = decodeFloat16(src[9]);\n            dst[25] = decodeFloat16(src[11]);\n            dst[26] = decodeFloat16(src[18]);\n            dst[27] = decodeFloat16(src[24]);\n            dst[28] = decodeFloat16(src[31]);\n            dst[29] = decodeFloat16(src[40]);\n            dst[30] = decodeFloat16(src[44]);\n            dst[31] = decodeFloat16(src[53]);\n            dst[32] = decodeFloat16(src[10]);\n            dst[33] = decodeFloat16(src[19]);\n            dst[34] = decodeFloat16(src[23]);\n            dst[35] = decodeFloat16(src[32]);\n            dst[36] = decodeFloat16(src[39]);\n            dst[37] = decodeFloat16(src[45]);\n            dst[38] = decodeFloat16(src[52]);\n            dst[39] = decodeFloat16(src[54]);\n            dst[40] = decodeFloat16(src[20]);\n            dst[41] = decodeFloat16(src[22]);\n            dst[42] = decodeFloat16(src[33]);\n            dst[43] = decodeFloat16(src[38]);\n            dst[44] = decodeFloat16(src[46]);\n            dst[45] = decodeFloat16(src[51]);\n            dst[46] = decodeFloat16(src[55]);\n            dst[47] = decodeFloat16(src[60]);\n            dst[48] = decodeFloat16(src[21]);\n            dst[49] = decodeFloat16(src[34]);\n            dst[50] = decodeFloat16(src[37]);\n            dst[51] = decodeFloat16(src[47]);\n            dst[52] = decodeFloat16(src[50]);\n            dst[53] = decodeFloat16(src[56]);\n            dst[54] = decodeFloat16(src[59]);\n            dst[55] = decodeFloat16(src[61]);\n            dst[56] = decodeFloat16(src[35]);\n            dst[57] = decodeFloat16(src[36]);\n            dst[58] = decodeFloat16(src[48]);\n            dst[59] = decodeFloat16(src[49]);\n            dst[60] = decodeFloat16(src[57]);\n            dst[61] = decodeFloat16(src[58]);\n            dst[62] = decodeFloat16(src[62]);\n            dst[63] = decodeFloat16(src[63]);\n        }\n        function dctInverse(data) {\n            const a = 0.5 * Math.cos(3.14159 / 4);\n            const b = 0.5 * Math.cos(3.14159 / 16);\n            const c = 0.5 * Math.cos(3.14159 / 8);\n            const d = 0.5 * Math.cos(3 * 3.14159 / 16);\n            const e = 0.5 * Math.cos(5 * 3.14159 / 16);\n            const f = 0.5 * Math.cos(3 * 3.14159 / 8);\n            const g = 0.5 * Math.cos(7 * 3.14159 / 16);\n            var alpha = new Array(4);\n            var beta = new Array(4);\n            var theta = new Array(4);\n            var gamma = new Array(4);\n            for(var row = 0; row < 8; ++row){\n                var rowPtr = row * 8;\n                alpha[0] = c * data[rowPtr + 2];\n                alpha[1] = f * data[rowPtr + 2];\n                alpha[2] = c * data[rowPtr + 6];\n                alpha[3] = f * data[rowPtr + 6];\n                beta[0] = b * data[rowPtr + 1] + d * data[rowPtr + 3] + e * data[rowPtr + 5] + g * data[rowPtr + 7];\n                beta[1] = d * data[rowPtr + 1] - g * data[rowPtr + 3] - b * data[rowPtr + 5] - e * data[rowPtr + 7];\n                beta[2] = e * data[rowPtr + 1] - b * data[rowPtr + 3] + g * data[rowPtr + 5] + d * data[rowPtr + 7];\n                beta[3] = g * data[rowPtr + 1] - e * data[rowPtr + 3] + d * data[rowPtr + 5] - b * data[rowPtr + 7];\n                theta[0] = a * (data[rowPtr + 0] + data[rowPtr + 4]);\n                theta[3] = a * (data[rowPtr + 0] - data[rowPtr + 4]);\n                theta[1] = alpha[0] + alpha[3];\n                theta[2] = alpha[1] - alpha[2];\n                gamma[0] = theta[0] + theta[1];\n                gamma[1] = theta[3] + theta[2];\n                gamma[2] = theta[3] - theta[2];\n                gamma[3] = theta[0] - theta[1];\n                data[rowPtr + 0] = gamma[0] + beta[0];\n                data[rowPtr + 1] = gamma[1] + beta[1];\n                data[rowPtr + 2] = gamma[2] + beta[2];\n                data[rowPtr + 3] = gamma[3] + beta[3];\n                data[rowPtr + 4] = gamma[3] - beta[3];\n                data[rowPtr + 5] = gamma[2] - beta[2];\n                data[rowPtr + 6] = gamma[1] - beta[1];\n                data[rowPtr + 7] = gamma[0] - beta[0];\n            }\n            for(var column = 0; column < 8; ++column){\n                alpha[0] = c * data[16 + column];\n                alpha[1] = f * data[16 + column];\n                alpha[2] = c * data[48 + column];\n                alpha[3] = f * data[48 + column];\n                beta[0] = b * data[8 + column] + d * data[24 + column] + e * data[40 + column] + g * data[56 + column];\n                beta[1] = d * data[8 + column] - g * data[24 + column] - b * data[40 + column] - e * data[56 + column];\n                beta[2] = e * data[8 + column] - b * data[24 + column] + g * data[40 + column] + d * data[56 + column];\n                beta[3] = g * data[8 + column] - e * data[24 + column] + d * data[40 + column] - b * data[56 + column];\n                theta[0] = a * (data[column] + data[32 + column]);\n                theta[3] = a * (data[column] - data[32 + column]);\n                theta[1] = alpha[0] + alpha[3];\n                theta[2] = alpha[1] - alpha[2];\n                gamma[0] = theta[0] + theta[1];\n                gamma[1] = theta[3] + theta[2];\n                gamma[2] = theta[3] - theta[2];\n                gamma[3] = theta[0] - theta[1];\n                data[0 + column] = gamma[0] + beta[0];\n                data[8 + column] = gamma[1] + beta[1];\n                data[16 + column] = gamma[2] + beta[2];\n                data[24 + column] = gamma[3] + beta[3];\n                data[32 + column] = gamma[3] - beta[3];\n                data[40 + column] = gamma[2] - beta[2];\n                data[48 + column] = gamma[1] - beta[1];\n                data[56 + column] = gamma[0] - beta[0];\n            }\n        }\n        function csc709Inverse(data) {\n            for(var i = 0; i < 64; ++i){\n                var y = data[0][i];\n                var cb = data[1][i];\n                var cr = data[2][i];\n                data[0][i] = y + 1.5747 * cr;\n                data[1][i] = y - 0.1873 * cb - 0.4682 * cr;\n                data[2][i] = y + 1.8556 * cb;\n            }\n        }\n        function convertToHalf(src, dst, idx) {\n            for(var i = 0; i < 64; ++i){\n                dst[idx + i] = three__WEBPACK_IMPORTED_MODULE_1__.DataUtils.toHalfFloat(toLinear(src[i]));\n            }\n        }\n        function toLinear(float) {\n            if (float <= 1) {\n                return Math.sign(float) * Math.pow(Math.abs(float), 2.2);\n            } else {\n                return Math.sign(float) * Math.pow(logBase, Math.abs(float) - 1);\n            }\n        }\n        function uncompressRAW(info) {\n            return new DataView(info.array.buffer, info.offset.value, info.size);\n        }\n        function uncompressRLE(info) {\n            var compressed = info.viewer.buffer.slice(info.offset.value, info.offset.value + info.size);\n            var rawBuffer = new Uint8Array(decodeRunLength(compressed));\n            var tmpBuffer = new Uint8Array(rawBuffer.length);\n            predictor(rawBuffer);\n            interleaveScalar(rawBuffer, tmpBuffer);\n            return new DataView(tmpBuffer.buffer);\n        }\n        function uncompressZIP(info) {\n            var compressed = info.array.slice(info.offset.value, info.offset.value + info.size);\n            var rawBuffer = (0,fflate__WEBPACK_IMPORTED_MODULE_2__.unzlibSync)(compressed);\n            var tmpBuffer = new Uint8Array(rawBuffer.length);\n            predictor(rawBuffer);\n            interleaveScalar(rawBuffer, tmpBuffer);\n            return new DataView(tmpBuffer.buffer);\n        }\n        function uncompressPIZ(info) {\n            var inDataView = info.viewer;\n            var inOffset = {\n                value: info.offset.value\n            };\n            var outBuffer = new Uint16Array(info.width * info.scanlineBlockSize * (info.channels * info.type));\n            var bitmap = new Uint8Array(BITMAP_SIZE);\n            var outBufferEnd = 0;\n            var pizChannelData = new Array(info.channels);\n            for(var i = 0; i < info.channels; i++){\n                pizChannelData[i] = {};\n                pizChannelData[i][\"start\"] = outBufferEnd;\n                pizChannelData[i][\"end\"] = pizChannelData[i][\"start\"];\n                pizChannelData[i][\"nx\"] = info.width;\n                pizChannelData[i][\"ny\"] = info.lines;\n                pizChannelData[i][\"size\"] = info.type;\n                outBufferEnd += pizChannelData[i].nx * pizChannelData[i].ny * pizChannelData[i].size;\n            }\n            var minNonZero = parseUint16(inDataView, inOffset);\n            var maxNonZero = parseUint16(inDataView, inOffset);\n            if (maxNonZero >= BITMAP_SIZE) {\n                throw \"Something is wrong with PIZ_COMPRESSION BITMAP_SIZE\";\n            }\n            if (minNonZero <= maxNonZero) {\n                for(var i = 0; i < maxNonZero - minNonZero + 1; i++){\n                    bitmap[i + minNonZero] = parseUint8(inDataView, inOffset);\n                }\n            }\n            var lut = new Uint16Array(USHORT_RANGE);\n            var maxValue = reverseLutFromBitmap(bitmap, lut);\n            var length = parseUint32(inDataView, inOffset);\n            hufUncompress(info.array, inDataView, inOffset, length, outBuffer, outBufferEnd);\n            for(var i = 0; i < info.channels; ++i){\n                var cd = pizChannelData[i];\n                for(var j = 0; j < pizChannelData[i].size; ++j){\n                    wav2Decode(outBuffer, cd.start + j, cd.nx, cd.size, cd.ny, cd.nx * cd.size, maxValue);\n                }\n            }\n            applyLut(lut, outBuffer, outBufferEnd);\n            var tmpOffset2 = 0;\n            var tmpBuffer = new Uint8Array(outBuffer.buffer.byteLength);\n            for(var y = 0; y < info.lines; y++){\n                for(var c = 0; c < info.channels; c++){\n                    var cd = pizChannelData[c];\n                    var n = cd.nx * cd.size;\n                    var cp = new Uint8Array(outBuffer.buffer, cd.end * INT16_SIZE, n * INT16_SIZE);\n                    tmpBuffer.set(cp, tmpOffset2);\n                    tmpOffset2 += n * INT16_SIZE;\n                    cd.end += n;\n                }\n            }\n            return new DataView(tmpBuffer.buffer);\n        }\n        function uncompressPXR(info) {\n            var compressed = info.array.slice(info.offset.value, info.offset.value + info.size);\n            var rawBuffer = (0,fflate__WEBPACK_IMPORTED_MODULE_2__.unzlibSync)(compressed);\n            const sz = info.lines * info.channels * info.width;\n            const tmpBuffer = info.type == 1 ? new Uint16Array(sz) : new Uint32Array(sz);\n            let tmpBufferEnd = 0;\n            let writePtr = 0;\n            const ptr = new Array(4);\n            for(let y = 0; y < info.lines; y++){\n                for(let c = 0; c < info.channels; c++){\n                    let pixel = 0;\n                    switch(info.type){\n                        case 1:\n                            ptr[0] = tmpBufferEnd;\n                            ptr[1] = ptr[0] + info.width;\n                            tmpBufferEnd = ptr[1] + info.width;\n                            for(let j = 0; j < info.width; ++j){\n                                const diff = rawBuffer[ptr[0]++] << 8 | rawBuffer[ptr[1]++];\n                                pixel += diff;\n                                tmpBuffer[writePtr] = pixel;\n                                writePtr++;\n                            }\n                            break;\n                        case 2:\n                            ptr[0] = tmpBufferEnd;\n                            ptr[1] = ptr[0] + info.width;\n                            ptr[2] = ptr[1] + info.width;\n                            tmpBufferEnd = ptr[2] + info.width;\n                            for(let j = 0; j < info.width; ++j){\n                                const diff = rawBuffer[ptr[0]++] << 24 | rawBuffer[ptr[1]++] << 16 | rawBuffer[ptr[2]++] << 8;\n                                pixel += diff;\n                                tmpBuffer[writePtr] = pixel;\n                                writePtr++;\n                            }\n                            break;\n                    }\n                }\n            }\n            return new DataView(tmpBuffer.buffer);\n        }\n        function uncompressDWA(info) {\n            var inDataView = info.viewer;\n            var inOffset = {\n                value: info.offset.value\n            };\n            var outBuffer = new Uint8Array(info.width * info.lines * (info.channels * info.type * INT16_SIZE));\n            var dwaHeader = {\n                version: parseInt64(inDataView, inOffset),\n                unknownUncompressedSize: parseInt64(inDataView, inOffset),\n                unknownCompressedSize: parseInt64(inDataView, inOffset),\n                acCompressedSize: parseInt64(inDataView, inOffset),\n                dcCompressedSize: parseInt64(inDataView, inOffset),\n                rleCompressedSize: parseInt64(inDataView, inOffset),\n                rleUncompressedSize: parseInt64(inDataView, inOffset),\n                rleRawSize: parseInt64(inDataView, inOffset),\n                totalAcUncompressedCount: parseInt64(inDataView, inOffset),\n                totalDcUncompressedCount: parseInt64(inDataView, inOffset),\n                acCompression: parseInt64(inDataView, inOffset)\n            };\n            if (dwaHeader.version < 2) {\n                throw \"EXRLoader.parse: \" + EXRHeader.compression + \" version \" + dwaHeader.version + \" is unsupported\";\n            }\n            var channelRules = new Array();\n            var ruleSize = parseUint16(inDataView, inOffset) - INT16_SIZE;\n            while(ruleSize > 0){\n                var name = parseNullTerminatedString(inDataView.buffer, inOffset);\n                var value = parseUint8(inDataView, inOffset);\n                var compression = value >> 2 & 3;\n                var csc = (value >> 4) - 1;\n                var index = new Int8Array([\n                    csc\n                ])[0];\n                var type = parseUint8(inDataView, inOffset);\n                channelRules.push({\n                    name,\n                    index,\n                    type,\n                    compression\n                });\n                ruleSize -= name.length + 3;\n            }\n            var channels = EXRHeader.channels;\n            var channelData = new Array(info.channels);\n            for(var i = 0; i < info.channels; ++i){\n                var cd = channelData[i] = {};\n                var channel = channels[i];\n                cd.name = channel.name;\n                cd.compression = UNKNOWN;\n                cd.decoded = false;\n                cd.type = channel.pixelType;\n                cd.pLinear = channel.pLinear;\n                cd.width = info.width;\n                cd.height = info.lines;\n            }\n            var cscSet = {\n                idx: new Array(3)\n            };\n            for(var offset2 = 0; offset2 < info.channels; ++offset2){\n                var cd = channelData[offset2];\n                for(var i = 0; i < channelRules.length; ++i){\n                    var rule = channelRules[i];\n                    if (cd.name == rule.name) {\n                        cd.compression = rule.compression;\n                        if (rule.index >= 0) {\n                            cscSet.idx[rule.index] = offset2;\n                        }\n                        cd.offset = offset2;\n                    }\n                }\n            }\n            if (dwaHeader.acCompressedSize > 0) {\n                switch(dwaHeader.acCompression){\n                    case STATIC_HUFFMAN:\n                        var acBuffer = new Uint16Array(dwaHeader.totalAcUncompressedCount);\n                        hufUncompress(info.array, inDataView, inOffset, dwaHeader.acCompressedSize, acBuffer, dwaHeader.totalAcUncompressedCount);\n                        break;\n                    case DEFLATE:\n                        var compressed = info.array.slice(inOffset.value, inOffset.value + dwaHeader.totalAcUncompressedCount);\n                        var data = (0,fflate__WEBPACK_IMPORTED_MODULE_2__.unzlibSync)(compressed);\n                        var acBuffer = new Uint16Array(data.buffer);\n                        inOffset.value += dwaHeader.totalAcUncompressedCount;\n                        break;\n                }\n            }\n            if (dwaHeader.dcCompressedSize > 0) {\n                var zlibInfo = {\n                    array: info.array,\n                    offset: inOffset,\n                    size: dwaHeader.dcCompressedSize\n                };\n                var dcBuffer = new Uint16Array(uncompressZIP(zlibInfo).buffer);\n                inOffset.value += dwaHeader.dcCompressedSize;\n            }\n            if (dwaHeader.rleRawSize > 0) {\n                var compressed = info.array.slice(inOffset.value, inOffset.value + dwaHeader.rleCompressedSize);\n                var data = (0,fflate__WEBPACK_IMPORTED_MODULE_2__.unzlibSync)(compressed);\n                var rleBuffer = decodeRunLength(data.buffer);\n                inOffset.value += dwaHeader.rleCompressedSize;\n            }\n            var outBufferEnd = 0;\n            var rowOffsets = new Array(channelData.length);\n            for(var i = 0; i < rowOffsets.length; ++i){\n                rowOffsets[i] = new Array();\n            }\n            for(var y = 0; y < info.lines; ++y){\n                for(var chan = 0; chan < channelData.length; ++chan){\n                    rowOffsets[chan].push(outBufferEnd);\n                    outBufferEnd += channelData[chan].width * info.type * INT16_SIZE;\n                }\n            }\n            lossyDctDecode(cscSet, rowOffsets, channelData, acBuffer, dcBuffer, outBuffer);\n            for(var i = 0; i < channelData.length; ++i){\n                var cd = channelData[i];\n                if (cd.decoded) continue;\n                switch(cd.compression){\n                    case RLE:\n                        var row = 0;\n                        var rleOffset = 0;\n                        for(var y = 0; y < info.lines; ++y){\n                            var rowOffsetBytes = rowOffsets[i][row];\n                            for(var x = 0; x < cd.width; ++x){\n                                for(var byte = 0; byte < INT16_SIZE * cd.type; ++byte){\n                                    outBuffer[rowOffsetBytes++] = rleBuffer[rleOffset + byte * cd.width * cd.height];\n                                }\n                                rleOffset++;\n                            }\n                            row++;\n                        }\n                        break;\n                    case LOSSY_DCT:\n                    default:\n                        throw \"EXRLoader.parse: unsupported channel compression\";\n                }\n            }\n            return new DataView(outBuffer.buffer);\n        }\n        function parseNullTerminatedString(buffer2, offset2) {\n            var uintBuffer = new Uint8Array(buffer2);\n            var endOffset = 0;\n            while(uintBuffer[offset2.value + endOffset] != 0){\n                endOffset += 1;\n            }\n            var stringValue = new TextDecoder().decode(uintBuffer.slice(offset2.value, offset2.value + endOffset));\n            offset2.value = offset2.value + endOffset + 1;\n            return stringValue;\n        }\n        function parseFixedLengthString(buffer2, offset2, size) {\n            var stringValue = new TextDecoder().decode(new Uint8Array(buffer2).slice(offset2.value, offset2.value + size));\n            offset2.value = offset2.value + size;\n            return stringValue;\n        }\n        function parseRational(dataView, offset2) {\n            var x = parseInt32(dataView, offset2);\n            var y = parseUint32(dataView, offset2);\n            return [\n                x,\n                y\n            ];\n        }\n        function parseTimecode(dataView, offset2) {\n            var x = parseUint32(dataView, offset2);\n            var y = parseUint32(dataView, offset2);\n            return [\n                x,\n                y\n            ];\n        }\n        function parseInt32(dataView, offset2) {\n            var Int32 = dataView.getInt32(offset2.value, true);\n            offset2.value = offset2.value + INT32_SIZE;\n            return Int32;\n        }\n        function parseUint32(dataView, offset2) {\n            var Uint32 = dataView.getUint32(offset2.value, true);\n            offset2.value = offset2.value + INT32_SIZE;\n            return Uint32;\n        }\n        function parseUint8Array(uInt8Array2, offset2) {\n            var Uint8 = uInt8Array2[offset2.value];\n            offset2.value = offset2.value + INT8_SIZE;\n            return Uint8;\n        }\n        function parseUint8(dataView, offset2) {\n            var Uint8 = dataView.getUint8(offset2.value);\n            offset2.value = offset2.value + INT8_SIZE;\n            return Uint8;\n        }\n        const parseInt64 = function(dataView, offset2) {\n            let int;\n            if (\"getBigInt64\" in DataView.prototype) {\n                int = Number(dataView.getBigInt64(offset2.value, true));\n            } else {\n                int = dataView.getUint32(offset2.value + 4, true) + Number(dataView.getUint32(offset2.value, true) << 32);\n            }\n            offset2.value += ULONG_SIZE;\n            return int;\n        };\n        function parseFloat32(dataView, offset2) {\n            var float = dataView.getFloat32(offset2.value, true);\n            offset2.value += FLOAT32_SIZE;\n            return float;\n        }\n        function decodeFloat32(dataView, offset2) {\n            return three__WEBPACK_IMPORTED_MODULE_1__.DataUtils.toHalfFloat(parseFloat32(dataView, offset2));\n        }\n        function decodeFloat16(binary) {\n            var exponent = (binary & 31744) >> 10, fraction = binary & 1023;\n            return (binary >> 15 ? -1 : 1) * (exponent ? exponent === 31 ? fraction ? NaN : Infinity : Math.pow(2, exponent - 15) * (1 + fraction / 1024) : 6103515625e-14 * (fraction / 1024));\n        }\n        function parseUint16(dataView, offset2) {\n            var Uint16 = dataView.getUint16(offset2.value, true);\n            offset2.value += INT16_SIZE;\n            return Uint16;\n        }\n        function parseFloat16(buffer2, offset2) {\n            return decodeFloat16(parseUint16(buffer2, offset2));\n        }\n        function parseChlist(dataView, buffer2, offset2, size) {\n            var startOffset = offset2.value;\n            var channels = [];\n            while(offset2.value < startOffset + size - 1){\n                var name = parseNullTerminatedString(buffer2, offset2);\n                var pixelType = parseInt32(dataView, offset2);\n                var pLinear = parseUint8(dataView, offset2);\n                offset2.value += 3;\n                var xSampling = parseInt32(dataView, offset2);\n                var ySampling = parseInt32(dataView, offset2);\n                channels.push({\n                    name,\n                    pixelType,\n                    pLinear,\n                    xSampling,\n                    ySampling\n                });\n            }\n            offset2.value += 1;\n            return channels;\n        }\n        function parseChromaticities(dataView, offset2) {\n            var redX = parseFloat32(dataView, offset2);\n            var redY = parseFloat32(dataView, offset2);\n            var greenX = parseFloat32(dataView, offset2);\n            var greenY = parseFloat32(dataView, offset2);\n            var blueX = parseFloat32(dataView, offset2);\n            var blueY = parseFloat32(dataView, offset2);\n            var whiteX = parseFloat32(dataView, offset2);\n            var whiteY = parseFloat32(dataView, offset2);\n            return {\n                redX,\n                redY,\n                greenX,\n                greenY,\n                blueX,\n                blueY,\n                whiteX,\n                whiteY\n            };\n        }\n        function parseCompression(dataView, offset2) {\n            var compressionCodes = [\n                \"NO_COMPRESSION\",\n                \"RLE_COMPRESSION\",\n                \"ZIPS_COMPRESSION\",\n                \"ZIP_COMPRESSION\",\n                \"PIZ_COMPRESSION\",\n                \"PXR24_COMPRESSION\",\n                \"B44_COMPRESSION\",\n                \"B44A_COMPRESSION\",\n                \"DWAA_COMPRESSION\",\n                \"DWAB_COMPRESSION\"\n            ];\n            var compression = parseUint8(dataView, offset2);\n            return compressionCodes[compression];\n        }\n        function parseBox2i(dataView, offset2) {\n            var xMin = parseUint32(dataView, offset2);\n            var yMin = parseUint32(dataView, offset2);\n            var xMax = parseUint32(dataView, offset2);\n            var yMax = parseUint32(dataView, offset2);\n            return {\n                xMin,\n                yMin,\n                xMax,\n                yMax\n            };\n        }\n        function parseLineOrder(dataView, offset2) {\n            var lineOrders = [\n                \"INCREASING_Y\"\n            ];\n            var lineOrder = parseUint8(dataView, offset2);\n            return lineOrders[lineOrder];\n        }\n        function parseV2f(dataView, offset2) {\n            var x = parseFloat32(dataView, offset2);\n            var y = parseFloat32(dataView, offset2);\n            return [\n                x,\n                y\n            ];\n        }\n        function parseV3f(dataView, offset2) {\n            var x = parseFloat32(dataView, offset2);\n            var y = parseFloat32(dataView, offset2);\n            var z = parseFloat32(dataView, offset2);\n            return [\n                x,\n                y,\n                z\n            ];\n        }\n        function parseValue(dataView, buffer2, offset2, type, size) {\n            if (type === \"string\" || type === \"stringvector\" || type === \"iccProfile\") {\n                return parseFixedLengthString(buffer2, offset2, size);\n            } else if (type === \"chlist\") {\n                return parseChlist(dataView, buffer2, offset2, size);\n            } else if (type === \"chromaticities\") {\n                return parseChromaticities(dataView, offset2);\n            } else if (type === \"compression\") {\n                return parseCompression(dataView, offset2);\n            } else if (type === \"box2i\") {\n                return parseBox2i(dataView, offset2);\n            } else if (type === \"lineOrder\") {\n                return parseLineOrder(dataView, offset2);\n            } else if (type === \"float\") {\n                return parseFloat32(dataView, offset2);\n            } else if (type === \"v2f\") {\n                return parseV2f(dataView, offset2);\n            } else if (type === \"v3f\") {\n                return parseV3f(dataView, offset2);\n            } else if (type === \"int\") {\n                return parseInt32(dataView, offset2);\n            } else if (type === \"rational\") {\n                return parseRational(dataView, offset2);\n            } else if (type === \"timecode\") {\n                return parseTimecode(dataView, offset2);\n            } else if (type === \"preview\") {\n                offset2.value += size;\n                return \"skipped\";\n            } else {\n                offset2.value += size;\n                return void 0;\n            }\n        }\n        function parseHeader(dataView, buffer2, offset2) {\n            const EXRHeader2 = {};\n            if (dataView.getUint32(0, true) != 20000630) {\n                throw \"THREE.EXRLoader: provided file doesn't appear to be in OpenEXR format.\";\n            }\n            EXRHeader2.version = dataView.getUint8(4);\n            const spec = dataView.getUint8(5);\n            EXRHeader2.spec = {\n                singleTile: !!(spec & 2),\n                longName: !!(spec & 4),\n                deepFormat: !!(spec & 8),\n                multiPart: !!(spec & 16)\n            };\n            offset2.value = 8;\n            var keepReading = true;\n            while(keepReading){\n                var attributeName = parseNullTerminatedString(buffer2, offset2);\n                if (attributeName == 0) {\n                    keepReading = false;\n                } else {\n                    var attributeType = parseNullTerminatedString(buffer2, offset2);\n                    var attributeSize = parseUint32(dataView, offset2);\n                    var attributeValue = parseValue(dataView, buffer2, offset2, attributeType, attributeSize);\n                    if (attributeValue === void 0) {\n                        console.warn(`EXRLoader.parse: skipped unknown header attribute type '${attributeType}'.`);\n                    } else {\n                        EXRHeader2[attributeName] = attributeValue;\n                    }\n                }\n            }\n            if ((spec & ~4) != 0) {\n                console.error(\"EXRHeader:\", EXRHeader2);\n                throw \"THREE.EXRLoader: provided file is currently unsupported.\";\n            }\n            return EXRHeader2;\n        }\n        function setupDecoder(EXRHeader2, dataView, uInt8Array2, offset2, outputType) {\n            const EXRDecoder2 = {\n                size: 0,\n                viewer: dataView,\n                array: uInt8Array2,\n                offset: offset2,\n                width: EXRHeader2.dataWindow.xMax - EXRHeader2.dataWindow.xMin + 1,\n                height: EXRHeader2.dataWindow.yMax - EXRHeader2.dataWindow.yMin + 1,\n                channels: EXRHeader2.channels.length,\n                bytesPerLine: null,\n                lines: null,\n                inputSize: null,\n                type: EXRHeader2.channels[0].pixelType,\n                uncompress: null,\n                getter: null,\n                format: null,\n                [hasColorSpace ? \"colorSpace\" : \"encoding\"]: null\n            };\n            switch(EXRHeader2.compression){\n                case \"NO_COMPRESSION\":\n                    EXRDecoder2.lines = 1;\n                    EXRDecoder2.uncompress = uncompressRAW;\n                    break;\n                case \"RLE_COMPRESSION\":\n                    EXRDecoder2.lines = 1;\n                    EXRDecoder2.uncompress = uncompressRLE;\n                    break;\n                case \"ZIPS_COMPRESSION\":\n                    EXRDecoder2.lines = 1;\n                    EXRDecoder2.uncompress = uncompressZIP;\n                    break;\n                case \"ZIP_COMPRESSION\":\n                    EXRDecoder2.lines = 16;\n                    EXRDecoder2.uncompress = uncompressZIP;\n                    break;\n                case \"PIZ_COMPRESSION\":\n                    EXRDecoder2.lines = 32;\n                    EXRDecoder2.uncompress = uncompressPIZ;\n                    break;\n                case \"PXR24_COMPRESSION\":\n                    EXRDecoder2.lines = 16;\n                    EXRDecoder2.uncompress = uncompressPXR;\n                    break;\n                case \"DWAA_COMPRESSION\":\n                    EXRDecoder2.lines = 32;\n                    EXRDecoder2.uncompress = uncompressDWA;\n                    break;\n                case \"DWAB_COMPRESSION\":\n                    EXRDecoder2.lines = 256;\n                    EXRDecoder2.uncompress = uncompressDWA;\n                    break;\n                default:\n                    throw \"EXRLoader.parse: \" + EXRHeader2.compression + \" is unsupported\";\n            }\n            EXRDecoder2.scanlineBlockSize = EXRDecoder2.lines;\n            if (EXRDecoder2.type == 1) {\n                switch(outputType){\n                    case three__WEBPACK_IMPORTED_MODULE_1__.FloatType:\n                        EXRDecoder2.getter = parseFloat16;\n                        EXRDecoder2.inputSize = INT16_SIZE;\n                        break;\n                    case three__WEBPACK_IMPORTED_MODULE_1__.HalfFloatType:\n                        EXRDecoder2.getter = parseUint16;\n                        EXRDecoder2.inputSize = INT16_SIZE;\n                        break;\n                }\n            } else if (EXRDecoder2.type == 2) {\n                switch(outputType){\n                    case three__WEBPACK_IMPORTED_MODULE_1__.FloatType:\n                        EXRDecoder2.getter = parseFloat32;\n                        EXRDecoder2.inputSize = FLOAT32_SIZE;\n                        break;\n                    case three__WEBPACK_IMPORTED_MODULE_1__.HalfFloatType:\n                        EXRDecoder2.getter = decodeFloat32;\n                        EXRDecoder2.inputSize = FLOAT32_SIZE;\n                }\n            } else {\n                throw \"EXRLoader.parse: unsupported pixelType \" + EXRDecoder2.type + \" for \" + EXRHeader2.compression + \".\";\n            }\n            EXRDecoder2.blockCount = (EXRHeader2.dataWindow.yMax + 1) / EXRDecoder2.scanlineBlockSize;\n            for(var i = 0; i < EXRDecoder2.blockCount; i++)parseInt64(dataView, offset2);\n            EXRDecoder2.outputChannels = EXRDecoder2.channels == 3 ? 4 : EXRDecoder2.channels;\n            const size = EXRDecoder2.width * EXRDecoder2.height * EXRDecoder2.outputChannels;\n            switch(outputType){\n                case three__WEBPACK_IMPORTED_MODULE_1__.FloatType:\n                    EXRDecoder2.byteArray = new Float32Array(size);\n                    if (EXRDecoder2.channels < EXRDecoder2.outputChannels) EXRDecoder2.byteArray.fill(1, 0, size);\n                    break;\n                case three__WEBPACK_IMPORTED_MODULE_1__.HalfFloatType:\n                    EXRDecoder2.byteArray = new Uint16Array(size);\n                    if (EXRDecoder2.channels < EXRDecoder2.outputChannels) EXRDecoder2.byteArray.fill(15360, 0, size);\n                    break;\n                default:\n                    console.error(\"THREE.EXRLoader: unsupported type: \", outputType);\n                    break;\n            }\n            EXRDecoder2.bytesPerLine = EXRDecoder2.width * EXRDecoder2.inputSize * EXRDecoder2.channels;\n            if (EXRDecoder2.outputChannels == 4) EXRDecoder2.format = three__WEBPACK_IMPORTED_MODULE_1__.RGBAFormat;\n            else EXRDecoder2.format = three__WEBPACK_IMPORTED_MODULE_1__.RedFormat;\n            if (hasColorSpace) EXRDecoder2.colorSpace = \"srgb-linear\";\n            else EXRDecoder2.encoding = 3e3;\n            return EXRDecoder2;\n        }\n        const bufferDataView = new DataView(buffer);\n        const uInt8Array = new Uint8Array(buffer);\n        const offset = {\n            value: 0\n        };\n        const EXRHeader = parseHeader(bufferDataView, buffer, offset);\n        const EXRDecoder = setupDecoder(EXRHeader, bufferDataView, uInt8Array, offset, this.type);\n        const tmpOffset = {\n            value: 0\n        };\n        const channelOffsets = {\n            R: 0,\n            G: 1,\n            B: 2,\n            A: 3,\n            Y: 0\n        };\n        for(let scanlineBlockIdx = 0; scanlineBlockIdx < EXRDecoder.height / EXRDecoder.scanlineBlockSize; scanlineBlockIdx++){\n            const line = parseUint32(bufferDataView, offset);\n            EXRDecoder.size = parseUint32(bufferDataView, offset);\n            EXRDecoder.lines = line + EXRDecoder.scanlineBlockSize > EXRDecoder.height ? EXRDecoder.height - line : EXRDecoder.scanlineBlockSize;\n            const isCompressed = EXRDecoder.size < EXRDecoder.lines * EXRDecoder.bytesPerLine;\n            const viewer = isCompressed ? EXRDecoder.uncompress(EXRDecoder) : uncompressRAW(EXRDecoder);\n            offset.value += EXRDecoder.size;\n            for(let line_y = 0; line_y < EXRDecoder.scanlineBlockSize; line_y++){\n                const true_y = line_y + scanlineBlockIdx * EXRDecoder.scanlineBlockSize;\n                if (true_y >= EXRDecoder.height) break;\n                for(let channelID = 0; channelID < EXRDecoder.channels; channelID++){\n                    const cOff = channelOffsets[EXRHeader.channels[channelID].name];\n                    for(let x = 0; x < EXRDecoder.width; x++){\n                        tmpOffset.value = (line_y * (EXRDecoder.channels * EXRDecoder.width) + channelID * EXRDecoder.width + x) * EXRDecoder.inputSize;\n                        const outIndex = (EXRDecoder.height - 1 - true_y) * (EXRDecoder.width * EXRDecoder.outputChannels) + x * EXRDecoder.outputChannels + cOff;\n                        EXRDecoder.byteArray[outIndex] = EXRDecoder.getter(viewer, tmpOffset);\n                    }\n                }\n            }\n        }\n        return {\n            header: EXRHeader,\n            width: EXRDecoder.width,\n            height: EXRDecoder.height,\n            data: EXRDecoder.byteArray,\n            format: EXRDecoder.format,\n            [hasColorSpace ? \"colorSpace\" : \"encoding\"]: EXRDecoder[hasColorSpace ? \"colorSpace\" : \"encoding\"],\n            type: this.type\n        };\n    }\n    setDataType(value) {\n        this.type = value;\n        return this;\n    }\n    load(url, onLoad, onProgress, onError) {\n        function onLoadCallback(texture, texData) {\n            if (hasColorSpace) texture.colorSpace = texData.colorSpace;\n            else texture.encoding = texData.encoding;\n            texture.minFilter = three__WEBPACK_IMPORTED_MODULE_1__.LinearFilter;\n            texture.magFilter = three__WEBPACK_IMPORTED_MODULE_1__.LinearFilter;\n            texture.generateMipmaps = false;\n            texture.flipY = false;\n            if (onLoad) onLoad(texture, texData);\n        }\n        return super.load(url, onLoadCallback, onProgress, onError);\n    }\n}\n //# sourceMappingURL=EXRLoader.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL2xvYWRlcnMvRVhSTG9hZGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBb0g7QUFDaEY7QUFDZ0I7QUFDcEQsTUFBTVMsZ0JBQWdCRCwyREFBT0EsSUFBSTtBQUNqQyxNQUFNRSxrQkFBa0JWLG9EQUFpQkE7SUFDdkNXLFlBQVlDLE9BQU8sQ0FBRTtRQUNuQixLQUFLLENBQUNBO1FBQ04sSUFBSSxDQUFDQyxJQUFJLEdBQUdaLGdEQUFhQTtJQUMzQjtJQUNBYSxNQUFNQyxNQUFNLEVBQUU7UUFDWixNQUFNQyxlQUFlLEtBQUs7UUFDMUIsTUFBTUMsY0FBY0QsZ0JBQWdCO1FBQ3BDLE1BQU1FLGNBQWM7UUFDcEIsTUFBTUMsY0FBYztRQUNwQixNQUFNQyxjQUFjLENBQUMsS0FBS0YsV0FBVSxJQUFLO1FBQ3pDLE1BQU1HLGNBQWMsS0FBS0Y7UUFDekIsTUFBTUcsY0FBY0QsY0FBYztRQUNsQyxNQUFNRSxRQUFRO1FBQ2QsTUFBTUMsV0FBVyxLQUFLRCxRQUFRO1FBQzlCLE1BQU1FLFdBQVcsQ0FBQyxLQUFLRixLQUFJLElBQUs7UUFDaEMsTUFBTUcscUJBQXFCO1FBQzNCLE1BQU1DLG9CQUFvQjtRQUMxQixNQUFNQyxvQkFBb0IsSUFBSUQsb0JBQW9CRDtRQUNsRCxNQUFNRyxhQUFhO1FBQ25CLE1BQU1DLGVBQWU7UUFDckIsTUFBTUMsYUFBYTtRQUNuQixNQUFNQyxhQUFhO1FBQ25CLE1BQU1DLFlBQVk7UUFDbEIsTUFBTUMsaUJBQWlCO1FBQ3ZCLE1BQU1DLFVBQVU7UUFDaEIsTUFBTUMsVUFBVTtRQUNoQixNQUFNQyxZQUFZO1FBQ2xCLE1BQU1DLE1BQU07UUFDWixNQUFNQyxVQUFVQyxLQUFLQyxHQUFHLENBQUMsV0FBVztRQUNwQyxTQUFTQyxxQkFBcUJDLE1BQU0sRUFBRUMsR0FBRztZQUN2QyxJQUFJQyxJQUFJO1lBQ1IsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUk5QixjQUFjLEVBQUU4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R0FBR0gsY0FBY1gsR0FBRyxDQUFDLEdBQUc7WUFDL0JjLEdBQUcsQ0FBQyxHQUFHLEdBQUdILGNBQWNYLEdBQUcsQ0FBQyxHQUFHO1lBQy9CYyxHQUFHLENBQUMsR0FBRyxHQUFHSCxjQUFjWCxHQUFHLENBQUMsRUFBRTtZQUM5QmMsR0FBRyxDQUFDLEdBQUcsR0FBR0gsY0FBY1gsR0FBRyxDQUFDLEVBQUU7WUFDOUJjLEdBQUcsQ0FBQyxHQUFHLEdBQUdILGNBQWNYLEdBQUcsQ0FBQyxHQUFHO1lBQy9CYyxHQUFHLENBQUMsR0FBRyxHQUFHSCxjQUFjWCxHQUFHLENBQUMsR0FBRztZQUMvQmMsR0FBRyxDQUFDLEdBQUcsR0FBR0gsY0FBY1gsR0FBRyxDQUFDLEdBQUc7WUFDL0JjLEdBQUcsQ0FBQyxHQUFHLEdBQUdILGNBQWNYLEdBQUcsQ0FBQyxHQUFHO1lBQy9CYyxHQUFHLENBQUMsR0FBRyxHQUFHSCxjQUFjWCxHQUFHLENBQUMsR0FBRztZQUMvQmMsR0FBRyxDQUFDLEdBQUcsR0FBR0gsY0FBY1gsR0FBRyxDQUFDLEdBQUc7WUFDL0JjLEdBQUcsQ0FBQyxHQUFHLEdBQUdILGNBQWNYLEdBQUcsQ0FBQyxFQUFFO1lBQzlCYyxHQUFHLENBQUMsR0FBRyxHQUFHSCxjQUFjWCxHQUFHLENBQUMsR0FBRztZQUMvQmMsR0FBRyxDQUFDLEdBQUcsR0FBR0gsY0FBY1gsR0FBRyxDQUFDLEdBQUc7WUFDL0JjLEdBQUcsQ0FBQyxHQUFHLEdBQUdILGNBQWNYLEdBQUcsQ0FBQyxHQUFHO1lBQy9CYyxHQUFHLENBQUMsR0FBRyxHQUFHSCxjQUFjWCxHQUFHLENBQUMsR0FBRztZQUMvQmMsR0FBRyxDQUFDLEdBQUcsR0FBR0gsY0FBY1gsR0FBRyxDQUFDLEdBQUc7WUFDL0JjLEdBQUcsQ0FBQyxHQUFHLEdBQUdILGNBQWNYLEdBQUcsQ0FBQyxHQUFHO1lBQy9CYyxHQUFHLENBQUMsR0FBRyxHQUFHSCxjQUFjWCxHQUFHLENBQUMsR0FBRztZQUMvQmMsR0FBRyxDQUFDLEdBQUcsR0FBR0gsY0FBY1gsR0FBRyxDQUFDLEdBQUc7WUFDL0JjLEdBQUcsQ0FBQyxHQUFHLEdBQUdILGNBQWNYLEdBQUcsQ0FBQyxHQUFHO1lBQy9CYyxHQUFHLENBQUMsR0FBRyxHQUFHSCxjQUFjWCxHQUFHLENBQUMsR0FBRztZQUMvQmMsR0FBRyxDQUFDLEdBQUcsR0FBR0gsY0FBY1gsR0FBRyxDQUFDLEdBQUc7WUFDL0JjLEdBQUcsQ0FBQyxHQUFHLEdBQUdILGNBQWNYLEdBQUcsQ0FBQyxHQUFHO1lBQy9CYyxHQUFHLENBQUMsR0FBRyxHQUFHSCxjQUFjWCxHQUFHLENBQUMsR0FBRztZQUMvQmMsR0FBRyxDQUFDLEdBQUcsR0FBR0gsY0FBY1gsR0FBRyxDQUFDLEdBQUc7WUFDL0JjLEdBQUcsQ0FBQyxHQUFHLEdBQUdILGNBQWNYLEdBQUcsQ0FBQyxHQUFHO1lBQy9CYyxHQUFHLENBQUMsR0FBRyxHQUFHSCxjQUFjWCxHQUFHLENBQUMsR0FBRztZQUMvQmMsR0FBRyxDQUFDLEdBQUcsR0FBR0gsY0FBY1gsR0FBRyxDQUFDLEdBQUc7WUFDL0JjLEdBQUcsQ0FBQyxHQUFHLEdBQUdILGNBQWNYLEdBQUcsQ0FBQyxHQUFHO1lBQy9CYyxHQUFHLENBQUMsR0FBRyxHQUFHSCxjQUFjWCxHQUFHLENBQUMsR0FBRztZQUMvQmMsR0FBRyxDQUFDLEdBQUcsR0FBR0gsY0FBY1gsR0FBRyxDQUFDLEdBQUc7WUFDL0JjLEdBQUcsQ0FBQyxHQUFHLEdBQUdILGNBQWNYLEdBQUcsQ0FBQyxHQUFHO1lBQy9CYyxHQUFHLENBQUMsR0FBRyxHQUFHSCxjQUFjWCxHQUFHLENBQUMsR0FBRztZQUMvQmMsR0FBRyxDQUFDLEdBQUcsR0FBR0gsY0FBY1gsR0FBRyxDQUFDLEdBQUc7WUFDL0JjLEdBQUcsQ0FBQyxHQUFHLEdBQUdILGNBQWNYLEdBQUcsQ0FBQyxHQUFHO1lBQy9CYyxHQUFHLENBQUMsR0FBRyxHQUFHSCxjQUFjWCxHQUFHLENBQUMsR0FBRztZQUMvQmMsR0FBRyxDQUFDLEdBQUcsR0FBR0gsY0FBY1gsR0FBRyxDQUFDLEdBQUc7WUFDL0JjLEdB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UUFBUUcsU0FBUyxHQUFHcGEsK0NBQVlBO1lBQ2hDaWEsUUFBUUksZUFBZSxHQUFHO1lBQzFCSixRQUFRSyxLQUFLLEdBQUc7WUFDaEIsSUFBSVQsUUFDRkEsT0FBT0ksU0FBU0M7UUFDcEI7UUFDQSxPQUFPLEtBQUssQ0FBQ1AsS0FBS0MsS0FBS0ksZ0JBQWdCRixZQUFZQztJQUNyRDtBQUNGO0FBR0UsQ0FDRixxQ0FBcUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ibHVlcHJpbnQtdG8tM2QtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL2xvYWRlcnMvRVhSTG9hZGVyLmpzPzdlNDciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRGF0YVRleHR1cmVMb2FkZXIsIEhhbGZGbG9hdFR5cGUsIEZsb2F0VHlwZSwgUkdCQUZvcm1hdCwgUmVkRm9ybWF0LCBMaW5lYXJGaWx0ZXIsIERhdGFVdGlscyB9IGZyb20gXCJ0aHJlZVwiO1xuaW1wb3J0IHsgdW56bGliU3luYyB9IGZyb20gXCJmZmxhdGVcIjtcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tIFwiLi4vX3BvbHlmaWxsL2NvbnN0YW50cy5qc1wiO1xuY29uc3QgaGFzQ29sb3JTcGFjZSA9IHZlcnNpb24gPj0gMTUyO1xuY2xhc3MgRVhSTG9hZGVyIGV4dGVuZHMgRGF0YVRleHR1cmVMb2FkZXIge1xuICBjb25zdHJ1Y3RvcihtYW5hZ2VyKSB7XG4gICAgc3VwZXIobWFuYWdlcik7XG4gICAgdGhpcy50eXBlID0gSGFsZkZsb2F0VHlwZTtcbiAgfVxuICBwYXJzZShidWZmZXIpIHtcbiAgICBjb25zdCBVU0hPUlRfUkFOR0UgPSAxIDw8IDE2O1xuICAgIGNvbnN0IEJJVE1BUF9TSVpFID0gVVNIT1JUX1JBTkdFID4+IDM7XG4gICAgY29uc3QgSFVGX0VOQ0JJVFMgPSAxNjtcbiAgICBjb25zdCBIVUZfREVDQklUUyA9IDE0O1xuICAgIGNvbnN0IEhVRl9FTkNTSVpFID0gKDEgPDwgSFVGX0VOQ0JJVFMpICsgMTtcbiAgICBjb25zdCBIVUZfREVDU0laRSA9IDEgPDwgSFVGX0RFQ0JJVFM7XG4gICAgY29uc3QgSFVGX0RFQ01BU0sgPSBIVUZfREVDU0laRSAtIDE7XG4gICAgY29uc3QgTkJJVFMgPSAxNjtcbiAgICBjb25zdCBBX09GRlNFVCA9IDEgPDwgTkJJVFMgLSAxO1xuICAgIGNvbnN0IE1PRF9NQVNLID0gKDEgPDwgTkJJVFMpIC0gMTtcbiAgICBjb25zdCBTSE9SVF9aRVJPQ09ERV9SVU4gPSA1OTtcbiAgICBjb25zdCBMT05HX1pFUk9DT0RFX1JVTiA9IDYzO1xuICAgIGNvbnN0IFNIT1JURVNUX0xPTkdfUlVOID0gMiArIExPTkdfWkVST0NPREVfUlVOIC0gU0hPUlRfWkVST0NPREVfUlVOO1xuICAgIGNvbnN0IFVMT05HX1NJWkUgPSA4O1xuICAgIGNvbnN0IEZMT0FUMzJfU0laRSA9IDQ7XG4gICAgY29uc3QgSU5UMzJfU0laRSA9IDQ7XG4gICAgY29uc3QgSU5UMTZfU0laRSA9IDI7XG4gICAgY29uc3QgSU5UOF9TSVpFID0gMTtcbiAgICBjb25zdCBTVEFUSUNfSFVGRk1BTiA9IDA7XG4gICAgY29uc3QgREVGTEFURSA9IDE7XG4gICAgY29uc3QgVU5LTk9XTiA9IDA7XG4gICAgY29uc3QgTE9TU1lfRENUID0gMTtcbiAgICBjb25zdCBSTEUgPSAyO1xuICAgIGNvbnN0IGxvZ0Jhc2UgPSBNYXRoLnBvdygyLjcxODI4MTgsIDIuMik7XG4gICAgZnVuY3Rpb24gcmV2ZXJzZUx1dEZyb21CaXRtYXAoYml0bWFwLCBsdXQpIHtcbiAgICAgIHZhciBrID0gMDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgVVNIT1JUX1JBTkdFOyArK2kpIHtcbiAgICAgICAgaWYgKGkgPT0gMCB8fCBiaXRtYXBbaSA+PiAzXSAmIDEgPDwgKGkgJiA3KSkge1xuICAgICAgICAgIGx1dFtrKytdID0gaTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIG4gPSBrIC0gMTtcbiAgICAgIHdoaWxlIChrIDwgVVNIT1JUX1JBTkdFKVxuICAgICAgICBsdXRbaysrXSA9IDA7XG4gICAgICByZXR1cm4gbjtcbiAgICB9XG4gICAgZnVuY3Rpb24gaHVmQ2xlYXJEZWNUYWJsZShoZGVjKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IEhVRl9ERUNTSVpFOyBpKyspIHtcbiAgICAgICAgaGRlY1tpXSA9IHt9O1xuICAgICAgICBoZGVjW2ldLmxlbiA9IDA7XG4gICAgICAgIGhkZWNbaV0ubGl0ID0gMDtcbiAgICAgICAgaGRlY1tpXS5wID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZ2V0Qml0c1JldHVybiA9IHsgbDogMCwgYzogMCwgbGM6IDAgfTtcbiAgICBmdW5jdGlvbiBnZXRCaXRzKG5CaXRzLCBjLCBsYywgdUludDhBcnJheTIsIGluT2Zmc2V0KSB7XG4gICAgICB3aGlsZSAobGMgPCBuQml0cykge1xuICAgICAgICBjID0gYyA8PCA4IHwgcGFyc2VVaW50OEFycmF5KHVJbnQ4QXJyYXkyLCBpbk9mZnNldCk7XG4gICAgICAgIGxjICs9IDg7XG4gICAgICB9XG4gICAgICBsYyAtPSBuQml0cztcbiAgICAgIGdldEJpdHNSZXR1cm4ubCA9IGMgPj4gbGMgJiAoMSA8PCBuQml0cykgLSAxO1xuICAgICAgZ2V0Qml0c1JldHVybi5jID0gYztcbiAgICAgIGdldEJpdHNSZXR1cm4ubGMgPSBsYztcbiAgICB9XG4gICAgY29uc3QgaHVmVGFibGVCdWZmZXIgPSBuZXcgQXJyYXkoNTkpO1xuICAgIGZ1bmN0aW9uIGh1ZkNhbm9uaWNhbENvZGVUYWJsZShoY29kZSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gNTg7ICsraSlcbiAgICAgICAgaHVmVGFibGVCdWZmZXJbaV0gPSAwO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBIVUZfRU5DU0laRTsgKytpKVxuICAgICAgICBodWZUYWJsZUJ1ZmZlcltoY29kZVtpXV0gKz0gMTtcbiAgICAgIHZhciBjID0gMDtcbiAgICAgIGZvciAodmFyIGkgPSA1ODsgaSA+IDA7IC0taSkge1xuICAgICAgICB2YXIgbmMgPSBjICsgaHVmVGFibGVCdWZmZXJbaV0gPj4gMTtcbiAgICAgICAgaHVmVGFibGVCdWZmZXJbaV0gPSBjO1xuICAgICAgICBjID0gbmM7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IEhVRl9FTkNTSVpFOyArK2kpIHtcbiAgICAgICAgdmFyIGwgPSBoY29kZVtpXTtcbiAgICAgICAgaWYgKGwgPiAwKVxuICAgICAgICAgIGhjb2RlW2ldID0gbCB8IGh1ZlRhYmxlQnVmZmVyW2xdKysgPDwgNjtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gaHVmVW5wYWNrRW5jVGFibGUodUludDhBcnJheTIsIGluRGF0YVZpZXcsIGluT2Zmc2V0LCBuaSwgaW0sIGlNLCBoY29kZSkge1xuICAgICAgdmFyIHAgPSBpbk9mZnNldDtcbiAgICAgIHZhciBjID0gMDtcbiAgICAgIHZhciBsYyA9IDA7XG4gICAgICBmb3IgKDsgaW0gPD0gaU07IGltKyspIHtcbiAgICAgICAgaWYgKHAudmFsdWUgLSBpbk9mZnNldC52YWx1ZSA+IG5pKVxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgZ2V0Qml0cyg2LCBjLCBsYywgdUludDhBcnJheTIsIHApO1xuICAgICAgICB2YXIgbCA9IGdldEJpdHNSZXR1cm4ubDtcbiAgICAgICAgYyA9IGdldEJpdHNSZXR1cm4uYztcbiAgICAgICAgbGMgPSBnZXRCaXRzUmV0dXJuLmxjO1xuICAgICAgICBoY29kZVtpbV0gPSBsO1xuICAgICAgICBpZiAobCA9PSBMT05HX1pFUk9DT0RFX1JVTikge1xuICAgICAgICAgIGlmIChwLnZhbHVlIC0gaW5PZmZzZXQudmFsdWUgPiBuaSkge1xuICAgICAgICAgICAgdGhyb3cgXCJTb21ldGhpbmcgd3Jvbmcgd2l0aCBodWZVbnBhY2tFbmNUYWJsZVwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBnZXRCaXRzKDgsIGMsIGxjLCB1SW50OEFycmF5MiwgcCk7XG4gICAgICAgICAgdmFyIHplcnVuID0gZ2V0Qml0c1JldHVybi5sICsgU0hPUlRFU1RfTE9OR19SVU47XG4gICAgICAgICAgYyA9IGdldEJpdHNSZXR1cm4uYztcbiAgICAgICAgICBsYyA9IGdldEJpdHNSZXR1cm4ubGM7XG4gICAgICAgICAgaWYgKGltICsgemVydW4gPiBpTSArIDEpIHtcbiAgICAgICAgICAgIHRocm93IFwiU29tZXRoaW5nIHdyb25nIHdpdGggaHVmVW5wYWNrRW5jVGFibGVcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgd2hpbGUgKHplcnVuLS0pXG4gICAgICAgICAgICBoY29kZVtpbSsrXSA9IDA7XG4gICAgICAgICAgaW0tLTtcbiAgICAgICAgfSBlbHNlIGlmIChsID49IFNIT1JUX1pFUk9DT0RFX1JVTikge1xuICAgICAgICAgIHZhciB6ZXJ1biA9IGwgLSBTSE9SVF9aRVJPQ09ERV9SVU4gKyAyO1xuICAgICAgICAgIGlmIChpbSArIHplcnVuID4gaU0gKyAxKSB7XG4gICAgICAgICAgICB0aHJvdyBcIlNvbWV0aGluZyB3cm9uZyB3aXRoIGh1ZlVucGFja0VuY1RhYmxlXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHdoaWxlICh6ZXJ1bi0tKVxuICAgICAgICAgICAgaGNvZGVbaW0rK10gPSAwO1xuICAgICAgICAgIGltLS07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGh1ZkNhbm9uaWNhbENvZGVUYWJsZShoY29kZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGh1Zkxlbmd0aChjb2RlKSB7XG4gICAgICByZXR1cm4gY29kZSAmIDYzO1xuICAgIH1cbiAgICBmdW5jdGlvbiBodWZDb2RlKGNvZGUpIHtcbiAgICAgIHJldHVybiBjb2RlID4+IDY7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGh1ZkJ1aWxkRGVjVGFibGUoaGNvZGUsIGltLCBpTSwgaGRlY29kKSB7XG4gICAgICBmb3IgKDsgaW0gPD0gaU07IGltKyspIHtcbiAgICAgICAgdmFyIGMgPSBodWZDb2RlKGhjb2RlW2ltXSk7XG4gICAgICAgIHZhciBsID0gaHVmTGVuZ3RoKGhjb2RlW2ltXSk7XG4gICAgICAgIGlmIChjID4+IGwpIHtcbiAgICAgICAgICB0aHJvdyBcIkludmFsaWQgdGFibGUgZW50cnlcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobCA+IEhVRl9ERUNCSVRTKSB7XG4gICAgICAgICAgdmFyIHBsID0gaGRlY29kW2MgPj4gbCAtIEhVRl9ERUNCSVRTXTtcbiAgICAgICAgICBpZiAocGwubGVuKSB7XG4gICAgICAgICAgICB0aHJvdyBcIkludmFsaWQgdGFibGUgZW50cnlcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcGwubGl0Kys7XG4gICAgICAgICAgaWYgKHBsLnApIHtcbiAgICAgICAgICAgIHZhciBwID0gcGwucDtcbiAgICAgICAgICAgIHBsLnAgPSBuZXcgQXJyYXkocGwubGl0KTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGwubGl0IC0gMTsgKytpKSB7XG4gICAgICAgICAgICAgIHBsLnBbaV0gPSBwW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwbC5wID0gbmV3IEFycmF5KDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwbC5wW3BsLmxpdCAtIDFdID0gaW07XG4gICAgICAgIH0gZWxzZSBpZiAobCkge1xuICAgICAgICAgIHZhciBwbE9mZnNldCA9IDA7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDEgPDwgSFVGX0RFQ0JJVFMgLSBsOyBpID4gMDsgaS0tKSB7XG4gICAgICAgICAgICB2YXIgcGwgPSBoZGVjb2RbKGMgPDwgSFVGX0RFQ0JJVFMgLSBsKSArIHBsT2Zmc2V0XTtcbiAgICAgICAgICAgIGlmIChwbC5sZW4gfHwgcGwucCkge1xuICAgICAgICAgICAgICB0aHJvdyBcIkludmFsaWQgdGFibGUgZW50cnlcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBsLmxlbiA9IGw7XG4gICAgICAgICAgICBwbC5saXQgPSBpbTtcbiAgICAgICAgICAgIHBsT2Zmc2V0Kys7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3QgZ2V0Q2hhclJldHVybiA9IHsgYzogMCwgbGM6IDAgfTtcbiAgICBmdW5jdGlvbiBnZXRDaGFyKGMsIGxjLCB1SW50OEFycmF5MiwgaW5PZmZzZXQpIHtcbiAgICAgIGMgPSBjIDw8IDggfCBwYXJzZVVpbnQ4QXJyYXkodUludDhBcnJheTIsIGluT2Zmc2V0KTtcbiAgICAgIGxjICs9IDg7XG4gICAgICBnZXRDaGFyUmV0dXJuLmMgPSBjO1xuICAgICAgZ2V0Q2hhclJldHVybi5sYyA9IGxjO1xuICAgIH1cbiAgICBjb25zdCBnZXRDb2RlUmV0dXJuID0geyBjOiAwLCBsYzogMCB9O1xuICAgIGZ1bmN0aW9uIGdldENvZGUocG8sIHJsYywgYywgbGMsIHVJbnQ4QXJyYXkyLCBpbkRhdGFWaWV3LCBpbk9mZnNldCwgb3V0QnVmZmVyLCBvdXRCdWZmZXJPZmZzZXQsIG91dEJ1ZmZlckVuZE9mZnNldCkge1xuICAgICAgaWYgKHBvID09IHJsYykge1xuICAgICAgICBpZiAobGMgPCA4KSB7XG4gICAgICAgICAgZ2V0Q2hhcihjLCBsYywgdUludDhBcnJheTIsIGluT2Zmc2V0KTtcbiAgICAgICAgICBjID0gZ2V0Q2hhclJldHVybi5jO1xuICAgICAgICAgIGxjID0gZ2V0Q2hhclJldHVybi5sYztcbiAgICAgICAgfVxuICAgICAgICBsYyAtPSA4O1xuICAgICAgICB2YXIgY3MgPSBjID4+IGxjO1xuICAgICAgICB2YXIgY3MgPSBuZXcgVWludDhBcnJheShbY3NdKVswXTtcbiAgICAgICAgaWYgKG91dEJ1ZmZlck9mZnNldC52YWx1ZSArIGNzID4gb3V0QnVmZmVyRW5kT2Zmc2V0KSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzID0gb3V0QnVmZmVyW291dEJ1ZmZlck9mZnNldC52YWx1ZSAtIDFdO1xuICAgICAgICB3aGlsZSAoY3MtLSA+IDApIHtcbiAgICAgICAgICBvdXRCdWZmZXJbb3V0QnVmZmVyT2Zmc2V0LnZhbHVlKytdID0gcztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChvdXRCdWZmZXJPZmZzZXQudmFsdWUgPCBvdXRCdWZmZXJFbmRPZmZzZXQpIHtcbiAgICAgICAgb3V0QnVmZmVyW291dEJ1ZmZlck9mZnNldC52YWx1ZSsrXSA9IHBvO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgZ2V0Q29kZVJldHVybi5jID0gYztcbiAgICAgIGdldENvZGVSZXR1cm4ubGMgPSBsYztcbiAgICB9XG4gICAgZnVuY3Rpb24gVUludDE2KHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgJiA2NTUzNTtcbiAgICB9XG4gICAgZnVuY3Rpb24gSW50MTYodmFsdWUpIHtcbiAgICAgIHZhciByZWYgPSBVSW50MTYodmFsdWUpO1xuICAgICAgcmV0dXJuIHJlZiA+IDMyNzY3ID8gcmVmIC0gNjU1MzYgOiByZWY7XG4gICAgfVxuICAgIGNvbnN0IHdkZWMxNFJldHVybiA9IHsgYTogMCwgYjogMCB9O1xuICAgIGZ1bmN0aW9uIHdkZWMxNChsLCBoKSB7XG4gICAgICB2YXIgbHMgPSBJbnQxNihsKTtcbiAgICAgIHZhciBocyA9IEludDE2KGgpO1xuICAgICAgdmFyIGhpID0gaHM7XG4gICAgICB2YXIgYWkgPSBscyArIChoaSAmIDEpICsgKGhpID4+IDEpO1xuICAgICAgdmFyIGFzID0gYWk7XG4gICAgICB2YXIgYnMgPSBhaSAtIGhpO1xuICAgICAgd2RlYzE0UmV0dXJuLmEgPSBhcztcbiAgICAgIHdkZWMxNFJldHVybi5iID0gYnM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHdkZWMxNihsLCBoKSB7XG4gICAgICB2YXIgbSA9IFVJbnQxNihsKTtcbiAgICAgIHZhciBkID0gVUludDE2KGgpO1xuICAgICAgdmFyIGJiID0gbSAtIChkID4+IDEpICYgTU9EX01BU0s7XG4gICAgICB2YXIgYWEgPSBkICsgYmIgLSBBX09GRlNFVCAmIE1PRF9NQVNLO1xuICAgICAgd2RlYzE0UmV0dXJuLmEgPSBhYTtcbiAgICAgIHdkZWMxNFJldHVybi5iID0gYmI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHdhdjJEZWNvZGUoYnVmZmVyMiwgaiwgbngsIG94LCBueSwgb3ksIG14KSB7XG4gICAgICB2YXIgdzE0ID0gbXggPCAxIDw8IDE0O1xuICAgICAgdmFyIG4gPSBueCA+IG55ID8gbnkgOiBueDtcbiAgICAgIHZhciBwID0gMTtcbiAgICAgIHZhciBwMjtcbiAgICAgIHdoaWxlIChwIDw9IG4pXG4gICAgICAgIHAgPDw9IDE7XG4gICAgICBwID4+PSAxO1xuICAgICAgcDIgPSBwO1xuICAgICAgcCA+Pj0gMTtcbiAgICAgIHdoaWxlIChwID49IDEpIHtcbiAgICAgICAgdmFyIHB5ID0gMDtcbiAgICAgICAgdmFyIGV5ID0gcHkgKyBveSAqIChueSAtIHAyKTtcbiAgICAgICAgdmFyIG95MSA9IG95ICogcDtcbiAgICAgICAgdmFyIG95MiA9IG95ICogcDI7XG4gICAgICAgIHZhciBveDEgPSBveCAqIHA7XG4gICAgICAgIHZhciBveDIgPSBveCAqIHAyO1xuICAgICAgICB2YXIgaTAwLCBpMDEsIGkxMCwgaTExO1xuICAgICAgICBmb3IgKDsgcHkgPD0gZXk7IHB5ICs9IG95Mikge1xuICAgICAgICAgIHZhciBweCA9IHB5O1xuICAgICAgICAgIHZhciBleCA9IHB5ICsgb3ggKiAobnggLSBwMik7XG4gICAgICAgICAgZm9yICg7IHB4IDw9IGV4OyBweCArPSBveDIpIHtcbiAgICAgICAgICAgIHZhciBwMDEgPSBweCArIG94MTtcbiAgICAgICAgICAgIHZhciBwMTAgPSBweCArIG95MTtcbiAgICAgICAgICAgIHZhciBwMTEgPSBwMTAgKyBveDE7XG4gICAgICAgICAgICBpZiAodzE0KSB7XG4gICAgICAgICAgICAgIHdkZWMxNChidWZmZXIyW3B4ICsgal0sIGJ1ZmZlcjJbcDEwICsgal0pO1xuICAgICAgICAgICAgICBpMDAgPSB3ZGVjMTRSZXR1cm4uYTtcbiAgICAgICAgICAgICAgaTEwID0gd2RlYzE0UmV0dXJuLmI7XG4gICAgICAgICAgICAgIHdkZWMxNChidWZmZXIyW3AwMSArIGpdLCBidWZmZXIyW3AxMSArIGpdKTtcbiAgICAgICAgICAgICAgaTAxID0gd2RlYzE0UmV0dXJuLmE7XG4gICAgICAgICAgICAgIGkxMSA9IHdkZWMxNFJldHVybi5iO1xuICAgICAgICAgICAgICB3ZGVjMTQoaTAwLCBpMDEpO1xuICAgICAgICAgICAgICBidWZmZXIyW3B4ICsgal0gPSB3ZGVjMTRSZXR1cm4uYTtcbiAgICAgICAgICAgICAgYnVmZmVyMltwMDEgKyBqXSA9IHdkZWMxNFJldHVybi5iO1xuICAgICAgICAgICAgICB3ZGVjMTQoaTEwLCBpMTEpO1xuICAgICAgICAgICAgICBidWZmZXIyW3AxMCArIGpdID0gd2RlYzE0UmV0dXJuLmE7XG4gICAgICAgICAgICAgIGJ1ZmZlcjJbcDExICsgal0gPSB3ZGVjMTRSZXR1cm4uYjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHdkZWMxNihidWZmZXIyW3B4ICsgal0sIGJ1ZmZlcjJbcDEwICsgal0pO1xuICAgICAgICAgICAgICBpMDAgPSB3ZGVjMTRSZXR1cm4uYTtcbiAgICAgICAgICAgICAgaTEwID0gd2RlYzE0UmV0dXJuLmI7XG4gICAgICAgICAgICAgIHdkZWMxNihidWZmZXIyW3AwMSArIGpdLCBidWZmZXIyW3AxMSArIGpdKTtcbiAgICAgICAgICAgICAgaTAxID0gd2RlYzE0UmV0dXJuLmE7XG4gICAgICAgICAgICAgIGkxMSA9IHdkZWMxNFJldHVybi5iO1xuICAgICAgICAgICAgICB3ZGVjMTYoaTAwLCBpMDEpO1xuICAgICAgICAgICAgICBidWZmZXIyW3B4ICsgal0gPSB3ZGVjMTRSZXR1cm4uYTtcbiAgICAgICAgICAgICAgYnVmZmVyMltwMDEgKyBqXSA9IHdkZWMxNFJldHVybi5iO1xuICAgICAgICAgICAgICB3ZGVjMTYoaTEwLCBpMTEpO1xuICAgICAgICAgICAgICBidWZmZXIyW3AxMCArIGpdID0gd2RlYzE0UmV0dXJuLmE7XG4gICAgICAgICAgICAgIGJ1ZmZlcjJbcDExICsgal0gPSB3ZGVjMTRSZXR1cm4uYjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG54ICYgcCkge1xuICAgICAgICAgICAgdmFyIHAxMCA9IHB4ICsgb3kxO1xuICAgICAgICAgICAgaWYgKHcxNClcbiAgICAgICAgICAgICAgd2RlYzE0KGJ1ZmZlcjJbcHggKyBqXSwgYnVmZmVyMltwMTAgKyBqXSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIHdkZWMxNihidWZmZXIyW3B4ICsgal0sIGJ1ZmZlcjJbcDEwICsgal0pO1xuICAgICAgICAgICAgaTAwID0gd2RlYzE0UmV0dXJuLmE7XG4gICAgICAgICAgICBidWZmZXIyW3AxMCArIGpdID0gd2RlYzE0UmV0dXJuLmI7XG4gICAgICAgICAgICBidWZmZXIyW3B4ICsgal0gPSBpMDA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChueSAmIHApIHtcbiAgICAgICAgICB2YXIgcHggPSBweTtcbiAgICAgICAgICB2YXIgZXggPSBweSArIG94ICogKG54IC0gcDIpO1xuICAgICAgICAgIGZvciAoOyBweCA8PSBleDsgcHggKz0gb3gyKSB7XG4gICAgICAgICAgICB2YXIgcDAxID0gcHggKyBveDE7XG4gICAgICAgICAgICBpZiAodzE0KVxuICAgICAgICAgICAgICB3ZGVjMTQoYnVmZmVyMltweCArIGpdLCBidWZmZXIyW3AwMSArIGpdKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgd2RlYzE2KGJ1ZmZlcjJbcHggKyBqXSwgYnVmZmVyMltwMDEgKyBqXSk7XG4gICAgICAgICAgICBpMDAgPSB3ZGVjMTRSZXR1cm4uYTtcbiAgICAgICAgICAgIGJ1ZmZlcjJbcDAxICsgal0gPSB3ZGVjMTRSZXR1cm4uYjtcbiAgICAgICAgICAgIGJ1ZmZlcjJbcHggKyBqXSA9IGkwMDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcDIgPSBwO1xuICAgICAgICBwID4+PSAxO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHB5O1xuICAgIH1cbiAgICBmdW5jdGlvbiBodWZEZWNvZGUoZW5jb2RpbmdUYWJsZSwgZGVjb2RpbmdUYWJsZSwgdUludDhBcnJheTIsIGluRGF0YVZpZXcsIGluT2Zmc2V0LCBuaSwgcmxjLCBubywgb3V0QnVmZmVyLCBvdXRPZmZzZXQpIHtcbiAgICAgIHZhciBjID0gMDtcbiAgICAgIHZhciBsYyA9IDA7XG4gICAgICB2YXIgb3V0QnVmZmVyRW5kT2Zmc2V0ID0gbm87XG4gICAgICB2YXIgaW5PZmZzZXRFbmQgPSBNYXRoLnRydW5jKGluT2Zmc2V0LnZhbHVlICsgKG5pICsgNykgLyA4KTtcbiAgICAgIHdoaWxlIChpbk9mZnNldC52YWx1ZSA8IGluT2Zmc2V0RW5kKSB7XG4gICAgICAgIGdldENoYXIoYywgbGMsIHVJbnQ4QXJyYXkyLCBpbk9mZnNldCk7XG4gICAgICAgIGMgPSBnZXRDaGFyUmV0dXJuLmM7XG4gICAgICAgIGxjID0gZ2V0Q2hhclJldHVybi5sYztcbiAgICAgICAgd2hpbGUgKGxjID49IEhVRl9ERUNCSVRTKSB7XG4gICAgICAgICAgdmFyIGluZGV4ID0gYyA+PiBsYyAtIEhVRl9ERUNCSVRTICYgSFVGX0RFQ01BU0s7XG4gICAgICAgICAgdmFyIHBsID0gZGVjb2RpbmdUYWJsZVtpbmRleF07XG4gICAgICAgICAgaWYgKHBsLmxlbikge1xuICAgICAgICAgICAgbGMgLT0gcGwubGVuO1xuICAgICAgICAgICAgZ2V0Q29kZShwbC5saXQsIHJsYywgYywgbGMsIHVJbnQ4QXJyYXkyLCBpbkRhdGFWaWV3LCBpbk9mZnNldCwgb3V0QnVmZmVyLCBvdXRPZmZzZXQsIG91dEJ1ZmZlckVuZE9mZnNldCk7XG4gICAgICAgICAgICBjID0gZ2V0Q29kZVJldHVybi5jO1xuICAgICAgICAgICAgbGMgPSBnZXRDb2RlUmV0dXJuLmxjO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIXBsLnApIHtcbiAgICAgICAgICAgICAgdGhyb3cgXCJodWZEZWNvZGUgaXNzdWVzXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgajtcbiAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBwbC5saXQ7IGorKykge1xuICAgICAgICAgICAgICB2YXIgbCA9IGh1Zkxlbmd0aChlbmNvZGluZ1RhYmxlW3BsLnBbal1dKTtcbiAgICAgICAgICAgICAgd2hpbGUgKGxjIDwgbCAmJiBpbk9mZnNldC52YWx1ZSA8IGluT2Zmc2V0RW5kKSB7XG4gICAgICAgICAgICAgICAgZ2V0Q2hhcihjLCBsYywgdUludDhBcnJheTIsIGluT2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBjID0gZ2V0Q2hhclJldHVybi5jO1xuICAgICAgICAgICAgICAgIGxjID0gZ2V0Q2hhclJldHVybi5sYztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAobGMgPj0gbCkge1xuICAgICAgICAgICAgICAgIGlmIChodWZDb2RlKGVuY29kaW5nVGFibGVbcGwucFtqXV0pID09IChjID4+IGxjIC0gbCAmICgxIDw8IGwpIC0gMSkpIHtcbiAgICAgICAgICAgICAgICAgIGxjIC09IGw7XG4gICAgICAgICAgICAgICAgICBnZXRDb2RlKFxuICAgICAgICAgICAgICAgICAgICBwbC5wW2pdLFxuICAgICAgICAgICAgICAgICAgICBybGMsXG4gICAgICAgICAgICAgICAgICAgIGMsXG4gICAgICAgICAgICAgICAgICAgIGxjLFxuICAgICAgICAgICAgICAgICAgICB1SW50OEFycmF5MixcbiAgICAgICAgICAgICAgICAgICAgaW5EYXRhVmlldyxcbiAgICAgICAgICAgICAgICAgICAgaW5PZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgIG91dEJ1ZmZlcixcbiAgICAgICAgICAgICAgICAgICAgb3V0T2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICBvdXRCdWZmZXJFbmRPZmZzZXRcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICBjID0gZ2V0Q29kZVJldHVybi5jO1xuICAgICAgICAgICAgICAgICAgbGMgPSBnZXRDb2RlUmV0dXJuLmxjO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaiA9PSBwbC5saXQpIHtcbiAgICAgICAgICAgICAgdGhyb3cgXCJodWZEZWNvZGUgaXNzdWVzXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgaSA9IDggLSBuaSAmIDc7XG4gICAgICBjID4+PSBpO1xuICAgICAgbGMgLT0gaTtcbiAgICAgIHdoaWxlIChsYyA+IDApIHtcbiAgICAgICAgdmFyIHBsID0gZGVjb2RpbmdUYWJsZVtjIDw8IEhVRl9ERUNCSVRTIC0gbGMgJiBIVUZfREVDTUFTS107XG4gICAgICAgIGlmIChwbC5sZW4pIHtcbiAgICAgICAgICBsYyAtPSBwbC5sZW47XG4gICAgICAgICAgZ2V0Q29kZShwbC5saXQsIHJsYywgYywgbGMsIHVJbnQ4QXJyYXkyLCBpbkRhdGFWaWV3LCBpbk9mZnNldCwgb3V0QnVmZmVyLCBvdXRPZmZzZXQsIG91dEJ1ZmZlckVuZE9mZnNldCk7XG4gICAgICAgICAgYyA9IGdldENvZGVSZXR1cm4uYztcbiAgICAgICAgICBsYyA9IGdldENvZGVSZXR1cm4ubGM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgXCJodWZEZWNvZGUgaXNzdWVzXCI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBodWZVbmNvbXByZXNzKHVJbnQ4QXJyYXkyLCBpbkRhdGFWaWV3LCBpbk9mZnNldCwgbkNvbXByZXNzZWQsIG91dEJ1ZmZlciwgblJhdykge1xuICAgICAgdmFyIG91dE9mZnNldCA9IHsgdmFsdWU6IDAgfTtcbiAgICAgIHZhciBpbml0aWFsSW5PZmZzZXQgPSBpbk9mZnNldC52YWx1ZTtcbiAgICAgIHZhciBpbSA9IHBhcnNlVWludDMyKGluRGF0YVZpZXcsIGluT2Zmc2V0KTtcbiAgICAgIHZhciBpTSA9IHBhcnNlVWludDMyKGluRGF0YVZpZXcsIGluT2Zmc2V0KTtcbiAgICAgIGluT2Zmc2V0LnZhbHVlICs9IDQ7XG4gICAgICB2YXIgbkJpdHMgPSBwYXJzZVVpbnQzMihpbkRhdGFWaWV3LCBpbk9mZnNldCk7XG4gICAgICBpbk9mZnNldC52YWx1ZSArPSA0O1xuICAgICAgaWYgKGltIDwgMCB8fCBpbSA+PSBIVUZfRU5DU0laRSB8fCBpTSA8IDAgfHwgaU0gPj0gSFVGX0VOQ1NJWkUpIHtcbiAgICAgICAgdGhyb3cgXCJTb21ldGhpbmcgd3Jvbmcgd2l0aCBIVUZfRU5DU0laRVwiO1xuICAgICAgfVxuICAgICAgdmFyIGZyZXEgPSBuZXcgQXJyYXkoSFVGX0VOQ1NJWkUpO1xuICAgICAgdmFyIGhkZWMgPSBuZXcgQXJyYXkoSFVGX0RFQ1NJWkUpO1xuICAgICAgaHVmQ2xlYXJEZWNUYWJsZShoZGVjKTtcbiAgICAgIHZhciBuaSA9IG5Db21wcmVzc2VkIC0gKGluT2Zmc2V0LnZhbHVlIC0gaW5pdGlhbEluT2Zmc2V0KTtcbiAgICAgIGh1ZlVucGFja0VuY1RhYmxlKHVJbnQ4QXJyYXkyLCBpbkRhdGFWaWV3LCBpbk9mZnNldCwgbmksIGltLCBpTSwgZnJlcSk7XG4gICAgICBpZiAobkJpdHMgPiA4ICogKG5Db21wcmVzc2VkIC0gKGluT2Zmc2V0LnZhbHVlIC0gaW5pdGlhbEluT2Zmc2V0KSkpIHtcbiAgICAgICAgdGhyb3cgXCJTb21ldGhpbmcgd3Jvbmcgd2l0aCBodWZVbmNvbXByZXNzXCI7XG4gICAgICB9XG4gICAgICBodWZCdWlsZERlY1RhYmxlKGZyZXEsIGltLCBpTSwgaGRlYyk7XG4gICAgICBodWZEZWNvZGUoZnJlcSwgaGRlYywgdUludDhBcnJheTIsIGluRGF0YVZpZXcsIGluT2Zmc2V0LCBuQml0cywgaU0sIG5SYXcsIG91dEJ1ZmZlciwgb3V0T2Zmc2V0KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYXBwbHlMdXQobHV0LCBkYXRhLCBuRGF0YSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuRGF0YTsgKytpKSB7XG4gICAgICAgIGRhdGFbaV0gPSBsdXRbZGF0YVtpXV07XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHByZWRpY3Rvcihzb3VyY2UpIHtcbiAgICAgIGZvciAodmFyIHQgPSAxOyB0IDwgc291cmNlLmxlbmd0aDsgdCsrKSB7XG4gICAgICAgIHZhciBkID0gc291cmNlW3QgLSAxXSArIHNvdXJjZVt0XSAtIDEyODtcbiAgICAgICAgc291cmNlW3RdID0gZDtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gaW50ZXJsZWF2ZVNjYWxhcihzb3VyY2UsIG91dCkge1xuICAgICAgdmFyIHQxID0gMDtcbiAgICAgIHZhciB0MiA9IE1hdGguZmxvb3IoKHNvdXJjZS5sZW5ndGggKyAxKSAvIDIpO1xuICAgICAgdmFyIHMgPSAwO1xuICAgICAgdmFyIHN0b3AgPSBzb3VyY2UubGVuZ3RoIC0gMTtcbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGlmIChzID4gc3RvcClcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgb3V0W3MrK10gPSBzb3VyY2VbdDErK107XG4gICAgICAgIGlmIChzID4gc3RvcClcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgb3V0W3MrK10gPSBzb3VyY2VbdDIrK107XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlY29kZVJ1bkxlbmd0aChzb3VyY2UpIHtcbiAgICAgIHZhciBzaXplID0gc291cmNlLmJ5dGVMZW5ndGg7XG4gICAgICB2YXIgb3V0ID0gbmV3IEFycmF5KCk7XG4gICAgICB2YXIgcCA9IDA7XG4gICAgICB2YXIgcmVhZGVyID0gbmV3IERhdGFWaWV3KHNvdXJjZSk7XG4gICAgICB3aGlsZSAoc2l6ZSA+IDApIHtcbiAgICAgICAgdmFyIGwgPSByZWFkZXIuZ2V0SW50OChwKyspO1xuICAgICAgICBpZiAobCA8IDApIHtcbiAgICAgICAgICB2YXIgY291bnQgPSAtbDtcbiAgICAgICAgICBzaXplIC09IGNvdW50ICsgMTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgICAgIG91dC5wdXNoKHJlYWRlci5nZXRVaW50OChwKyspKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGNvdW50ID0gbDtcbiAgICAgICAgICBzaXplIC09IDI7XG4gICAgICAgICAgdmFyIHZhbHVlID0gcmVhZGVyLmdldFVpbnQ4KHArKyk7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudCArIDE7IGkrKykge1xuICAgICAgICAgICAgb3V0LnB1c2godmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG4gICAgZnVuY3Rpb24gbG9zc3lEY3REZWNvZGUoY3NjU2V0LCByb3dQdHJzLCBjaGFubmVsRGF0YSwgYWNCdWZmZXIsIGRjQnVmZmVyLCBvdXRCdWZmZXIpIHtcbiAgICAgIHZhciBkYXRhVmlldyA9IG5ldyBEYXRhVmlldyhvdXRCdWZmZXIuYnVmZmVyKTtcbiAgICAgIHZhciB3aWR0aCA9IGNoYW5uZWxEYXRhW2NzY1NldC5pZHhbMF1dLndpZHRoO1xuICAgICAgdmFyIGhlaWdodCA9IGNoYW5uZWxEYXRhW2NzY1NldC5pZHhbMF1dLmhlaWdodDtcbiAgICAgIHZhciBudW1Db21wID0gMztcbiAgICAgIHZhciBudW1GdWxsQmxvY2tzWCA9IE1hdGguZmxvb3Iod2lkdGggLyA4KTtcbiAgICAgIHZhciBudW1CbG9ja3NYID0gTWF0aC5jZWlsKHdpZHRoIC8gOCk7XG4gICAgICB2YXIgbnVtQmxvY2tzWSA9IE1hdGguY2VpbChoZWlnaHQgLyA4KTtcbiAgICAgIHZhciBsZWZ0b3ZlclggPSB3aWR0aCAtIChudW1CbG9ja3NYIC0gMSkgKiA4O1xuICAgICAgdmFyIGxlZnRvdmVyWSA9IGhlaWdodCAtIChudW1CbG9ja3NZIC0gMSkgKiA4O1xuICAgICAgdmFyIGN1cnJBY0NvbXAgPSB7IHZhbHVlOiAwIH07XG4gICAgICB2YXIgY3VyckRjQ29tcCA9IG5ldyBBcnJheShudW1Db21wKTtcbiAgICAgIHZhciBkY3REYXRhID0gbmV3IEFycmF5KG51bUNvbXApO1xuICAgICAgdmFyIGhhbGZaaWdCbG9jayA9IG5ldyBBcnJheShudW1Db21wKTtcbiAgICAgIHZhciByb3dCbG9jayA9IG5ldyBBcnJheShudW1Db21wKTtcbiAgICAgIHZhciByb3dPZmZzZXRzID0gbmV3IEFycmF5KG51bUNvbXApO1xuICAgICAgZm9yIChsZXQgY29tcDIgPSAwOyBjb21wMiA8IG51bUNvbXA7ICsrY29tcDIpIHtcbiAgICAgICAgcm93T2Zmc2V0c1tjb21wMl0gPSByb3dQdHJzW2NzY1NldC5pZHhbY29tcDJdXTtcbiAgICAgICAgY3VyckRjQ29tcFtjb21wMl0gPSBjb21wMiA8IDEgPyAwIDogY3VyckRjQ29tcFtjb21wMiAtIDFdICsgbnVtQmxvY2tzWCAqIG51bUJsb2Nrc1k7XG4gICAgICAgIGRjdERhdGFbY29tcDJdID0gbmV3IEZsb2F0MzJBcnJheSg2NCk7XG4gICAgICAgIGhhbGZaaWdCbG9ja1tjb21wMl0gPSBuZXcgVWludDE2QXJyYXkoNjQpO1xuICAgICAgICByb3dCbG9ja1tjb21wMl0gPSBuZXcgVWludDE2QXJyYXkobnVtQmxvY2tzWCAqIDY0KTtcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGJsb2NreSA9IDA7IGJsb2NreSA8IG51bUJsb2Nrc1k7ICsrYmxvY2t5KSB7XG4gICAgICAgIHZhciBtYXhZID0gODtcbiAgICAgICAgaWYgKGJsb2NreSA9PSBudW1CbG9ja3NZIC0gMSlcbiAgICAgICAgICBtYXhZID0gbGVmdG92ZXJZO1xuICAgICAgICB2YXIgbWF4WCA9IDg7XG4gICAgICAgIGZvciAobGV0IGJsb2NreCA9IDA7IGJsb2NreCA8IG51bUJsb2Nrc1g7ICsrYmxvY2t4KSB7XG4gICAgICAgICAgaWYgKGJsb2NreCA9PSBudW1CbG9ja3NYIC0gMSlcbiAgICAgICAgICAgIG1heFggPSBsZWZ0b3Zlclg7XG4gICAgICAgICAgZm9yIChsZXQgY29tcDIgPSAwOyBjb21wMiA8IG51bUNvbXA7ICsrY29tcDIpIHtcbiAgICAgICAgICAgIGhhbGZaaWdCbG9ja1tjb21wMl0uZmlsbCgwKTtcbiAgICAgICAgICAgIGhhbGZaaWdCbG9ja1tjb21wMl1bMF0gPSBkY0J1ZmZlcltjdXJyRGNDb21wW2NvbXAyXSsrXTtcbiAgICAgICAgICAgIHVuUmxlQUMoY3VyckFjQ29tcCwgYWNCdWZmZXIsIGhhbGZaaWdCbG9ja1tjb21wMl0pO1xuICAgICAgICAgICAgdW5aaWdaYWcoaGFsZlppZ0Jsb2NrW2NvbXAyXSwgZGN0RGF0YVtjb21wMl0pO1xuICAgICAgICAgICAgZGN0SW52ZXJzZShkY3REYXRhW2NvbXAyXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNzYzcwOUludmVyc2UoZGN0RGF0YSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAobGV0IGNvbXAyID0gMDsgY29tcDIgPCBudW1Db21wOyArK2NvbXAyKSB7XG4gICAgICAgICAgICBjb252ZXJ0VG9IYWxmKGRjdERhdGFbY29tcDJdLCByb3dCbG9ja1tjb21wMl0sIGJsb2NreCAqIDY0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG9mZnNldDIgPSAwO1xuICAgICAgICBmb3IgKGxldCBjb21wMiA9IDA7IGNvbXAyIDwgbnVtQ29tcDsgKytjb21wMikge1xuICAgICAgICAgIGNvbnN0IHR5cGUyID0gY2hhbm5lbERhdGFbY3NjU2V0LmlkeFtjb21wMl1dLnR5cGU7XG4gICAgICAgICAgZm9yIChsZXQgeTIgPSA4ICogYmxvY2t5OyB5MiA8IDggKiBibG9ja3kgKyBtYXhZOyArK3kyKSB7XG4gICAgICAgICAgICBvZmZzZXQyID0gcm93T2Zmc2V0c1tjb21wMl1beTJdO1xuICAgICAgICAgICAgZm9yIChsZXQgYmxvY2t4ID0gMDsgYmxvY2t4IDwgbnVtRnVsbEJsb2Nrc1g7ICsrYmxvY2t4KSB7XG4gICAgICAgICAgICAgIGNvbnN0IHNyYyA9IGJsb2NreCAqIDY0ICsgKHkyICYgNykgKiA4O1xuICAgICAgICAgICAgICBkYXRhVmlldy5zZXRVaW50MTYob2Zmc2V0MiArIDAgKiBJTlQxNl9TSVpFICogdHlwZTIsIHJvd0Jsb2NrW2NvbXAyXVtzcmMgKyAwXSwgdHJ1ZSk7XG4gICAgICAgICAgICAgIGRhdGFWaWV3LnNldFVpbnQxNihvZmZzZXQyICsgMSAqIElOVDE2X1NJWkUgKiB0eXBlMiwgcm93QmxvY2tbY29tcDJdW3NyYyArIDFdLCB0cnVlKTtcbiAgICAgICAgICAgICAgZGF0YVZpZXcuc2V0VWludDE2KG9mZnNldDIgKyAyICogSU5UMTZfU0laRSAqIHR5cGUyLCByb3dCbG9ja1tjb21wMl1bc3JjICsgMl0sIHRydWUpO1xuICAgICAgICAgICAgICBkYXRhVmlldy5zZXRVaW50MTYob2Zmc2V0MiArIDMgKiBJTlQxNl9TSVpFICogdHlwZTIsIHJvd0Jsb2NrW2NvbXAyXVtzcmMgKyAzXSwgdHJ1ZSk7XG4gICAgICAgICAgICAgIGRhdGFWaWV3LnNldFVpbnQxNihvZmZzZXQyICsgNCAqIElOVDE2X1NJWkUgKiB0eXBlMiwgcm93QmxvY2tbY29tcDJdW3NyYyArIDRdLCB0cnVlKTtcbiAgICAgICAgICAgICAgZGF0YVZpZXcuc2V0VWludDE2KG9mZnNldDIgKyA1ICogSU5UMTZfU0laRSAqIHR5cGUyLCByb3dCbG9ja1tjb21wMl1bc3JjICsgNV0sIHRydWUpO1xuICAgICAgICAgICAgICBkYXRhVmlldy5zZXRVaW50MTYob2Zmc2V0MiArIDYgKiBJTlQxNl9TSVpFICogdHlwZTIsIHJvd0Jsb2NrW2NvbXAyXVtzcmMgKyA2XSwgdHJ1ZSk7XG4gICAgICAgICAgICAgIGRhdGFWaWV3LnNldFVpbnQxNihvZmZzZXQyICsgNyAqIElOVDE2X1NJWkUgKiB0eXBlMiwgcm93QmxvY2tbY29tcDJdW3NyYyArIDddLCB0cnVlKTtcbiAgICAgICAgICAgICAgb2Zmc2V0MiArPSA4ICogSU5UMTZfU0laRSAqIHR5cGUyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobnVtRnVsbEJsb2Nrc1ggIT0gbnVtQmxvY2tzWCkge1xuICAgICAgICAgICAgZm9yIChsZXQgeTIgPSA4ICogYmxvY2t5OyB5MiA8IDggKiBibG9ja3kgKyBtYXhZOyArK3kyKSB7XG4gICAgICAgICAgICAgIGNvbnN0IG9mZnNldDMgPSByb3dPZmZzZXRzW2NvbXAyXVt5Ml0gKyA4ICogbnVtRnVsbEJsb2Nrc1ggKiBJTlQxNl9TSVpFICogdHlwZTI7XG4gICAgICAgICAgICAgIGNvbnN0IHNyYyA9IG51bUZ1bGxCbG9ja3NYICogNjQgKyAoeTIgJiA3KSAqIDg7XG4gICAgICAgICAgICAgIGZvciAobGV0IHgyID0gMDsgeDIgPCBtYXhYOyArK3gyKSB7XG4gICAgICAgICAgICAgICAgZGF0YVZpZXcuc2V0VWludDE2KG9mZnNldDMgKyB4MiAqIElOVDE2X1NJWkUgKiB0eXBlMiwgcm93QmxvY2tbY29tcDJdW3NyYyArIHgyXSwgdHJ1ZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBoYWxmUm93ID0gbmV3IFVpbnQxNkFycmF5KHdpZHRoKTtcbiAgICAgIHZhciBkYXRhVmlldyA9IG5ldyBEYXRhVmlldyhvdXRCdWZmZXIuYnVmZmVyKTtcbiAgICAgIGZvciAodmFyIGNvbXAgPSAwOyBjb21wIDwgbnVtQ29tcDsgKytjb21wKSB7XG4gICAgICAgIGNoYW5uZWxEYXRhW2NzY1NldC5pZHhbY29tcF1dLmRlY29kZWQgPSB0cnVlO1xuICAgICAgICB2YXIgdHlwZSA9IGNoYW5uZWxEYXRhW2NzY1NldC5pZHhbY29tcF1dLnR5cGU7XG4gICAgICAgIGlmIChjaGFubmVsRGF0YVtjb21wXS50eXBlICE9IDIpXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIGZvciAodmFyIHkgPSAwOyB5IDwgaGVpZ2h0OyArK3kpIHtcbiAgICAgICAgICBjb25zdCBvZmZzZXQyID0gcm93T2Zmc2V0c1tjb21wXVt5XTtcbiAgICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IHdpZHRoOyArK3gpIHtcbiAgICAgICAgICAgIGhhbGZSb3dbeF0gPSBkYXRhVmlldy5nZXRVaW50MTYob2Zmc2V0MiArIHggKiBJTlQxNl9TSVpFICogdHlwZSwgdHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgd2lkdGg7ICsreCkge1xuICAgICAgICAgICAgZGF0YVZpZXcuc2V0RmxvYXQzMihvZmZzZXQyICsgeCAqIElOVDE2X1NJWkUgKiB0eXBlLCBkZWNvZGVGbG9hdDE2KGhhbGZSb3dbeF0pLCB0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gdW5SbGVBQyhjdXJyQWNDb21wLCBhY0J1ZmZlciwgaGFsZlppZ0Jsb2NrKSB7XG4gICAgICB2YXIgYWNWYWx1ZTtcbiAgICAgIHZhciBkY3RDb21wID0gMTtcbiAgICAgIHdoaWxlIChkY3RDb21wIDwgNjQpIHtcbiAgICAgICAgYWNWYWx1ZSA9IGFjQnVmZmVyW2N1cnJBY0NvbXAudmFsdWVdO1xuICAgICAgICBpZiAoYWNWYWx1ZSA9PSA2NTI4MCkge1xuICAgICAgICAgIGRjdENvbXAgPSA2NDtcbiAgICAgICAgfSBlbHNlIGlmIChhY1ZhbHVlID4+IDggPT0gMjU1KSB7XG4gICAgICAgICAgZGN0Q29tcCArPSBhY1ZhbHVlICYgMjU1O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGhhbGZaaWdCbG9ja1tkY3RDb21wXSA9IGFjVmFsdWU7XG4gICAgICAgICAgZGN0Q29tcCsrO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJBY0NvbXAudmFsdWUrKztcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gdW5aaWdaYWcoc3JjLCBkc3QpIHtcbiAgICAgIGRzdFswXSA9IGRlY29kZUZsb2F0MTYoc3JjWzBdKTtcbiAgICAgIGRzdFsxXSA9IGRlY29kZUZsb2F0MTYoc3JjWzFdKTtcbiAgICAgIGRzdFsyXSA9IGRlY29kZUZsb2F0MTYoc3JjWzVdKTtcbiAgICAgIGRzdFszXSA9IGRlY29kZUZsb2F0MTYoc3JjWzZdKTtcbiAgICAgIGRzdFs0XSA9IGRlY29kZUZsb2F0MTYoc3JjWzE0XSk7XG4gICAgICBkc3RbNV0gPSBkZWNvZGVGbG9hdDE2KHNyY1sxNV0pO1xuICAgICAgZHN0WzZdID0gZGVjb2RlRmxvYXQxNihzcmNbMjddKTtcbiAgICAgIGRzdFs3XSA9IGRlY29kZUZsb2F0MTYoc3JjWzI4XSk7XG4gICAgICBkc3RbOF0gPSBkZWNvZGVGbG9hdDE2KHNyY1syXSk7XG4gICAgICBkc3RbOV0gPSBkZWNvZGVGbG9hdDE2KHNyY1s0XSk7XG4gICAgICBkc3RbMTBdID0gZGVjb2RlRmxvYXQxNihzcmNbN10pO1xuICAgICAgZHN0WzExXSA9IGRlY29kZUZsb2F0MTYoc3JjWzEzXSk7XG4gICAgICBkc3RbMTJdID0gZGVjb2RlRmxvYXQxNihzcmNbMTZdKTtcbiAgICAgIGRzdFsxM10gPSBkZWNvZGVGbG9hdDE2KHNyY1syNl0pO1xuICAgICAgZHN0WzE0XSA9IGRlY29kZUZsb2F0MTYoc3JjWzI5XSk7XG4gICAgICBkc3RbMTVdID0gZGVjb2RlRmxvYXQxNihzcmNbNDJdKTtcbiAgICAgIGRzdFsxNl0gPSBkZWNvZGVGbG9hdDE2KHNyY1szXSk7XG4gICAgICBkc3RbMTddID0gZGVjb2RlRmxvYXQxNihzcmNbOF0pO1xuICAgICAgZHN0WzE4XSA9IGRlY29kZUZsb2F0MTYoc3JjWzEyXSk7XG4gICAgICBkc3RbMTldID0gZGVjb2RlRmxvYXQxNihzcmNbMTddKTtcbiAgICAgIGRzdFsyMF0gPSBkZWNvZGVGbG9hdDE2KHNyY1syNV0pO1xuICAgICAgZHN0WzIxXSA9IGRlY29kZUZsb2F0MTYoc3JjWzMwXSk7XG4gICAgICBkc3RbMjJdID0gZGVjb2RlRmxvYXQxNihzcmNbNDFdKTtcbiAgICAgIGRzdFsyM10gPSBkZWNvZGVGbG9hdDE2KHNyY1s0M10pO1xuICAgICAgZHN0WzI0XSA9IGRlY29kZUZsb2F0MTYoc3JjWzldKTtcbiAgICAgIGRzdFsyNV0gPSBkZWNvZGVGbG9hdDE2KHNyY1sxMV0pO1xuICAgICAgZHN0WzI2XSA9IGRlY29kZUZsb2F0MTYoc3JjWzE4XSk7XG4gICAgICBkc3RbMjddID0gZGVjb2RlRmxvYXQxNihzcmNbMjRdKTtcbiAgICAgIGRzdFsyOF0gPSBkZWNvZGVGbG9hdDE2KHNyY1szMV0pO1xuICAgICAgZHN0WzI5XSA9IGRlY29kZUZsb2F0MTYoc3JjWzQwXSk7XG4gICAgICBkc3RbMzBdID0gZGVjb2RlRmxvYXQxNihzcmNbNDRdKTtcbiAgICAgIGRzdFszMV0gPSBkZWNvZGVGbG9hdDE2KHNyY1s1M10pO1xuICAgICAgZHN0WzMyXSA9IGRlY29kZUZsb2F0MTYoc3JjWzEwXSk7XG4gICAgICBkc3RbMzNdID0gZGVjb2RlRmxvYXQxNihzcmNbMTldKTtcbiAgICAgIGRzdFszNF0gPSBkZWNvZGVGbG9hdDE2KHNyY1syM10pO1xuICAgICAgZHN0WzM1XSA9IGRlY29kZUZsb2F0MTYoc3JjWzMyXSk7XG4gICAgICBkc3RbMzZdID0gZGVjb2RlRmxvYXQxNihzcmNbMzldKTtcbiAgICAgIGRzdFszN10gPSBkZWNvZGVGbG9hdDE2KHNyY1s0NV0pO1xuICAgICAgZHN0WzM4XSA9IGRlY29kZUZsb2F0MTYoc3JjWzUyXSk7XG4gICAgICBkc3RbMzldID0gZGVjb2RlRmxvYXQxNihzcmNbNTRdKTtcbiAgICAgIGRzdFs0MF0gPSBkZWNvZGVGbG9hdDE2KHNyY1syMF0pO1xuICAgICAgZHN0WzQxXSA9IGRlY29kZUZsb2F0MTYoc3JjWzIyXSk7XG4gICAgICBkc3RbNDJdID0gZGVjb2RlRmxvYXQxNihzcmNbMzNdKTtcbiAgICAgIGRzdFs0M10gPSBkZWNvZGVGbG9hdDE2KHNyY1szOF0pO1xuICAgICAgZHN0WzQ0XSA9IGRlY29kZUZsb2F0MTYoc3JjWzQ2XSk7XG4gICAgICBkc3RbNDVdID0gZGVjb2RlRmxvYXQxNihzcmNbNTFdKTtcbiAgICAgIGRzdFs0Nl0gPSBkZWNvZGVGbG9hdDE2KHNyY1s1NV0pO1xuICAgICAgZHN0WzQ3XSA9IGRlY29kZUZsb2F0MTYoc3JjWzYwXSk7XG4gICAgICBkc3RbNDhdID0gZGVjb2RlRmxvYXQxNihzcmNbMjFdKTtcbiAgICAgIGRzdFs0OV0gPSBkZWNvZGVGbG9hdDE2KHNyY1szNF0pO1xuICAgICAgZHN0WzUwXSA9IGRlY29kZUZsb2F0MTYoc3JjWzM3XSk7XG4gICAgICBkc3RbNTFdID0gZGVjb2RlRmxvYXQxNihzcmNbNDddKTtcbiAgICAgIGRzdFs1Ml0gPSBkZWNvZGVGbG9hdDE2KHNyY1s1MF0pO1xuICAgICAgZHN0WzUzXSA9IGRlY29kZUZsb2F0MTYoc3JjWzU2XSk7XG4gICAgICBkc3RbNTRdID0gZGVjb2RlRmxvYXQxNihzcmNbNTldKTtcbiAgICAgIGRzdFs1NV0gPSBkZWNvZGVGbG9hdDE2KHNyY1s2MV0pO1xuICAgICAgZHN0WzU2XSA9IGRlY29kZUZsb2F0MTYoc3JjWzM1XSk7XG4gICAgICBkc3RbNTddID0gZGVjb2RlRmxvYXQxNihzcmNbMzZdKTtcbiAgICAgIGRzdFs1OF0gPSBkZWNvZGVGbG9hdDE2KHNyY1s0OF0pO1xuICAgICAgZHN0WzU5XSA9IGRlY29kZUZsb2F0MTYoc3JjWzQ5XSk7XG4gICAgICBkc3RbNjBdID0gZGVjb2RlRmxvYXQxNihzcmNbNTddKTtcbiAgICAgIGRzdFs2MV0gPSBkZWNvZGVGbG9hdDE2KHNyY1s1OF0pO1xuICAgICAgZHN0WzYyXSA9IGRlY29kZUZsb2F0MTYoc3JjWzYyXSk7XG4gICAgICBkc3RbNjNdID0gZGVjb2RlRmxvYXQxNihzcmNbNjNdKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGN0SW52ZXJzZShkYXRhKSB7XG4gICAgICBjb25zdCBhID0gMC41ICogTWF0aC5jb3MoMy4xNDE1OSAvIDQpO1xuICAgICAgY29uc3QgYiA9IDAuNSAqIE1hdGguY29zKDMuMTQxNTkgLyAxNik7XG4gICAgICBjb25zdCBjID0gMC41ICogTWF0aC5jb3MoMy4xNDE1OSAvIDgpO1xuICAgICAgY29uc3QgZCA9IDAuNSAqIE1hdGguY29zKDMgKiAzLjE0MTU5IC8gMTYpO1xuICAgICAgY29uc3QgZSA9IDAuNSAqIE1hdGguY29zKDUgKiAzLjE0MTU5IC8gMTYpO1xuICAgICAgY29uc3QgZiA9IDAuNSAqIE1hdGguY29zKDMgKiAzLjE0MTU5IC8gOCk7XG4gICAgICBjb25zdCBnID0gMC41ICogTWF0aC5jb3MoNyAqIDMuMTQxNTkgLyAxNik7XG4gICAgICB2YXIgYWxwaGEgPSBuZXcgQXJyYXkoNCk7XG4gICAgICB2YXIgYmV0YSA9IG5ldyBBcnJheSg0KTtcbiAgICAgIHZhciB0aGV0YSA9IG5ldyBBcnJheSg0KTtcbiAgICAgIHZhciBnYW1tYSA9IG5ldyBBcnJheSg0KTtcbiAgICAgIGZvciAodmFyIHJvdyA9IDA7IHJvdyA8IDg7ICsrcm93KSB7XG4gICAgICAgIHZhciByb3dQdHIgPSByb3cgKiA4O1xuICAgICAgICBhbHBoYVswXSA9IGMgKiBkYXRhW3Jvd1B0ciArIDJdO1xuICAgICAgICBhbHBoYVsxXSA9IGYgKiBkYXRhW3Jvd1B0ciArIDJdO1xuICAgICAgICBhbHBoYVsyXSA9IGMgKiBkYXRhW3Jvd1B0ciArIDZdO1xuICAgICAgICBhbHBoYVszXSA9IGYgKiBkYXRhW3Jvd1B0ciArIDZdO1xuICAgICAgICBiZXRhWzBdID0gYiAqIGRhdGFbcm93UHRyICsgMV0gKyBkICogZGF0YVtyb3dQdHIgKyAzXSArIGUgKiBkYXRhW3Jvd1B0ciArIDVdICsgZyAqIGRhdGFbcm93UHRyICsgN107XG4gICAgICAgIGJldGFbMV0gPSBkICogZGF0YVtyb3dQdHIgKyAxXSAtIGcgKiBkYXRhW3Jvd1B0ciArIDNdIC0gYiAqIGRhdGFbcm93UHRyICsgNV0gLSBlICogZGF0YVtyb3dQdHIgKyA3XTtcbiAgICAgICAgYmV0YVsyXSA9IGUgKiBkYXRhW3Jvd1B0ciArIDFdIC0gYiAqIGRhdGFbcm93UHRyICsgM10gKyBnICogZGF0YVtyb3dQdHIgKyA1XSArIGQgKiBkYXRhW3Jvd1B0ciArIDddO1xuICAgICAgICBiZXRhWzNdID0gZyAqIGRhdGFbcm93UHRyICsgMV0gLSBlICogZGF0YVtyb3dQdHIgKyAzXSArIGQgKiBkYXRhW3Jvd1B0ciArIDVdIC0gYiAqIGRhdGFbcm93UHRyICsgN107XG4gICAgICAgIHRoZXRhWzBdID0gYSAqIChkYXRhW3Jvd1B0ciArIDBdICsgZGF0YVtyb3dQdHIgKyA0XSk7XG4gICAgICAgIHRoZXRhWzNdID0gYSAqIChkYXRhW3Jvd1B0ciArIDBdIC0gZGF0YVtyb3dQdHIgKyA0XSk7XG4gICAgICAgIHRoZXRhWzFdID0gYWxwaGFbMF0gKyBhbHBoYVszXTtcbiAgICAgICAgdGhldGFbMl0gPSBhbHBoYVsxXSAtIGFscGhhWzJdO1xuICAgICAgICBnYW1tYVswXSA9IHRoZXRhWzBdICsgdGhldGFbMV07XG4gICAgICAgIGdhbW1hWzFdID0gdGhldGFbM10gKyB0aGV0YVsyXTtcbiAgICAgICAgZ2FtbWFbMl0gPSB0aGV0YVszXSAtIHRoZXRhWzJdO1xuICAgICAgICBnYW1tYVszXSA9IHRoZXRhWzBdIC0gdGhldGFbMV07XG4gICAgICAgIGRhdGFbcm93UHRyICsgMF0gPSBnYW1tYVswXSArIGJldGFbMF07XG4gICAgICAgIGRhdGFbcm93UHRyICsgMV0gPSBnYW1tYVsxXSArIGJldGFbMV07XG4gICAgICAgIGRhdGFbcm93UHRyICsgMl0gPSBnYW1tYVsyXSArIGJldGFbMl07XG4gICAgICAgIGRhdGFbcm93UHRyICsgM10gPSBnYW1tYVszXSArIGJldGFbM107XG4gICAgICAgIGRhdGFbcm93UHRyICsgNF0gPSBnYW1tYVszXSAtIGJldGFbM107XG4gICAgICAgIGRhdGFbcm93UHRyICsgNV0gPSBnYW1tYVsyXSAtIGJldGFbMl07XG4gICAgICAgIGRhdGFbcm93UHRyICsgNl0gPSBnYW1tYVsxXSAtIGJldGFbMV07XG4gICAgICAgIGRhdGFbcm93UHRyICsgN10gPSBnYW1tYVswXSAtIGJldGFbMF07XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBjb2x1bW4gPSAwOyBjb2x1bW4gPCA4OyArK2NvbHVtbikge1xuICAgICAgICBhbHBoYVswXSA9IGMgKiBkYXRhWzE2ICsgY29sdW1uXTtcbiAgICAgICAgYWxwaGFbMV0gPSBmICogZGF0YVsxNiArIGNvbHVtbl07XG4gICAgICAgIGFscGhhWzJdID0gYyAqIGRhdGFbNDggKyBjb2x1bW5dO1xuICAgICAgICBhbHBoYVszXSA9IGYgKiBkYXRhWzQ4ICsgY29sdW1uXTtcbiAgICAgICAgYmV0YVswXSA9IGIgKiBkYXRhWzggKyBjb2x1bW5dICsgZCAqIGRhdGFbMjQgKyBjb2x1bW5dICsgZSAqIGRhdGFbNDAgKyBjb2x1bW5dICsgZyAqIGRhdGFbNTYgKyBjb2x1bW5dO1xuICAgICAgICBiZXRhWzFdID0gZCAqIGRhdGFbOCArIGNvbHVtbl0gLSBnICogZGF0YVsyNCArIGNvbHVtbl0gLSBiICogZGF0YVs0MCArIGNvbHVtbl0gLSBlICogZGF0YVs1NiArIGNvbHVtbl07XG4gICAgICAgIGJldGFbMl0gPSBlICogZGF0YVs4ICsgY29sdW1uXSAtIGIgKiBkYXRhWzI0ICsgY29sdW1uXSArIGcgKiBkYXRhWzQwICsgY29sdW1uXSArIGQgKiBkYXRhWzU2ICsgY29sdW1uXTtcbiAgICAgICAgYmV0YVszXSA9IGcgKiBkYXRhWzggKyBjb2x1bW5dIC0gZSAqIGRhdGFbMjQgKyBjb2x1bW5dICsgZCAqIGRhdGFbNDAgKyBjb2x1bW5dIC0gYiAqIGRhdGFbNTYgKyBjb2x1bW5dO1xuICAgICAgICB0aGV0YVswXSA9IGEgKiAoZGF0YVtjb2x1bW5dICsgZGF0YVszMiArIGNvbHVtbl0pO1xuICAgICAgICB0aGV0YVszXSA9IGEgKiAoZGF0YVtjb2x1bW5dIC0gZGF0YVszMiArIGNvbHVtbl0pO1xuICAgICAgICB0aGV0YVsxXSA9IGFscGhhWzBdICsgYWxwaGFbM107XG4gICAgICAgIHRoZXRhWzJdID0gYWxwaGFbMV0gLSBhbHBoYVsyXTtcbiAgICAgICAgZ2FtbWFbMF0gPSB0aGV0YVswXSArIHRoZXRhWzFdO1xuICAgICAgICBnYW1tYVsxXSA9IHRoZXRhWzNdICsgdGhldGFbMl07XG4gICAgICAgIGdhbW1hWzJdID0gdGhldGFbM10gLSB0aGV0YVsyXTtcbiAgICAgICAgZ2FtbWFbM10gPSB0aGV0YVswXSAtIHRoZXRhWzFdO1xuICAgICAgICBkYXRhWzAgKyBjb2x1bW5dID0gZ2FtbWFbMF0gKyBiZXRhWzBdO1xuICAgICAgICBkYXRhWzggKyBjb2x1bW5dID0gZ2FtbWFbMV0gKyBiZXRhWzFdO1xuICAgICAgICBkYXRhWzE2ICsgY29sdW1uXSA9IGdhbW1hWzJdICsgYmV0YVsyXTtcbiAgICAgICAgZGF0YVsyNCArIGNvbHVtbl0gPSBnYW1tYVszXSArIGJldGFbM107XG4gICAgICAgIGRhdGFbMzIgKyBjb2x1bW5dID0gZ2FtbWFbM10gLSBiZXRhWzNdO1xuICAgICAgICBkYXRhWzQwICsgY29sdW1uXSA9IGdhbW1hWzJdIC0gYmV0YVsyXTtcbiAgICAgICAgZGF0YVs0OCArIGNvbHVtbl0gPSBnYW1tYVsxXSAtIGJldGFbMV07XG4gICAgICAgIGRhdGFbNTYgKyBjb2x1bW5dID0gZ2FtbWFbMF0gLSBiZXRhWzBdO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBjc2M3MDlJbnZlcnNlKGRhdGEpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNjQ7ICsraSkge1xuICAgICAgICB2YXIgeSA9IGRhdGFbMF1baV07XG4gICAgICAgIHZhciBjYiA9IGRhdGFbMV1baV07XG4gICAgICAgIHZhciBjciA9IGRhdGFbMl1baV07XG4gICAgICAgIGRhdGFbMF1baV0gPSB5ICsgMS41NzQ3ICogY3I7XG4gICAgICAgIGRhdGFbMV1baV0gPSB5IC0gMC4xODczICogY2IgLSAwLjQ2ODIgKiBjcjtcbiAgICAgICAgZGF0YVsyXVtpXSA9IHkgKyAxLjg1NTYgKiBjYjtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gY29udmVydFRvSGFsZihzcmMsIGRzdCwgaWR4KSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDY0OyArK2kpIHtcbiAgICAgICAgZHN0W2lkeCArIGldID0gRGF0YVV0aWxzLnRvSGFsZkZsb2F0KHRvTGluZWFyKHNyY1tpXSkpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB0b0xpbmVhcihmbG9hdCkge1xuICAgICAgaWYgKGZsb2F0IDw9IDEpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguc2lnbihmbG9hdCkgKiBNYXRoLnBvdyhNYXRoLmFicyhmbG9hdCksIDIuMik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gTWF0aC5zaWduKGZsb2F0KSAqIE1hdGgucG93KGxvZ0Jhc2UsIE1hdGguYWJzKGZsb2F0KSAtIDEpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB1bmNvbXByZXNzUkFXKGluZm8pIHtcbiAgICAgIHJldHVybiBuZXcgRGF0YVZpZXcoaW5mby5hcnJheS5idWZmZXIsIGluZm8ub2Zmc2V0LnZhbHVlLCBpbmZvLnNpemUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1bmNvbXByZXNzUkxFKGluZm8pIHtcbiAgICAgIHZhciBjb21wcmVzc2VkID0gaW5mby52aWV3ZXIuYnVmZmVyLnNsaWNlKGluZm8ub2Zmc2V0LnZhbHVlLCBpbmZvLm9mZnNldC52YWx1ZSArIGluZm8uc2l6ZSk7XG4gICAgICB2YXIgcmF3QnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoZGVjb2RlUnVuTGVuZ3RoKGNvbXByZXNzZWQpKTtcbiAgICAgIHZhciB0bXBCdWZmZXIgPSBuZXcgVWludDhBcnJheShyYXdCdWZmZXIubGVuZ3RoKTtcbiAgICAgIHByZWRpY3RvcihyYXdCdWZmZXIpO1xuICAgICAgaW50ZXJsZWF2ZVNjYWxhcihyYXdCdWZmZXIsIHRtcEJ1ZmZlcik7XG4gICAgICByZXR1cm4gbmV3IERhdGFWaWV3KHRtcEJ1ZmZlci5idWZmZXIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1bmNvbXByZXNzWklQKGluZm8pIHtcbiAgICAgIHZhciBjb21wcmVzc2VkID0gaW5mby5hcnJheS5zbGljZShpbmZvLm9mZnNldC52YWx1ZSwgaW5mby5vZmZzZXQudmFsdWUgKyBpbmZvLnNpemUpO1xuICAgICAgdmFyIHJhd0J1ZmZlciA9IHVuemxpYlN5bmMoY29tcHJlc3NlZCk7XG4gICAgICB2YXIgdG1wQnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkocmF3QnVmZmVyLmxlbmd0aCk7XG4gICAgICBwcmVkaWN0b3IocmF3QnVmZmVyKTtcbiAgICAgIGludGVybGVhdmVTY2FsYXIocmF3QnVmZmVyLCB0bXBCdWZmZXIpO1xuICAgICAgcmV0dXJuIG5ldyBEYXRhVmlldyh0bXBCdWZmZXIuYnVmZmVyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdW5jb21wcmVzc1BJWihpbmZvKSB7XG4gICAgICB2YXIgaW5EYXRhVmlldyA9IGluZm8udmlld2VyO1xuICAgICAgdmFyIGluT2Zmc2V0ID0geyB2YWx1ZTogaW5mby5vZmZzZXQudmFsdWUgfTtcbiAgICAgIHZhciBvdXRCdWZmZXIgPSBuZXcgVWludDE2QXJyYXkoaW5mby53aWR0aCAqIGluZm8uc2NhbmxpbmVCbG9ja1NpemUgKiAoaW5mby5jaGFubmVscyAqIGluZm8udHlwZSkpO1xuICAgICAgdmFyIGJpdG1hcCA9IG5ldyBVaW50OEFycmF5KEJJVE1BUF9TSVpFKTtcbiAgICAgIHZhciBvdXRCdWZmZXJFbmQgPSAwO1xuICAgICAgdmFyIHBpekNoYW5uZWxEYXRhID0gbmV3IEFycmF5KGluZm8uY2hhbm5lbHMpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbmZvLmNoYW5uZWxzOyBpKyspIHtcbiAgICAgICAgcGl6Q2hhbm5lbERhdGFbaV0gPSB7fTtcbiAgICAgICAgcGl6Q2hhbm5lbERhdGFbaV1bXCJzdGFydFwiXSA9IG91dEJ1ZmZlckVuZDtcbiAgICAgICAgcGl6Q2hhbm5lbERhdGFbaV1bXCJlbmRcIl0gPSBwaXpDaGFubmVsRGF0YVtpXVtcInN0YXJ0XCJdO1xuICAgICAgICBwaXpDaGFubmVsRGF0YVtpXVtcIm54XCJdID0gaW5mby53aWR0aDtcbiAgICAgICAgcGl6Q2hhbm5lbERhdGFbaV1bXCJueVwiXSA9IGluZm8ubGluZXM7XG4gICAgICAgIHBpekNoYW5uZWxEYXRhW2ldW1wic2l6ZVwiXSA9IGluZm8udHlwZTtcbiAgICAgICAgb3V0QnVmZmVyRW5kICs9IHBpekNoYW5uZWxEYXRhW2ldLm54ICogcGl6Q2hhbm5lbERhdGFbaV0ubnkgKiBwaXpDaGFubmVsRGF0YVtpXS5zaXplO1xuICAgICAgfVxuICAgICAgdmFyIG1pbk5vblplcm8gPSBwYXJzZVVpbnQxNihpbkRhdGFWaWV3LCBpbk9mZnNldCk7XG4gICAgICB2YXIgbWF4Tm9uWmVybyA9IHBhcnNlVWludDE2KGluRGF0YVZpZXcsIGluT2Zmc2V0KTtcbiAgICAgIGlmIChtYXhOb25aZXJvID49IEJJVE1BUF9TSVpFKSB7XG4gICAgICAgIHRocm93IFwiU29tZXRoaW5nIGlzIHdyb25nIHdpdGggUElaX0NPTVBSRVNTSU9OIEJJVE1BUF9TSVpFXCI7XG4gICAgICB9XG4gICAgICBpZiAobWluTm9uWmVybyA8PSBtYXhOb25aZXJvKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWF4Tm9uWmVybyAtIG1pbk5vblplcm8gKyAxOyBpKyspIHtcbiAgICAgICAgICBiaXRtYXBbaSArIG1pbk5vblplcm9dID0gcGFyc2VVaW50OChpbkRhdGFWaWV3LCBpbk9mZnNldCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBsdXQgPSBuZXcgVWludDE2QXJyYXkoVVNIT1JUX1JBTkdFKTtcbiAgICAgIHZhciBtYXhWYWx1ZSA9IHJldmVyc2VMdXRGcm9tQml0bWFwKGJpdG1hcCwgbHV0KTtcbiAgICAgIHZhciBsZW5ndGggPSBwYXJzZVVpbnQzMihpbkRhdGFWaWV3LCBpbk9mZnNldCk7XG4gICAgICBodWZVbmNvbXByZXNzKGluZm8uYXJyYXksIGluRGF0YVZpZXcsIGluT2Zmc2V0LCBsZW5ndGgsIG91dEJ1ZmZlciwgb3V0QnVmZmVyRW5kKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5mby5jaGFubmVsczsgKytpKSB7XG4gICAgICAgIHZhciBjZCA9IHBpekNoYW5uZWxEYXRhW2ldO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHBpekNoYW5uZWxEYXRhW2ldLnNpemU7ICsraikge1xuICAgICAgICAgIHdhdjJEZWNvZGUob3V0QnVmZmVyLCBjZC5zdGFydCArIGosIGNkLm54LCBjZC5zaXplLCBjZC5ueSwgY2QubnggKiBjZC5zaXplLCBtYXhWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGFwcGx5THV0KGx1dCwgb3V0QnVmZmVyLCBvdXRCdWZmZXJFbmQpO1xuICAgICAgdmFyIHRtcE9mZnNldDIgPSAwO1xuICAgICAgdmFyIHRtcEJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KG91dEJ1ZmZlci5idWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICBmb3IgKHZhciB5ID0gMDsgeSA8IGluZm8ubGluZXM7IHkrKykge1xuICAgICAgICBmb3IgKHZhciBjID0gMDsgYyA8IGluZm8uY2hhbm5lbHM7IGMrKykge1xuICAgICAgICAgIHZhciBjZCA9IHBpekNoYW5uZWxEYXRhW2NdO1xuICAgICAgICAgIHZhciBuID0gY2QubnggKiBjZC5zaXplO1xuICAgICAgICAgIHZhciBjcCA9IG5ldyBVaW50OEFycmF5KG91dEJ1ZmZlci5idWZmZXIsIGNkLmVuZCAqIElOVDE2X1NJWkUsIG4gKiBJTlQxNl9TSVpFKTtcbiAgICAgICAgICB0bXBCdWZmZXIuc2V0KGNwLCB0bXBPZmZzZXQyKTtcbiAgICAgICAgICB0bXBPZmZzZXQyICs9IG4gKiBJTlQxNl9TSVpFO1xuICAgICAgICAgIGNkLmVuZCArPSBuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IERhdGFWaWV3KHRtcEJ1ZmZlci5idWZmZXIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1bmNvbXByZXNzUFhSKGluZm8pIHtcbiAgICAgIHZhciBjb21wcmVzc2VkID0gaW5mby5hcnJheS5zbGljZShpbmZvLm9mZnNldC52YWx1ZSwgaW5mby5vZmZzZXQudmFsdWUgKyBpbmZvLnNpemUpO1xuICAgICAgdmFyIHJhd0J1ZmZlciA9IHVuemxpYlN5bmMoY29tcHJlc3NlZCk7XG4gICAgICBjb25zdCBzeiA9IGluZm8ubGluZXMgKiBpbmZvLmNoYW5uZWxzICogaW5mby53aWR0aDtcbiAgICAgIGNvbnN0IHRtcEJ1ZmZlciA9IGluZm8udHlwZSA9PSAxID8gbmV3IFVpbnQxNkFycmF5KHN6KSA6IG5ldyBVaW50MzJBcnJheShzeik7XG4gICAgICBsZXQgdG1wQnVmZmVyRW5kID0gMDtcbiAgICAgIGxldCB3cml0ZVB0ciA9IDA7XG4gICAgICBjb25zdCBwdHIgPSBuZXcgQXJyYXkoNCk7XG4gICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IGluZm8ubGluZXM7IHkrKykge1xuICAgICAgICBmb3IgKGxldCBjID0gMDsgYyA8IGluZm8uY2hhbm5lbHM7IGMrKykge1xuICAgICAgICAgIGxldCBwaXhlbCA9IDA7XG4gICAgICAgICAgc3dpdGNoIChpbmZvLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgcHRyWzBdID0gdG1wQnVmZmVyRW5kO1xuICAgICAgICAgICAgICBwdHJbMV0gPSBwdHJbMF0gKyBpbmZvLndpZHRoO1xuICAgICAgICAgICAgICB0bXBCdWZmZXJFbmQgPSBwdHJbMV0gKyBpbmZvLndpZHRoO1xuICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGluZm8ud2lkdGg7ICsraikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRpZmYgPSByYXdCdWZmZXJbcHRyWzBdKytdIDw8IDggfCByYXdCdWZmZXJbcHRyWzFdKytdO1xuICAgICAgICAgICAgICAgIHBpeGVsICs9IGRpZmY7XG4gICAgICAgICAgICAgICAgdG1wQnVmZmVyW3dyaXRlUHRyXSA9IHBpeGVsO1xuICAgICAgICAgICAgICAgIHdyaXRlUHRyKys7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgIHB0clswXSA9IHRtcEJ1ZmZlckVuZDtcbiAgICAgICAgICAgICAgcHRyWzFdID0gcHRyWzBdICsgaW5mby53aWR0aDtcbiAgICAgICAgICAgICAgcHRyWzJdID0gcHRyWzFdICsgaW5mby53aWR0aDtcbiAgICAgICAgICAgICAgdG1wQnVmZmVyRW5kID0gcHRyWzJdICsgaW5mby53aWR0aDtcbiAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBpbmZvLndpZHRoOyArK2opIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkaWZmID0gcmF3QnVmZmVyW3B0clswXSsrXSA8PCAyNCB8IHJhd0J1ZmZlcltwdHJbMV0rK10gPDwgMTYgfCByYXdCdWZmZXJbcHRyWzJdKytdIDw8IDg7XG4gICAgICAgICAgICAgICAgcGl4ZWwgKz0gZGlmZjtcbiAgICAgICAgICAgICAgICB0bXBCdWZmZXJbd3JpdGVQdHJdID0gcGl4ZWw7XG4gICAgICAgICAgICAgICAgd3JpdGVQdHIrKztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgRGF0YVZpZXcodG1wQnVmZmVyLmJ1ZmZlcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVuY29tcHJlc3NEV0EoaW5mbykge1xuICAgICAgdmFyIGluRGF0YVZpZXcgPSBpbmZvLnZpZXdlcjtcbiAgICAgIHZhciBpbk9mZnNldCA9IHsgdmFsdWU6IGluZm8ub2Zmc2V0LnZhbHVlIH07XG4gICAgICB2YXIgb3V0QnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoaW5mby53aWR0aCAqIGluZm8ubGluZXMgKiAoaW5mby5jaGFubmVscyAqIGluZm8udHlwZSAqIElOVDE2X1NJWkUpKTtcbiAgICAgIHZhciBkd2FIZWFkZXIgPSB7XG4gICAgICAgIHZlcnNpb246IHBhcnNlSW50NjQoaW5EYXRhVmlldywgaW5PZmZzZXQpLFxuICAgICAgICB1bmtub3duVW5jb21wcmVzc2VkU2l6ZTogcGFyc2VJbnQ2NChpbkRhdGFWaWV3LCBpbk9mZnNldCksXG4gICAgICAgIHVua25vd25Db21wcmVzc2VkU2l6ZTogcGFyc2VJbnQ2NChpbkRhdGFWaWV3LCBpbk9mZnNldCksXG4gICAgICAgIGFjQ29tcHJlc3NlZFNpemU6IHBhcnNlSW50NjQoaW5EYXRhVmlldywgaW5PZmZzZXQpLFxuICAgICAgICBkY0NvbXByZXNzZWRTaXplOiBwYXJzZUludDY0KGluRGF0YVZpZXcsIGluT2Zmc2V0KSxcbiAgICAgICAgcmxlQ29tcHJlc3NlZFNpemU6IHBhcnNlSW50NjQoaW5EYXRhVmlldywgaW5PZmZzZXQpLFxuICAgICAgICBybGVVbmNvbXByZXNzZWRTaXplOiBwYXJzZUludDY0KGluRGF0YVZpZXcsIGluT2Zmc2V0KSxcbiAgICAgICAgcmxlUmF3U2l6ZTogcGFyc2VJbnQ2NChpbkRhdGFWaWV3LCBpbk9mZnNldCksXG4gICAgICAgIHRvdGFsQWNVbmNvbXByZXNzZWRDb3VudDogcGFyc2VJbnQ2NChpbkRhdGFWaWV3LCBpbk9mZnNldCksXG4gICAgICAgIHRvdGFsRGNVbmNvbXByZXNzZWRDb3VudDogcGFyc2VJbnQ2NChpbkRhdGFWaWV3LCBpbk9mZnNldCksXG4gICAgICAgIGFjQ29tcHJlc3Npb246IHBhcnNlSW50NjQoaW5EYXRhVmlldywgaW5PZmZzZXQpXG4gICAgICB9O1xuICAgICAgaWYgKGR3YUhlYWRlci52ZXJzaW9uIDwgMikge1xuICAgICAgICB0aHJvdyBcIkVYUkxvYWRlci5wYXJzZTogXCIgKyBFWFJIZWFkZXIuY29tcHJlc3Npb24gKyBcIiB2ZXJzaW9uIFwiICsgZHdhSGVhZGVyLnZlcnNpb24gKyBcIiBpcyB1bnN1cHBvcnRlZFwiO1xuICAgICAgfVxuICAgICAgdmFyIGNoYW5uZWxSdWxlcyA9IG5ldyBBcnJheSgpO1xuICAgICAgdmFyIHJ1bGVTaXplID0gcGFyc2VVaW50MTYoaW5EYXRhVmlldywgaW5PZmZzZXQpIC0gSU5UMTZfU0laRTtcbiAgICAgIHdoaWxlIChydWxlU2l6ZSA+IDApIHtcbiAgICAgICAgdmFyIG5hbWUgPSBwYXJzZU51bGxUZXJtaW5hdGVkU3RyaW5nKGluRGF0YVZpZXcuYnVmZmVyLCBpbk9mZnNldCk7XG4gICAgICAgIHZhciB2YWx1ZSA9IHBhcnNlVWludDgoaW5EYXRhVmlldywgaW5PZmZzZXQpO1xuICAgICAgICB2YXIgY29tcHJlc3Npb24gPSB2YWx1ZSA+PiAyICYgMztcbiAgICAgICAgdmFyIGNzYyA9ICh2YWx1ZSA+PiA0KSAtIDE7XG4gICAgICAgIHZhciBpbmRleCA9IG5ldyBJbnQ4QXJyYXkoW2NzY10pWzBdO1xuICAgICAgICB2YXIgdHlwZSA9IHBhcnNlVWludDgoaW5EYXRhVmlldywgaW5PZmZzZXQpO1xuICAgICAgICBjaGFubmVsUnVsZXMucHVzaCh7XG4gICAgICAgICAgbmFtZSxcbiAgICAgICAgICBpbmRleCxcbiAgICAgICAgICB0eXBlLFxuICAgICAgICAgIGNvbXByZXNzaW9uXG4gICAgICAgIH0pO1xuICAgICAgICBydWxlU2l6ZSAtPSBuYW1lLmxlbmd0aCArIDM7XG4gICAgICB9XG4gICAgICB2YXIgY2hhbm5lbHMgPSBFWFJIZWFkZXIuY2hhbm5lbHM7XG4gICAgICB2YXIgY2hhbm5lbERhdGEgPSBuZXcgQXJyYXkoaW5mby5jaGFubmVscyk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGluZm8uY2hhbm5lbHM7ICsraSkge1xuICAgICAgICB2YXIgY2QgPSBjaGFubmVsRGF0YVtpXSA9IHt9O1xuICAgICAgICB2YXIgY2hhbm5lbCA9IGNoYW5uZWxzW2ldO1xuICAgICAgICBjZC5uYW1lID0gY2hhbm5lbC5uYW1lO1xuICAgICAgICBjZC5jb21wcmVzc2lvbiA9IFVOS05PV047XG4gICAgICAgIGNkLmRlY29kZWQgPSBmYWxzZTtcbiAgICAgICAgY2QudHlwZSA9IGNoYW5uZWwucGl4ZWxUeXBlO1xuICAgICAgICBjZC5wTGluZWFyID0gY2hhbm5lbC5wTGluZWFyO1xuICAgICAgICBjZC53aWR0aCA9IGluZm8ud2lkdGg7XG4gICAgICAgIGNkLmhlaWdodCA9IGluZm8ubGluZXM7XG4gICAgICB9XG4gICAgICB2YXIgY3NjU2V0ID0ge1xuICAgICAgICBpZHg6IG5ldyBBcnJheSgzKVxuICAgICAgfTtcbiAgICAgIGZvciAodmFyIG9mZnNldDIgPSAwOyBvZmZzZXQyIDwgaW5mby5jaGFubmVsczsgKytvZmZzZXQyKSB7XG4gICAgICAgIHZhciBjZCA9IGNoYW5uZWxEYXRhW29mZnNldDJdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoYW5uZWxSdWxlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIHZhciBydWxlID0gY2hhbm5lbFJ1bGVzW2ldO1xuICAgICAgICAgIGlmIChjZC5uYW1lID09IHJ1bGUubmFtZSkge1xuICAgICAgICAgICAgY2QuY29tcHJlc3Npb24gPSBydWxlLmNvbXByZXNzaW9uO1xuICAgICAgICAgICAgaWYgKHJ1bGUuaW5kZXggPj0gMCkge1xuICAgICAgICAgICAgICBjc2NTZXQuaWR4W3J1bGUuaW5kZXhdID0gb2Zmc2V0MjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNkLm9mZnNldCA9IG9mZnNldDI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZHdhSGVhZGVyLmFjQ29tcHJlc3NlZFNpemUgPiAwKSB7XG4gICAgICAgIHN3aXRjaCAoZHdhSGVhZGVyLmFjQ29tcHJlc3Npb24pIHtcbiAgICAgICAgICBjYXNlIFNUQVRJQ19IVUZGTUFOOlxuICAgICAgICAgICAgdmFyIGFjQnVmZmVyID0gbmV3IFVpbnQxNkFycmF5KGR3YUhlYWRlci50b3RhbEFjVW5jb21wcmVzc2VkQ291bnQpO1xuICAgICAgICAgICAgaHVmVW5jb21wcmVzcyhcbiAgICAgICAgICAgICAgaW5mby5hcnJheSxcbiAgICAgICAgICAgICAgaW5EYXRhVmlldyxcbiAgICAgICAgICAgICAgaW5PZmZzZXQsXG4gICAgICAgICAgICAgIGR3YUhlYWRlci5hY0NvbXByZXNzZWRTaXplLFxuICAgICAgICAgICAgICBhY0J1ZmZlcixcbiAgICAgICAgICAgICAgZHdhSGVhZGVyLnRvdGFsQWNVbmNvbXByZXNzZWRDb3VudFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgREVGTEFURTpcbiAgICAgICAgICAgIHZhciBjb21wcmVzc2VkID0gaW5mby5hcnJheS5zbGljZShpbk9mZnNldC52YWx1ZSwgaW5PZmZzZXQudmFsdWUgKyBkd2FIZWFkZXIudG90YWxBY1VuY29tcHJlc3NlZENvdW50KTtcbiAgICAgICAgICAgIHZhciBkYXRhID0gdW56bGliU3luYyhjb21wcmVzc2VkKTtcbiAgICAgICAgICAgIHZhciBhY0J1ZmZlciA9IG5ldyBVaW50MTZBcnJheShkYXRhLmJ1ZmZlcik7XG4gICAgICAgICAgICBpbk9mZnNldC52YWx1ZSArPSBkd2FIZWFkZXIudG90YWxBY1VuY29tcHJlc3NlZENvdW50O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChkd2FIZWFkZXIuZGNDb21wcmVzc2VkU2l6ZSA+IDApIHtcbiAgICAgICAgdmFyIHpsaWJJbmZvID0ge1xuICAgICAgICAgIGFycmF5OiBpbmZvLmFycmF5LFxuICAgICAgICAgIG9mZnNldDogaW5PZmZzZXQsXG4gICAgICAgICAgc2l6ZTogZHdhSGVhZGVyLmRjQ29tcHJlc3NlZFNpemVcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGRjQnVmZmVyID0gbmV3IFVpbnQxNkFycmF5KHVuY29tcHJlc3NaSVAoemxpYkluZm8pLmJ1ZmZlcik7XG4gICAgICAgIGluT2Zmc2V0LnZhbHVlICs9IGR3YUhlYWRlci5kY0NvbXByZXNzZWRTaXplO1xuICAgICAgfVxuICAgICAgaWYgKGR3YUhlYWRlci5ybGVSYXdTaXplID4gMCkge1xuICAgICAgICB2YXIgY29tcHJlc3NlZCA9IGluZm8uYXJyYXkuc2xpY2UoaW5PZmZzZXQudmFsdWUsIGluT2Zmc2V0LnZhbHVlICsgZHdhSGVhZGVyLnJsZUNvbXByZXNzZWRTaXplKTtcbiAgICAgICAgdmFyIGRhdGEgPSB1bnpsaWJTeW5jKGNvbXByZXNzZWQpO1xuICAgICAgICB2YXIgcmxlQnVmZmVyID0gZGVjb2RlUnVuTGVuZ3RoKGRhdGEuYnVmZmVyKTtcbiAgICAgICAgaW5PZmZzZXQudmFsdWUgKz0gZHdhSGVhZGVyLnJsZUNvbXByZXNzZWRTaXplO1xuICAgICAgfVxuICAgICAgdmFyIG91dEJ1ZmZlckVuZCA9IDA7XG4gICAgICB2YXIgcm93T2Zmc2V0cyA9IG5ldyBBcnJheShjaGFubmVsRGF0YS5sZW5ndGgpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByb3dPZmZzZXRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHJvd09mZnNldHNbaV0gPSBuZXcgQXJyYXkoKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIHkgPSAwOyB5IDwgaW5mby5saW5lczsgKyt5KSB7XG4gICAgICAgIGZvciAodmFyIGNoYW4gPSAwOyBjaGFuIDwgY2hhbm5lbERhdGEubGVuZ3RoOyArK2NoYW4pIHtcbiAgICAgICAgICByb3dPZmZzZXRzW2NoYW5dLnB1c2gob3V0QnVmZmVyRW5kKTtcbiAgICAgICAgICBvdXRCdWZmZXJFbmQgKz0gY2hhbm5lbERhdGFbY2hhbl0ud2lkdGggKiBpbmZvLnR5cGUgKiBJTlQxNl9TSVpFO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBsb3NzeURjdERlY29kZShjc2NTZXQsIHJvd09mZnNldHMsIGNoYW5uZWxEYXRhLCBhY0J1ZmZlciwgZGNCdWZmZXIsIG91dEJ1ZmZlcik7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoYW5uZWxEYXRhLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBjZCA9IGNoYW5uZWxEYXRhW2ldO1xuICAgICAgICBpZiAoY2QuZGVjb2RlZClcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgc3dpdGNoIChjZC5jb21wcmVzc2lvbikge1xuICAgICAgICAgIGNhc2UgUkxFOlxuICAgICAgICAgICAgdmFyIHJvdyA9IDA7XG4gICAgICAgICAgICB2YXIgcmxlT2Zmc2V0ID0gMDtcbiAgICAgICAgICAgIGZvciAodmFyIHkgPSAwOyB5IDwgaW5mby5saW5lczsgKyt5KSB7XG4gICAgICAgICAgICAgIHZhciByb3dPZmZzZXRCeXRlcyA9IHJvd09mZnNldHNbaV1bcm93XTtcbiAgICAgICAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCBjZC53aWR0aDsgKyt4KSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgYnl0ZSA9IDA7IGJ5dGUgPCBJTlQxNl9TSVpFICogY2QudHlwZTsgKytieXRlKSB7XG4gICAgICAgICAgICAgICAgICBvdXRCdWZmZXJbcm93T2Zmc2V0Qnl0ZXMrK10gPSBybGVCdWZmZXJbcmxlT2Zmc2V0ICsgYnl0ZSAqIGNkLndpZHRoICogY2QuaGVpZ2h0XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmxlT2Zmc2V0Kys7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcm93Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIExPU1NZX0RDVDpcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgXCJFWFJMb2FkZXIucGFyc2U6IHVuc3VwcG9ydGVkIGNoYW5uZWwgY29tcHJlc3Npb25cIjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBEYXRhVmlldyhvdXRCdWZmZXIuYnVmZmVyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGFyc2VOdWxsVGVybWluYXRlZFN0cmluZyhidWZmZXIyLCBvZmZzZXQyKSB7XG4gICAgICB2YXIgdWludEJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlcjIpO1xuICAgICAgdmFyIGVuZE9mZnNldCA9IDA7XG4gICAgICB3aGlsZSAodWludEJ1ZmZlcltvZmZzZXQyLnZhbHVlICsgZW5kT2Zmc2V0XSAhPSAwKSB7XG4gICAgICAgIGVuZE9mZnNldCArPSAxO1xuICAgICAgfVxuICAgICAgdmFyIHN0cmluZ1ZhbHVlID0gbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKHVpbnRCdWZmZXIuc2xpY2Uob2Zmc2V0Mi52YWx1ZSwgb2Zmc2V0Mi52YWx1ZSArIGVuZE9mZnNldCkpO1xuICAgICAgb2Zmc2V0Mi52YWx1ZSA9IG9mZnNldDIudmFsdWUgKyBlbmRPZmZzZXQgKyAxO1xuICAgICAgcmV0dXJuIHN0cmluZ1ZhbHVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwYXJzZUZpeGVkTGVuZ3RoU3RyaW5nKGJ1ZmZlcjIsIG9mZnNldDIsIHNpemUpIHtcbiAgICAgIHZhciBzdHJpbmdWYWx1ZSA9IG5ldyBUZXh0RGVjb2RlcigpLmRlY29kZShuZXcgVWludDhBcnJheShidWZmZXIyKS5zbGljZShvZmZzZXQyLnZhbHVlLCBvZmZzZXQyLnZhbHVlICsgc2l6ZSkpO1xuICAgICAgb2Zmc2V0Mi52YWx1ZSA9IG9mZnNldDIudmFsdWUgKyBzaXplO1xuICAgICAgcmV0dXJuIHN0cmluZ1ZhbHVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwYXJzZVJhdGlvbmFsKGRhdGFWaWV3LCBvZmZzZXQyKSB7XG4gICAgICB2YXIgeCA9IHBhcnNlSW50MzIoZGF0YVZpZXcsIG9mZnNldDIpO1xuICAgICAgdmFyIHkgPSBwYXJzZVVpbnQzMihkYXRhVmlldywgb2Zmc2V0Mik7XG4gICAgICByZXR1cm4gW3gsIHldO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwYXJzZVRpbWVjb2RlKGRhdGFWaWV3LCBvZmZzZXQyKSB7XG4gICAgICB2YXIgeCA9IHBhcnNlVWludDMyKGRhdGFWaWV3LCBvZmZzZXQyKTtcbiAgICAgIHZhciB5ID0gcGFyc2VVaW50MzIoZGF0YVZpZXcsIG9mZnNldDIpO1xuICAgICAgcmV0dXJuIFt4LCB5XTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGFyc2VJbnQzMihkYXRhVmlldywgb2Zmc2V0Mikge1xuICAgICAgdmFyIEludDMyID0gZGF0YVZpZXcuZ2V0SW50MzIob2Zmc2V0Mi52YWx1ZSwgdHJ1ZSk7XG4gICAgICBvZmZzZXQyLnZhbHVlID0gb2Zmc2V0Mi52YWx1ZSArIElOVDMyX1NJWkU7XG4gICAgICByZXR1cm4gSW50MzI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBhcnNlVWludDMyKGRhdGFWaWV3LCBvZmZzZXQyKSB7XG4gICAgICB2YXIgVWludDMyID0gZGF0YVZpZXcuZ2V0VWludDMyKG9mZnNldDIudmFsdWUsIHRydWUpO1xuICAgICAgb2Zmc2V0Mi52YWx1ZSA9IG9mZnNldDIudmFsdWUgKyBJTlQzMl9TSVpFO1xuICAgICAgcmV0dXJuIFVpbnQzMjtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGFyc2VVaW50OEFycmF5KHVJbnQ4QXJyYXkyLCBvZmZzZXQyKSB7XG4gICAgICB2YXIgVWludDggPSB1SW50OEFycmF5MltvZmZzZXQyLnZhbHVlXTtcbiAgICAgIG9mZnNldDIudmFsdWUgPSBvZmZzZXQyLnZhbHVlICsgSU5UOF9TSVpFO1xuICAgICAgcmV0dXJuIFVpbnQ4O1xuICAgIH1cbiAgICBmdW5jdGlvbiBwYXJzZVVpbnQ4KGRhdGFWaWV3LCBvZmZzZXQyKSB7XG4gICAgICB2YXIgVWludDggPSBkYXRhVmlldy5nZXRVaW50OChvZmZzZXQyLnZhbHVlKTtcbiAgICAgIG9mZnNldDIudmFsdWUgPSBvZmZzZXQyLnZhbHVlICsgSU5UOF9TSVpFO1xuICAgICAgcmV0dXJuIFVpbnQ4O1xuICAgIH1cbiAgICBjb25zdCBwYXJzZUludDY0ID0gZnVuY3Rpb24oZGF0YVZpZXcsIG9mZnNldDIpIHtcbiAgICAgIGxldCBpbnQ7XG4gICAgICBpZiAoXCJnZXRCaWdJbnQ2NFwiIGluIERhdGFWaWV3LnByb3RvdHlwZSkge1xuICAgICAgICBpbnQgPSBOdW1iZXIoZGF0YVZpZXcuZ2V0QmlnSW50NjQob2Zmc2V0Mi52YWx1ZSwgdHJ1ZSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW50ID0gZGF0YVZpZXcuZ2V0VWludDMyKG9mZnNldDIudmFsdWUgKyA0LCB0cnVlKSArIE51bWJlcihkYXRhVmlldy5nZXRVaW50MzIob2Zmc2V0Mi52YWx1ZSwgdHJ1ZSkgPDwgMzIpO1xuICAgICAgfVxuICAgICAgb2Zmc2V0Mi52YWx1ZSArPSBVTE9OR19TSVpFO1xuICAgICAgcmV0dXJuIGludDtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIHBhcnNlRmxvYXQzMihkYXRhVmlldywgb2Zmc2V0Mikge1xuICAgICAgdmFyIGZsb2F0ID0gZGF0YVZpZXcuZ2V0RmxvYXQzMihvZmZzZXQyLnZhbHVlLCB0cnVlKTtcbiAgICAgIG9mZnNldDIudmFsdWUgKz0gRkxPQVQzMl9TSVpFO1xuICAgICAgcmV0dXJuIGZsb2F0O1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZWNvZGVGbG9hdDMyKGRhdGFWaWV3LCBvZmZzZXQyKSB7XG4gICAgICByZXR1cm4gRGF0YVV0aWxzLnRvSGFsZkZsb2F0KHBhcnNlRmxvYXQzMihkYXRhVmlldywgb2Zmc2V0MikpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZWNvZGVGbG9hdDE2KGJpbmFyeSkge1xuICAgICAgdmFyIGV4cG9uZW50ID0gKGJpbmFyeSAmIDMxNzQ0KSA+PiAxMCwgZnJhY3Rpb24gPSBiaW5hcnkgJiAxMDIzO1xuICAgICAgcmV0dXJuIChiaW5hcnkgPj4gMTUgPyAtMSA6IDEpICogKGV4cG9uZW50ID8gZXhwb25lbnQgPT09IDMxID8gZnJhY3Rpb24gPyBOYU4gOiBJbmZpbml0eSA6IE1hdGgucG93KDIsIGV4cG9uZW50IC0gMTUpICogKDEgKyBmcmFjdGlvbiAvIDEwMjQpIDogNjEwMzUxNTYyNWUtMTQgKiAoZnJhY3Rpb24gLyAxMDI0KSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBhcnNlVWludDE2KGRhdGFWaWV3LCBvZmZzZXQyKSB7XG4gICAgICB2YXIgVWludDE2ID0gZGF0YVZpZXcuZ2V0VWludDE2KG9mZnNldDIudmFsdWUsIHRydWUpO1xuICAgICAgb2Zmc2V0Mi52YWx1ZSArPSBJTlQxNl9TSVpFO1xuICAgICAgcmV0dXJuIFVpbnQxNjtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGFyc2VGbG9hdDE2KGJ1ZmZlcjIsIG9mZnNldDIpIHtcbiAgICAgIHJldHVybiBkZWNvZGVGbG9hdDE2KHBhcnNlVWludDE2KGJ1ZmZlcjIsIG9mZnNldDIpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGFyc2VDaGxpc3QoZGF0YVZpZXcsIGJ1ZmZlcjIsIG9mZnNldDIsIHNpemUpIHtcbiAgICAgIHZhciBzdGFydE9mZnNldCA9IG9mZnNldDIudmFsdWU7XG4gICAgICB2YXIgY2hhbm5lbHMgPSBbXTtcbiAgICAgIHdoaWxlIChvZmZzZXQyLnZhbHVlIDwgc3RhcnRPZmZzZXQgKyBzaXplIC0gMSkge1xuICAgICAgICB2YXIgbmFtZSA9IHBhcnNlTnVsbFRlcm1pbmF0ZWRTdHJpbmcoYnVmZmVyMiwgb2Zmc2V0Mik7XG4gICAgICAgIHZhciBwaXhlbFR5cGUgPSBwYXJzZUludDMyKGRhdGFWaWV3LCBvZmZzZXQyKTtcbiAgICAgICAgdmFyIHBMaW5lYXIgPSBwYXJzZVVpbnQ4KGRhdGFWaWV3LCBvZmZzZXQyKTtcbiAgICAgICAgb2Zmc2V0Mi52YWx1ZSArPSAzO1xuICAgICAgICB2YXIgeFNhbXBsaW5nID0gcGFyc2VJbnQzMihkYXRhVmlldywgb2Zmc2V0Mik7XG4gICAgICAgIHZhciB5U2FtcGxpbmcgPSBwYXJzZUludDMyKGRhdGFWaWV3LCBvZmZzZXQyKTtcbiAgICAgICAgY2hhbm5lbHMucHVzaCh7XG4gICAgICAgICAgbmFtZSxcbiAgICAgICAgICBwaXhlbFR5cGUsXG4gICAgICAgICAgcExpbmVhcixcbiAgICAgICAgICB4U2FtcGxpbmcsXG4gICAgICAgICAgeVNhbXBsaW5nXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgb2Zmc2V0Mi52YWx1ZSArPSAxO1xuICAgICAgcmV0dXJuIGNoYW5uZWxzO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwYXJzZUNocm9tYXRpY2l0aWVzKGRhdGFWaWV3LCBvZmZzZXQyKSB7XG4gICAgICB2YXIgcmVkWCA9IHBhcnNlRmxvYXQzMihkYXRhVmlldywgb2Zmc2V0Mik7XG4gICAgICB2YXIgcmVkWSA9IHBhcnNlRmxvYXQzMihkYXRhVmlldywgb2Zmc2V0Mik7XG4gICAgICB2YXIgZ3JlZW5YID0gcGFyc2VGbG9hdDMyKGRhdGFWaWV3LCBvZmZzZXQyKTtcbiAgICAgIHZhciBncmVlblkgPSBwYXJzZUZsb2F0MzIoZGF0YVZpZXcsIG9mZnNldDIpO1xuICAgICAgdmFyIGJsdWVYID0gcGFyc2VGbG9hdDMyKGRhdGFWaWV3LCBvZmZzZXQyKTtcbiAgICAgIHZhciBibHVlWSA9IHBhcnNlRmxvYXQzMihkYXRhVmlldywgb2Zmc2V0Mik7XG4gICAgICB2YXIgd2hpdGVYID0gcGFyc2VGbG9hdDMyKGRhdGFWaWV3LCBvZmZzZXQyKTtcbiAgICAgIHZhciB3aGl0ZVkgPSBwYXJzZUZsb2F0MzIoZGF0YVZpZXcsIG9mZnNldDIpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVkWCxcbiAgICAgICAgcmVkWSxcbiAgICAgICAgZ3JlZW5YLFxuICAgICAgICBncmVlblksXG4gICAgICAgIGJsdWVYLFxuICAgICAgICBibHVlWSxcbiAgICAgICAgd2hpdGVYLFxuICAgICAgICB3aGl0ZVlcbiAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBhcnNlQ29tcHJlc3Npb24oZGF0YVZpZXcsIG9mZnNldDIpIHtcbiAgICAgIHZhciBjb21wcmVzc2lvbkNvZGVzID0gW1xuICAgICAgICBcIk5PX0NPTVBSRVNTSU9OXCIsXG4gICAgICAgIFwiUkxFX0NPTVBSRVNTSU9OXCIsXG4gICAgICAgIFwiWklQU19DT01QUkVTU0lPTlwiLFxuICAgICAgICBcIlpJUF9DT01QUkVTU0lPTlwiLFxuICAgICAgICBcIlBJWl9DT01QUkVTU0lPTlwiLFxuICAgICAgICBcIlBYUjI0X0NPTVBSRVNTSU9OXCIsXG4gICAgICAgIFwiQjQ0X0NPTVBSRVNTSU9OXCIsXG4gICAgICAgIFwiQjQ0QV9DT01QUkVTU0lPTlwiLFxuICAgICAgICBcIkRXQUFfQ09NUFJFU1NJT05cIixcbiAgICAgICAgXCJEV0FCX0NPTVBSRVNTSU9OXCJcbiAgICAgIF07XG4gICAgICB2YXIgY29tcHJlc3Npb24gPSBwYXJzZVVpbnQ4KGRhdGFWaWV3LCBvZmZzZXQyKTtcbiAgICAgIHJldHVybiBjb21wcmVzc2lvbkNvZGVzW2NvbXByZXNzaW9uXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGFyc2VCb3gyaShkYXRhVmlldywgb2Zmc2V0Mikge1xuICAgICAgdmFyIHhNaW4gPSBwYXJzZVVpbnQzMihkYXRhVmlldywgb2Zmc2V0Mik7XG4gICAgICB2YXIgeU1pbiA9IHBhcnNlVWludDMyKGRhdGFWaWV3LCBvZmZzZXQyKTtcbiAgICAgIHZhciB4TWF4ID0gcGFyc2VVaW50MzIoZGF0YVZpZXcsIG9mZnNldDIpO1xuICAgICAgdmFyIHlNYXggPSBwYXJzZVVpbnQzMihkYXRhVmlldywgb2Zmc2V0Mik7XG4gICAgICByZXR1cm4geyB4TWluLCB5TWluLCB4TWF4LCB5TWF4IH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBhcnNlTGluZU9yZGVyKGRhdGFWaWV3LCBvZmZzZXQyKSB7XG4gICAgICB2YXIgbGluZU9yZGVycyA9IFtcIklOQ1JFQVNJTkdfWVwiXTtcbiAgICAgIHZhciBsaW5lT3JkZXIgPSBwYXJzZVVpbnQ4KGRhdGFWaWV3LCBvZmZzZXQyKTtcbiAgICAgIHJldHVybiBsaW5lT3JkZXJzW2xpbmVPcmRlcl07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBhcnNlVjJmKGRhdGFWaWV3LCBvZmZzZXQyKSB7XG4gICAgICB2YXIgeCA9IHBhcnNlRmxvYXQzMihkYXRhVmlldywgb2Zmc2V0Mik7XG4gICAgICB2YXIgeSA9IHBhcnNlRmxvYXQzMihkYXRhVmlldywgb2Zmc2V0Mik7XG4gICAgICByZXR1cm4gW3gsIHldO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwYXJzZVYzZihkYXRhVmlldywgb2Zmc2V0Mikge1xuICAgICAgdmFyIHggPSBwYXJzZUZsb2F0MzIoZGF0YVZpZXcsIG9mZnNldDIpO1xuICAgICAgdmFyIHkgPSBwYXJzZUZsb2F0MzIoZGF0YVZpZXcsIG9mZnNldDIpO1xuICAgICAgdmFyIHogPSBwYXJzZUZsb2F0MzIoZGF0YVZpZXcsIG9mZnNldDIpO1xuICAgICAgcmV0dXJuIFt4LCB5LCB6XTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGFyc2VWYWx1ZShkYXRhVmlldywgYnVmZmVyMiwgb2Zmc2V0MiwgdHlwZSwgc2l6ZSkge1xuICAgICAgaWYgKHR5cGUgPT09IFwic3RyaW5nXCIgfHwgdHlwZSA9PT0gXCJzdHJpbmd2ZWN0b3JcIiB8fCB0eXBlID09PSBcImljY1Byb2ZpbGVcIikge1xuICAgICAgICByZXR1cm4gcGFyc2VGaXhlZExlbmd0aFN0cmluZyhidWZmZXIyLCBvZmZzZXQyLCBzaXplKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJjaGxpc3RcIikge1xuICAgICAgICByZXR1cm4gcGFyc2VDaGxpc3QoZGF0YVZpZXcsIGJ1ZmZlcjIsIG9mZnNldDIsIHNpemUpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBcImNocm9tYXRpY2l0aWVzXCIpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlQ2hyb21hdGljaXRpZXMoZGF0YVZpZXcsIG9mZnNldDIpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBcImNvbXByZXNzaW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlQ29tcHJlc3Npb24oZGF0YVZpZXcsIG9mZnNldDIpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBcImJveDJpXCIpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlQm94MmkoZGF0YVZpZXcsIG9mZnNldDIpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBcImxpbmVPcmRlclwiKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUxpbmVPcmRlcihkYXRhVmlldywgb2Zmc2V0Mik7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwiZmxvYXRcIikge1xuICAgICAgICByZXR1cm4gcGFyc2VGbG9hdDMyKGRhdGFWaWV3LCBvZmZzZXQyKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJ2MmZcIikge1xuICAgICAgICByZXR1cm4gcGFyc2VWMmYoZGF0YVZpZXcsIG9mZnNldDIpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBcInYzZlwiKSB7XG4gICAgICAgIHJldHVybiBwYXJzZVYzZihkYXRhVmlldywgb2Zmc2V0Mik7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwiaW50XCIpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlSW50MzIoZGF0YVZpZXcsIG9mZnNldDIpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBcInJhdGlvbmFsXCIpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlUmF0aW9uYWwoZGF0YVZpZXcsIG9mZnNldDIpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBcInRpbWVjb2RlXCIpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlVGltZWNvZGUoZGF0YVZpZXcsIG9mZnNldDIpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBcInByZXZpZXdcIikge1xuICAgICAgICBvZmZzZXQyLnZhbHVlICs9IHNpemU7XG4gICAgICAgIHJldHVybiBcInNraXBwZWRcIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9mZnNldDIudmFsdWUgKz0gc2l6ZTtcbiAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcGFyc2VIZWFkZXIoZGF0YVZpZXcsIGJ1ZmZlcjIsIG9mZnNldDIpIHtcbiAgICAgIGNvbnN0IEVYUkhlYWRlcjIgPSB7fTtcbiAgICAgIGlmIChkYXRhVmlldy5nZXRVaW50MzIoMCwgdHJ1ZSkgIT0gMjAwMDA2MzApIHtcbiAgICAgICAgdGhyb3cgXCJUSFJFRS5FWFJMb2FkZXI6IHByb3ZpZGVkIGZpbGUgZG9lc24ndCBhcHBlYXIgdG8gYmUgaW4gT3BlbkVYUiBmb3JtYXQuXCI7XG4gICAgICB9XG4gICAgICBFWFJIZWFkZXIyLnZlcnNpb24gPSBkYXRhVmlldy5nZXRVaW50OCg0KTtcbiAgICAgIGNvbnN0IHNwZWMgPSBkYXRhVmlldy5nZXRVaW50OCg1KTtcbiAgICAgIEVYUkhlYWRlcjIuc3BlYyA9IHtcbiAgICAgICAgc2luZ2xlVGlsZTogISEoc3BlYyAmIDIpLFxuICAgICAgICBsb25nTmFtZTogISEoc3BlYyAmIDQpLFxuICAgICAgICBkZWVwRm9ybWF0OiAhIShzcGVjICYgOCksXG4gICAgICAgIG11bHRpUGFydDogISEoc3BlYyAmIDE2KVxuICAgICAgfTtcbiAgICAgIG9mZnNldDIudmFsdWUgPSA4O1xuICAgICAgdmFyIGtlZXBSZWFkaW5nID0gdHJ1ZTtcbiAgICAgIHdoaWxlIChrZWVwUmVhZGluZykge1xuICAgICAgICB2YXIgYXR0cmlidXRlTmFtZSA9IHBhcnNlTnVsbFRlcm1pbmF0ZWRTdHJpbmcoYnVmZmVyMiwgb2Zmc2V0Mik7XG4gICAgICAgIGlmIChhdHRyaWJ1dGVOYW1lID09IDApIHtcbiAgICAgICAgICBrZWVwUmVhZGluZyA9IGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBhdHRyaWJ1dGVUeXBlID0gcGFyc2VOdWxsVGVybWluYXRlZFN0cmluZyhidWZmZXIyLCBvZmZzZXQyKTtcbiAgICAgICAgICB2YXIgYXR0cmlidXRlU2l6ZSA9IHBhcnNlVWludDMyKGRhdGFWaWV3LCBvZmZzZXQyKTtcbiAgICAgICAgICB2YXIgYXR0cmlidXRlVmFsdWUgPSBwYXJzZVZhbHVlKGRhdGFWaWV3LCBidWZmZXIyLCBvZmZzZXQyLCBhdHRyaWJ1dGVUeXBlLCBhdHRyaWJ1dGVTaXplKTtcbiAgICAgICAgICBpZiAoYXR0cmlidXRlVmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGBFWFJMb2FkZXIucGFyc2U6IHNraXBwZWQgdW5rbm93biBoZWFkZXIgYXR0cmlidXRlIHR5cGUgJyR7YXR0cmlidXRlVHlwZX0nLmApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBFWFJIZWFkZXIyW2F0dHJpYnV0ZU5hbWVdID0gYXR0cmlidXRlVmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoKHNwZWMgJiB+NCkgIT0gMCkge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiRVhSSGVhZGVyOlwiLCBFWFJIZWFkZXIyKTtcbiAgICAgICAgdGhyb3cgXCJUSFJFRS5FWFJMb2FkZXI6IHByb3ZpZGVkIGZpbGUgaXMgY3VycmVudGx5IHVuc3VwcG9ydGVkLlwiO1xuICAgICAgfVxuICAgICAgcmV0dXJuIEVYUkhlYWRlcjI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNldHVwRGVjb2RlcihFWFJIZWFkZXIyLCBkYXRhVmlldywgdUludDhBcnJheTIsIG9mZnNldDIsIG91dHB1dFR5cGUpIHtcbiAgICAgIGNvbnN0IEVYUkRlY29kZXIyID0ge1xuICAgICAgICBzaXplOiAwLFxuICAgICAgICB2aWV3ZXI6IGRhdGFWaWV3LFxuICAgICAgICBhcnJheTogdUludDhBcnJheTIsXG4gICAgICAgIG9mZnNldDogb2Zmc2V0MixcbiAgICAgICAgd2lkdGg6IEVYUkhlYWRlcjIuZGF0YVdpbmRvdy54TWF4IC0gRVhSSGVhZGVyMi5kYXRhV2luZG93LnhNaW4gKyAxLFxuICAgICAgICBoZWlnaHQ6IEVYUkhlYWRlcjIuZGF0YVdpbmRvdy55TWF4IC0gRVhSSGVhZGVyMi5kYXRhV2luZG93LnlNaW4gKyAxLFxuICAgICAgICBjaGFubmVsczogRVhSSGVhZGVyMi5jaGFubmVscy5sZW5ndGgsXG4gICAgICAgIGJ5dGVzUGVyTGluZTogbnVsbCxcbiAgICAgICAgbGluZXM6IG51bGwsXG4gICAgICAgIGlucHV0U2l6ZTogbnVsbCxcbiAgICAgICAgdHlwZTogRVhSSGVhZGVyMi5jaGFubmVsc1swXS5waXhlbFR5cGUsXG4gICAgICAgIHVuY29tcHJlc3M6IG51bGwsXG4gICAgICAgIGdldHRlcjogbnVsbCxcbiAgICAgICAgZm9ybWF0OiBudWxsLFxuICAgICAgICBbaGFzQ29sb3JTcGFjZSA/IFwiY29sb3JTcGFjZVwiIDogXCJlbmNvZGluZ1wiXTogbnVsbFxuICAgICAgfTtcbiAgICAgIHN3aXRjaCAoRVhSSGVhZGVyMi5jb21wcmVzc2lvbikge1xuICAgICAgICBjYXNlIFwiTk9fQ09NUFJFU1NJT05cIjpcbiAgICAgICAgICBFWFJEZWNvZGVyMi5saW5lcyA9IDE7XG4gICAgICAgICAgRVhSRGVjb2RlcjIudW5jb21wcmVzcyA9IHVuY29tcHJlc3NSQVc7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJSTEVfQ09NUFJFU1NJT05cIjpcbiAgICAgICAgICBFWFJEZWNvZGVyMi5saW5lcyA9IDE7XG4gICAgICAgICAgRVhSRGVjb2RlcjIudW5jb21wcmVzcyA9IHVuY29tcHJlc3NSTEU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJaSVBTX0NPTVBSRVNTSU9OXCI6XG4gICAgICAgICAgRVhSRGVjb2RlcjIubGluZXMgPSAxO1xuICAgICAgICAgIEVYUkRlY29kZXIyLnVuY29tcHJlc3MgPSB1bmNvbXByZXNzWklQO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiWklQX0NPTVBSRVNTSU9OXCI6XG4gICAgICAgICAgRVhSRGVjb2RlcjIubGluZXMgPSAxNjtcbiAgICAgICAgICBFWFJEZWNvZGVyMi51bmNvbXByZXNzID0gdW5jb21wcmVzc1pJUDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIlBJWl9DT01QUkVTU0lPTlwiOlxuICAgICAgICAgIEVYUkRlY29kZXIyLmxpbmVzID0gMzI7XG4gICAgICAgICAgRVhSRGVjb2RlcjIudW5jb21wcmVzcyA9IHVuY29tcHJlc3NQSVo7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJQWFIyNF9DT01QUkVTU0lPTlwiOlxuICAgICAgICAgIEVYUkRlY29kZXIyLmxpbmVzID0gMTY7XG4gICAgICAgICAgRVhSRGVjb2RlcjIudW5jb21wcmVzcyA9IHVuY29tcHJlc3NQWFI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJEV0FBX0NPTVBSRVNTSU9OXCI6XG4gICAgICAgICAgRVhSRGVjb2RlcjIubGluZXMgPSAzMjtcbiAgICAgICAgICBFWFJEZWNvZGVyMi51bmNvbXByZXNzID0gdW5jb21wcmVzc0RXQTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIkRXQUJfQ09NUFJFU1NJT05cIjpcbiAgICAgICAgICBFWFJEZWNvZGVyMi5saW5lcyA9IDI1NjtcbiAgICAgICAgICBFWFJEZWNvZGVyMi51bmNvbXByZXNzID0gdW5jb21wcmVzc0RXQTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBcIkVYUkxvYWRlci5wYXJzZTogXCIgKyBFWFJIZWFkZXIyLmNvbXByZXNzaW9uICsgXCIgaXMgdW5zdXBwb3J0ZWRcIjtcbiAgICAgIH1cbiAgICAgIEVYUkRlY29kZXIyLnNjYW5saW5lQmxvY2tTaXplID0gRVhSRGVjb2RlcjIubGluZXM7XG4gICAgICBpZiAoRVhSRGVjb2RlcjIudHlwZSA9PSAxKSB7XG4gICAgICAgIHN3aXRjaCAob3V0cHV0VHlwZSkge1xuICAgICAgICAgIGNhc2UgRmxvYXRUeXBlOlxuICAgICAgICAgICAgRVhSRGVjb2RlcjIuZ2V0dGVyID0gcGFyc2VGbG9hdDE2O1xuICAgICAgICAgICAgRVhSRGVjb2RlcjIuaW5wdXRTaXplID0gSU5UMTZfU0laRTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgSGFsZkZsb2F0VHlwZTpcbiAgICAgICAgICAgIEVYUkRlY29kZXIyLmdldHRlciA9IHBhcnNlVWludDE2O1xuICAgICAgICAgICAgRVhSRGVjb2RlcjIuaW5wdXRTaXplID0gSU5UMTZfU0laRTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKEVYUkRlY29kZXIyLnR5cGUgPT0gMikge1xuICAgICAgICBzd2l0Y2ggKG91dHB1dFR5cGUpIHtcbiAgICAgICAgICBjYXNlIEZsb2F0VHlwZTpcbiAgICAgICAgICAgIEVYUkRlY29kZXIyLmdldHRlciA9IHBhcnNlRmxvYXQzMjtcbiAgICAgICAgICAgIEVYUkRlY29kZXIyLmlucHV0U2l6ZSA9IEZMT0FUMzJfU0laRTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgSGFsZkZsb2F0VHlwZTpcbiAgICAgICAgICAgIEVYUkRlY29kZXIyLmdldHRlciA9IGRlY29kZUZsb2F0MzI7XG4gICAgICAgICAgICBFWFJEZWNvZGVyMi5pbnB1dFNpemUgPSBGTE9BVDMyX1NJWkU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IFwiRVhSTG9hZGVyLnBhcnNlOiB1bnN1cHBvcnRlZCBwaXhlbFR5cGUgXCIgKyBFWFJEZWNvZGVyMi50eXBlICsgXCIgZm9yIFwiICsgRVhSSGVhZGVyMi5jb21wcmVzc2lvbiArIFwiLlwiO1xuICAgICAgfVxuICAgICAgRVhSRGVjb2RlcjIuYmxvY2tDb3VudCA9IChFWFJIZWFkZXIyLmRhdGFXaW5kb3cueU1heCArIDEpIC8gRVhSRGVjb2RlcjIuc2NhbmxpbmVCbG9ja1NpemU7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IEVYUkRlY29kZXIyLmJsb2NrQ291bnQ7IGkrKylcbiAgICAgICAgcGFyc2VJbnQ2NChkYXRhVmlldywgb2Zmc2V0Mik7XG4gICAgICBFWFJEZWNvZGVyMi5vdXRwdXRDaGFubmVscyA9IEVYUkRlY29kZXIyLmNoYW5uZWxzID09IDMgPyA0IDogRVhSRGVjb2RlcjIuY2hhbm5lbHM7XG4gICAgICBjb25zdCBzaXplID0gRVhSRGVjb2RlcjIud2lkdGggKiBFWFJEZWNvZGVyMi5oZWlnaHQgKiBFWFJEZWNvZGVyMi5vdXRwdXRDaGFubmVscztcbiAgICAgIHN3aXRjaCAob3V0cHV0VHlwZSkge1xuICAgICAgICBjYXNlIEZsb2F0VHlwZTpcbiAgICAgICAgICBFWFJEZWNvZGVyMi5ieXRlQXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KHNpemUpO1xuICAgICAgICAgIGlmIChFWFJEZWNvZGVyMi5jaGFubmVscyA8IEVYUkRlY29kZXIyLm91dHB1dENoYW5uZWxzKVxuICAgICAgICAgICAgRVhSRGVjb2RlcjIuYnl0ZUFycmF5LmZpbGwoMSwgMCwgc2l6ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgSGFsZkZsb2F0VHlwZTpcbiAgICAgICAgICBFWFJEZWNvZGVyMi5ieXRlQXJyYXkgPSBuZXcgVWludDE2QXJyYXkoc2l6ZSk7XG4gICAgICAgICAgaWYgKEVYUkRlY29kZXIyLmNoYW5uZWxzIDwgRVhSRGVjb2RlcjIub3V0cHV0Q2hhbm5lbHMpXG4gICAgICAgICAgICBFWFJEZWNvZGVyMi5ieXRlQXJyYXkuZmlsbCgxNTM2MCwgMCwgc2l6ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcIlRIUkVFLkVYUkxvYWRlcjogdW5zdXBwb3J0ZWQgdHlwZTogXCIsIG91dHB1dFR5cGUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgRVhSRGVjb2RlcjIuYnl0ZXNQZXJMaW5lID0gRVhSRGVjb2RlcjIud2lkdGggKiBFWFJEZWNvZGVyMi5pbnB1dFNpemUgKiBFWFJEZWNvZGVyMi5jaGFubmVscztcbiAgICAgIGlmIChFWFJEZWNvZGVyMi5vdXRwdXRDaGFubmVscyA9PSA0KVxuICAgICAgICBFWFJEZWNvZGVyMi5mb3JtYXQgPSBSR0JBRm9ybWF0O1xuICAgICAgZWxzZVxuICAgICAgICBFWFJEZWNvZGVyMi5mb3JtYXQgPSBSZWRGb3JtYXQ7XG4gICAgICBpZiAoaGFzQ29sb3JTcGFjZSlcbiAgICAgICAgRVhSRGVjb2RlcjIuY29sb3JTcGFjZSA9IFwic3JnYi1saW5lYXJcIjtcbiAgICAgIGVsc2VcbiAgICAgICAgRVhSRGVjb2RlcjIuZW5jb2RpbmcgPSAzZTM7XG4gICAgICByZXR1cm4gRVhSRGVjb2RlcjI7XG4gICAgfVxuICAgIGNvbnN0IGJ1ZmZlckRhdGFWaWV3ID0gbmV3IERhdGFWaWV3KGJ1ZmZlcik7XG4gICAgY29uc3QgdUludDhBcnJheSA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlcik7XG4gICAgY29uc3Qgb2Zmc2V0ID0geyB2YWx1ZTogMCB9O1xuICAgIGNvbnN0IEVYUkhlYWRlciA9IHBhcnNlSGVhZGVyKGJ1ZmZlckRhdGFWaWV3LCBidWZmZXIsIG9mZnNldCk7XG4gICAgY29uc3QgRVhSRGVjb2RlciA9IHNldHVwRGVjb2RlcihFWFJIZWFkZXIsIGJ1ZmZlckRhdGFWaWV3LCB1SW50OEFycmF5LCBvZmZzZXQsIHRoaXMudHlwZSk7XG4gICAgY29uc3QgdG1wT2Zmc2V0ID0geyB2YWx1ZTogMCB9O1xuICAgIGNvbnN0IGNoYW5uZWxPZmZzZXRzID0geyBSOiAwLCBHOiAxLCBCOiAyLCBBOiAzLCBZOiAwIH07XG4gICAgZm9yIChsZXQgc2NhbmxpbmVCbG9ja0lkeCA9IDA7IHNjYW5saW5lQmxvY2tJZHggPCBFWFJEZWNvZGVyLmhlaWdodCAvIEVYUkRlY29kZXIuc2NhbmxpbmVCbG9ja1NpemU7IHNjYW5saW5lQmxvY2tJZHgrKykge1xuICAgICAgY29uc3QgbGluZSA9IHBhcnNlVWludDMyKGJ1ZmZlckRhdGFWaWV3LCBvZmZzZXQpO1xuICAgICAgRVhSRGVjb2Rlci5zaXplID0gcGFyc2VVaW50MzIoYnVmZmVyRGF0YVZpZXcsIG9mZnNldCk7XG4gICAgICBFWFJEZWNvZGVyLmxpbmVzID0gbGluZSArIEVYUkRlY29kZXIuc2NhbmxpbmVCbG9ja1NpemUgPiBFWFJEZWNvZGVyLmhlaWdodCA/IEVYUkRlY29kZXIuaGVpZ2h0IC0gbGluZSA6IEVYUkRlY29kZXIuc2NhbmxpbmVCbG9ja1NpemU7XG4gICAgICBjb25zdCBpc0NvbXByZXNzZWQgPSBFWFJEZWNvZGVyLnNpemUgPCBFWFJEZWNvZGVyLmxpbmVzICogRVhSRGVjb2Rlci5ieXRlc1BlckxpbmU7XG4gICAgICBjb25zdCB2aWV3ZXIgPSBpc0NvbXByZXNzZWQgPyBFWFJEZWNvZGVyLnVuY29tcHJlc3MoRVhSRGVjb2RlcikgOiB1bmNvbXByZXNzUkFXKEVYUkRlY29kZXIpO1xuICAgICAgb2Zmc2V0LnZhbHVlICs9IEVYUkRlY29kZXIuc2l6ZTtcbiAgICAgIGZvciAobGV0IGxpbmVfeSA9IDA7IGxpbmVfeSA8IEVYUkRlY29kZXIuc2NhbmxpbmVCbG9ja1NpemU7IGxpbmVfeSsrKSB7XG4gICAgICAgIGNvbnN0IHRydWVfeSA9IGxpbmVfeSArIHNjYW5saW5lQmxvY2tJZHggKiBFWFJEZWNvZGVyLnNjYW5saW5lQmxvY2tTaXplO1xuICAgICAgICBpZiAodHJ1ZV95ID49IEVYUkRlY29kZXIuaGVpZ2h0KVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBmb3IgKGxldCBjaGFubmVsSUQgPSAwOyBjaGFubmVsSUQgPCBFWFJEZWNvZGVyLmNoYW5uZWxzOyBjaGFubmVsSUQrKykge1xuICAgICAgICAgIGNvbnN0IGNPZmYgPSBjaGFubmVsT2Zmc2V0c1tFWFJIZWFkZXIuY2hhbm5lbHNbY2hhbm5lbElEXS5uYW1lXTtcbiAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IEVYUkRlY29kZXIud2lkdGg7IHgrKykge1xuICAgICAgICAgICAgdG1wT2Zmc2V0LnZhbHVlID0gKGxpbmVfeSAqIChFWFJEZWNvZGVyLmNoYW5uZWxzICogRVhSRGVjb2Rlci53aWR0aCkgKyBjaGFubmVsSUQgKiBFWFJEZWNvZGVyLndpZHRoICsgeCkgKiBFWFJEZWNvZGVyLmlucHV0U2l6ZTtcbiAgICAgICAgICAgIGNvbnN0IG91dEluZGV4ID0gKEVYUkRlY29kZXIuaGVpZ2h0IC0gMSAtIHRydWVfeSkgKiAoRVhSRGVjb2Rlci53aWR0aCAqIEVYUkRlY29kZXIub3V0cHV0Q2hhbm5lbHMpICsgeCAqIEVYUkRlY29kZXIub3V0cHV0Q2hhbm5lbHMgKyBjT2ZmO1xuICAgICAgICAgICAgRVhSRGVjb2Rlci5ieXRlQXJyYXlbb3V0SW5kZXhdID0gRVhSRGVjb2Rlci5nZXR0ZXIodmlld2VyLCB0bXBPZmZzZXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgaGVhZGVyOiBFWFJIZWFkZXIsXG4gICAgICB3aWR0aDogRVhSRGVjb2Rlci53aWR0aCxcbiAgICAgIGhlaWdodDogRVhSRGVjb2Rlci5oZWlnaHQsXG4gICAgICBkYXRhOiBFWFJEZWNvZGVyLmJ5dGVBcnJheSxcbiAgICAgIGZvcm1hdDogRVhSRGVjb2Rlci5mb3JtYXQsXG4gICAgICBbaGFzQ29sb3JTcGFjZSA/IFwiY29sb3JTcGFjZVwiIDogXCJlbmNvZGluZ1wiXTogRVhSRGVjb2RlcltoYXNDb2xvclNwYWNlID8gXCJjb2xvclNwYWNlXCIgOiBcImVuY29kaW5nXCJdLFxuICAgICAgdHlwZTogdGhpcy50eXBlXG4gICAgfTtcbiAgfVxuICBzZXREYXRhVHlwZSh2YWx1ZSkge1xuICAgIHRoaXMudHlwZSA9IHZhbHVlO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGxvYWQodXJsLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IpIHtcbiAgICBmdW5jdGlvbiBvbkxvYWRDYWxsYmFjayh0ZXh0dXJlLCB0ZXhEYXRhKSB7XG4gICAgICBpZiAoaGFzQ29sb3JTcGFjZSlcbiAgICAgICAgdGV4dHVyZS5jb2xvclNwYWNlID0gdGV4RGF0YS5jb2xvclNwYWNlO1xuICAgICAgZWxzZVxuICAgICAgICB0ZXh0dXJlLmVuY29kaW5nID0gdGV4RGF0YS5lbmNvZGluZztcbiAgICAgIHRleHR1cmUubWluRmlsdGVyID0gTGluZWFyRmlsdGVyO1xuICAgICAgdGV4dHVyZS5tYWdGaWx0ZXIgPSBMaW5lYXJGaWx0ZXI7XG4gICAgICB0ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcyA9IGZhbHNlO1xuICAgICAgdGV4dHVyZS5mbGlwWSA9IGZhbHNlO1xuICAgICAgaWYgKG9uTG9hZClcbiAgICAgICAgb25Mb2FkKHRleHR1cmUsIHRleERhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gc3VwZXIubG9hZCh1cmwsIG9uTG9hZENhbGxiYWNrLCBvblByb2dyZXNzLCBvbkVycm9yKTtcbiAgfVxufVxuZXhwb3J0IHtcbiAgRVhSTG9hZGVyXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RVhSTG9hZGVyLmpzLm1hcFxuIl0sIm5hbWVzIjpbIkRhdGFUZXh0dXJlTG9hZGVyIiwiSGFsZkZsb2F0VHlwZSIsIkZsb2F0VHlwZSIsIlJHQkFGb3JtYXQiLCJSZWRGb3JtYXQiLCJMaW5lYXJGaWx0ZXIiLCJEYXRhVXRpbHMiLCJ1bnpsaWJTeW5jIiwidmVyc2lvbiIsImhhc0NvbG9yU3BhY2UiLCJFWFJMb2FkZXIiLCJjb25zdHJ1Y3RvciIsIm1hbmFnZXIiLCJ0eXBlIiwicGFyc2UiLCJidWZmZXIiLCJVU0hPUlRfUkFOR0UiLCJCSVRNQVBfU0laRSIsIkhVRl9FTkNCSVRTIiwiSFVGX0RFQ0JJVFMiLCJIVUZfRU5DU0laRSIsIkhVRl9ERUNTSVpFIiwiSFVGX0RFQ01BU0siLCJOQklUUyIsIkFfT0ZGU0VUIiwiTU9EX01BU0siLCJTSE9SVF9aRVJPQ09ERV9SVU4iLCJMT05HX1pFUk9DT0RFX1JVTiIsIlNIT1JURVNUX0xPTkdfUlVOIiwiVUxPTkdfU0laRSIsIkZMT0FUMzJfU0laRSIsIklOVDMyX1NJWkUiLCJJTlQxNl9TSVpFIiwiSU5UOF9TSVpFIiwiU1RBVElDX0hVRkZNQU4iLCJERUZMQVRFIiwiVU5LTk9XTiIsIkxPU1NZX0RDVCIsIlJMRSIsImxvZ0Jhc2UiLCJNYXRoIiwicG93IiwicmV2ZXJzZUx1dEZyb21CaXRtYXAiLCJiaXRtYXAiLCJsdXQiLCJrIiwiaSIsIm4iLCJodWZDbGVhckRlY1RhYmxlIiwiaGRlYyIsImxlbiIsImxpdCIsInAiLCJnZXRCaXRzUmV0dXJuIiwibCIsImMiLCJsYyIsImdldEJpdHMiLCJuQml0cyIsInVJbnQ4QXJyYXkyIiwiaW5PZmZzZXQiLCJwYXJzZVVpbnQ4QXJyYXkiLCJodWZUYWJsZUJ1ZmZlciIsIkFycmF5IiwiaHVmQ2Fub25pY2FsQ29kZVRhYmxlIiwiaGNvZGUiLCJuYyIsImh1ZlVucGFja0VuY1RhYmxlIiwiaW5EYXRhVmlldyIsIm5pIiwiaW0iLCJpTSIsInZhbHVlIiwiemVydW4iLCJodWZMZW5ndGgiLCJjb2RlIiwiaHVmQ29kZSIsImh1ZkJ1aWxkRGVjVGFibGUiLCJoZGVjb2QiLCJwbCIsInBsT2Zmc2V0IiwiZ2V0Q2hhclJldHVybiIsImdldENoYXIiLCJnZXRDb2RlUmV0dXJuIiwiZ2V0Q29kZSIsInBvIiwicmxjIiwib3V0QnVmZmVyIiwib3V0QnVmZmVyT2Zmc2V0Iiwib3V0QnVmZmVyRW5kT2Zmc2V0IiwiY3MiLCJVaW50OEFycmF5IiwicyIsIlVJbnQxNiIsIkludDE2IiwicmVmIiwid2RlYzE0UmV0dXJuIiwiYSIsImIiLCJ3ZGVjMTQiLCJoIiwibHMiLCJocyIsImhpIiwiYWkiLCJhcyIsImJzIiwid2RlYzE2IiwibSIsImQiLCJiYiIsImFhIiwid2F2MkRlY29kZSIsImJ1ZmZlcjIiLCJqIiwibngiLCJveCIsIm55Iiwib3kiLCJteCIsIncxNCIsInAyIiwicHkiLCJleSIsIm95MSIsIm95MiIsIm94MSIsIm94MiIsImkwMCIsImkwMSIsImkxMCIsImkxMSIsInB4IiwiZXgiLCJwMDEiLCJwMTAiLCJwMTEiLCJodWZEZWNvZGUiLCJlbmNvZGluZ1RhYmxlIiwiZGVjb2RpbmdUYWJsZSIsIm5vIiwib3V0T2Zmc2V0IiwiaW5PZmZzZXRFbmQiLCJ0cnVuYyIsImluZGV4IiwiaHVmVW5jb21wcmVzcyIsIm5Db21wcmVzc2VkIiwiblJhdyIsImluaXRpYWxJbk9mZnNldCIsInBhcnNlVWludDMyIiwiZnJlcSIsImFwcGx5THV0IiwiZGF0YSIsIm5EYXRhIiwicHJlZGljdG9yIiwic291cmNlIiwidCIsImxlbmd0aCIsImludGVybGVhdmVTY2FsYXIiLCJvdXQiLCJ0MSIsInQyIiwiZmxvb3IiLCJzdG9wIiwiZGVjb2RlUnVuTGVuZ3RoIiwic2l6ZSIsImJ5dGVMZW5ndGgiLCJyZWFkZXIiLCJEYXRhVmlldyIsImdldEludDgiLCJjb3VudCIsInB1c2giLCJnZXRVaW50OCIsImxvc3N5RGN0RGVjb2RlIiwiY3NjU2V0Iiwicm93UHRycyIsImNoYW5uZWxEYXRhIiwiYWNCdWZmZXIiLCJkY0J1ZmZlciIsImRhdGFWaWV3Iiwid2lkdGgiLCJpZHgiLCJoZWlnaHQiLCJudW1Db21wIiwibnVtRnVsbEJsb2Nrc1giLCJudW1CbG9ja3NYIiwiY2VpbCIsIm51bUJsb2Nrc1kiLCJsZWZ0b3ZlclgiLCJsZWZ0b3ZlclkiLCJjdXJyQWNDb21wIiwiY3VyckRjQ29tcCIsImRjdERhdGEiLCJoYWxmWmlnQmxvY2siLCJyb3dCbG9jayIsInJvd09mZnNldHMiLCJjb21wMiIsIkZsb2F0MzJBcnJheSIsIlVpbnQxNkFycmF5IiwiYmxvY2t5IiwibWF4WSIsIm1heFgiLCJibG9ja3giLCJmaWxsIiwidW5SbGVBQyIsInVuWmlnWmFnIiwiZGN0SW52ZXJzZSIsImNzYzcwOUludmVyc2UiLCJjb252ZXJ0VG9IYWxmIiwib2Zmc2V0MiIsInR5cGUyIiwieTIiLCJzcmMiLCJzZXRVaW50MTYiLCJvZmZzZXQzIiwieDIiLCJoYWxmUm93IiwiY29tcCIsImRlY29kZWQiLCJ5IiwieCIsImdldFVpbnQxNiIsInNldEZsb2F0MzIiLCJkZWNvZGVGbG9hdDE2IiwiYWNWYWx1ZSIsImRjdENvbXAiLCJkc3QiLCJjb3MiLCJlIiwiZiIsImciLCJhbHBoYSIsImJldGEiLCJ0aGV0YSIsImdhbW1hIiwicm93Iiwicm93UHRyIiwiY29sdW1uIiwiY2IiLCJjciIsInRvSGFsZkZsb2F0IiwidG9MaW5lYXIiLCJmbG9hdCIsInNpZ24iLCJhYnMiLCJ1bmNvbXByZXNzUkFXIiwiaW5mbyIsImFycmF5Iiwib2Zmc2V0IiwidW5jb21wcmVzc1JMRSIsImNvbXByZXNzZWQiLCJ2aWV3ZXIiLCJzbGljZSIsInJhd0J1ZmZlciIsInRtcEJ1ZmZlciIsInVuY29tcHJlc3NaSVAiLCJ1bmNvbXByZXNzUElaIiwic2NhbmxpbmVCbG9ja1NpemUiLCJjaGFubmVscyIsIm91dEJ1ZmZlckVuZCIsInBpekNoYW5uZWxEYXRhIiwibGluZXMiLCJtaW5Ob25aZXJvIiwicGFyc2VVaW50MTYiLCJtYXhOb25aZXJvIiwicGFyc2VVaW50OCIsIm1heFZhbHVlIiwiY2QiLCJzdGFydCIsInRtcE9mZnNldDIiLCJjcCIsImVuZCIsInNldCIsInVuY29tcHJlc3NQWFIiLCJzeiIsIlVpbnQzMkFycmF5IiwidG1wQnVmZmVyRW5kIiwid3JpdGVQdHIiLCJwdHIiLCJwaXhlbCIsImRpZmYiLCJ1bmNvbXByZXNzRFdBIiwiZHdhSGVhZGVyIiwicGFyc2VJbnQ2NCIsInVua25vd25VbmNvbXByZXNzZWRTaXplIiwidW5rbm93bkNvbXByZXNzZWRTaXplIiwiYWNDb21wcmVzc2VkU2l6ZSIsImRjQ29tcHJlc3NlZFNpemUiLCJybGVDb21wcmVzc2VkU2l6ZSIsInJsZVVuY29tcHJlc3NlZFNpemUiLCJybGVSYXdTaXplIiwidG90YWxBY1VuY29tcHJlc3NlZENvdW50IiwidG90YWxEY1VuY29tcHJlc3NlZENvdW50IiwiYWNDb21wcmVzc2lvbiIsIkVYUkhlYWRlciIsImNvbXByZXNzaW9uIiwiY2hhbm5lbFJ1bGVzIiwicnVsZVNpemUiLCJuYW1lIiwicGFyc2VOdWxsVGVybWluYXRlZFN0cmluZyIsImNzYyIsIkludDhBcnJheSIsImNoYW5uZWwiLCJwaXhlbFR5cGUiLCJwTGluZWFyIiwicnVsZSIsInpsaWJJbmZvIiwicmxlQnVmZmVyIiwiY2hhbiIsInJsZU9mZnNldCIsInJvd09mZnNldEJ5dGVzIiwiYnl0ZSIsInVpbnRCdWZmZXIiLCJlbmRPZmZzZXQiLCJzdHJpbmdWYWx1ZSIsIlRleHREZWNvZGVyIiwiZGVjb2RlIiwicGFyc2VGaXhlZExlbmd0aFN0cmluZyIsInBhcnNlUmF0aW9uYWwiLCJwYXJzZUludDMyIiwicGFyc2VUaW1lY29kZSIsIkludDMyIiwiZ2V0SW50MzIiLCJVaW50MzIiLCJnZXRVaW50MzIiLCJVaW50OCIsImludCIsInByb3RvdHlwZSIsIk51bWJlciIsImdldEJpZ0ludDY0IiwicGFyc2VGbG9hdDMyIiwiZ2V0RmxvYXQzMiIsImRlY29kZUZsb2F0MzIiLCJiaW5hcnkiLCJleHBvbmVudCIsImZyYWN0aW9uIiwiTmFOIiwiSW5maW5pdHkiLCJVaW50MTYiLCJwYXJzZUZsb2F0MTYiLCJwYXJzZUNobGlzdCIsInN0YXJ0T2Zmc2V0IiwieFNhbXBsaW5nIiwieVNhbXBsaW5nIiwicGFyc2VDaHJvbWF0aWNpdGllcyIsInJlZFgiLCJyZWRZIiwiZ3JlZW5YIiwiZ3JlZW5ZIiwiYmx1ZVgiLCJibHVlWSIsIndoaXRlWCIsIndoaXRlWSIsInBhcnNlQ29tcHJlc3Npb24iLCJjb21wcmVzc2lvbkNvZGVzIiwicGFyc2VCb3gyaSIsInhNaW4iLCJ5TWluIiwieE1heCIsInlNYXgiLCJwYXJzZUxpbmVPcmRlciIsImxpbmVPcmRlcnMiLCJsaW5lT3JkZXIiLCJwYXJzZVYyZiIsInBhcnNlVjNmIiwieiIsInBhcnNlVmFsdWUiLCJwYXJzZUhlYWRlciIsIkVYUkhlYWRlcjIiLCJzcGVjIiwic2luZ2xlVGlsZSIsImxvbmdOYW1lIiwiZGVlcEZvcm1hdCIsIm11bHRpUGFydCIsImtlZXBSZWFkaW5nIiwiYXR0cmlidXRlTmFtZSIsImF0dHJpYnV0ZVR5cGUiLCJhdHRyaWJ1dGVTaXplIiwiYXR0cmlidXRlVmFsdWUiLCJjb25zb2xlIiwid2FybiIsImVycm9yIiwic2V0dXBEZWNvZGVyIiwib3V0cHV0VHlwZSIsIkVYUkRlY29kZXIyIiwiZGF0YVdpbmRvdyIsImJ5dGVzUGVyTGluZSIsImlucHV0U2l6ZSIsInVuY29tcHJlc3MiLCJnZXR0ZXIiLCJmb3JtYXQiLCJibG9ja0NvdW50Iiwib3V0cHV0Q2hhbm5lbHMiLCJieXRlQXJyYXkiLCJjb2xvclNwYWNlIiwiZW5jb2RpbmciLCJidWZmZXJEYXRhVmlldyIsInVJbnQ4QXJyYXkiLCJFWFJEZWNvZGVyIiwidG1wT2Zmc2V0IiwiY2hhbm5lbE9mZnNldHMiLCJSIiwiRyIsIkIiLCJBIiwiWSIsInNjYW5saW5lQmxvY2tJZHgiLCJsaW5lIiwiaXNDb21wcmVzc2VkIiwibGluZV95IiwidHJ1ZV95IiwiY2hhbm5lbElEIiwiY09mZiIsIm91dEluZGV4IiwiaGVhZGVyIiwic2V0RGF0YVR5cGUiLCJsb2FkIiwidXJsIiwib25Mb2FkIiwib25Qcm9ncmVzcyIsIm9uRXJyb3IiLCJvbkxvYWRDYWxsYmFjayIsInRleHR1cmUiLCJ0ZXhEYXRhIiwibWluRmlsdGVyIiwibWFnRmlsdGVyIiwiZ2VuZXJhdGVNaXBtYXBzIiwiZmxpcFkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/three-stdlib/loaders/EXRLoader.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/three-stdlib/loaders/RGBELoader.js":
/*!*********************************************************!*\
  !*** ./node_modules/three-stdlib/loaders/RGBELoader.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RGBELoader: () => (/* binding */ RGBELoader)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n\nclass RGBELoader extends three__WEBPACK_IMPORTED_MODULE_0__.DataTextureLoader {\n    constructor(manager){\n        super(manager);\n        this.type = three__WEBPACK_IMPORTED_MODULE_0__.HalfFloatType;\n    }\n    // adapted from http://www.graphics.cornell.edu/~bjw/rgbe.html\n    parse(buffer) {\n        const rgbe_read_error = 1, rgbe_write_error = 2, rgbe_format_error = 3, rgbe_memory_error = 4, rgbe_error = function(rgbe_error_code, msg) {\n            switch(rgbe_error_code){\n                case rgbe_read_error:\n                    throw new Error(\"THREE.RGBELoader: Read Error: \" + (msg || \"\"));\n                case rgbe_write_error:\n                    throw new Error(\"THREE.RGBELoader: Write Error: \" + (msg || \"\"));\n                case rgbe_format_error:\n                    throw new Error(\"THREE.RGBELoader: Bad File Format: \" + (msg || \"\"));\n                default:\n                case rgbe_memory_error:\n                    throw new Error(\"THREE.RGBELoader: Memory Error: \" + (msg || \"\"));\n            }\n        }, RGBE_VALID_PROGRAMTYPE = 1, RGBE_VALID_FORMAT = 2, RGBE_VALID_DIMENSIONS = 4, NEWLINE = \"\\n\", fgets = function(buffer2, lineLimit, consume) {\n            const chunkSize = 128;\n            lineLimit = !lineLimit ? 1024 : lineLimit;\n            let p = buffer2.pos, i = -1, len = 0, s = \"\", chunk = String.fromCharCode.apply(null, new Uint16Array(buffer2.subarray(p, p + chunkSize)));\n            while(0 > (i = chunk.indexOf(NEWLINE)) && len < lineLimit && p < buffer2.byteLength){\n                s += chunk;\n                len += chunk.length;\n                p += chunkSize;\n                chunk += String.fromCharCode.apply(null, new Uint16Array(buffer2.subarray(p, p + chunkSize)));\n            }\n            if (-1 < i) {\n                if (false !== consume) buffer2.pos += len + i + 1;\n                return s + chunk.slice(0, i);\n            }\n            return false;\n        }, RGBE_ReadHeader = function(buffer2) {\n            const magic_token_re = /^#\\?(\\S+)/, gamma_re = /^\\s*GAMMA\\s*=\\s*(\\d+(\\.\\d+)?)\\s*$/, exposure_re = /^\\s*EXPOSURE\\s*=\\s*(\\d+(\\.\\d+)?)\\s*$/, format_re = /^\\s*FORMAT=(\\S+)\\s*$/, dimensions_re = /^\\s*\\-Y\\s+(\\d+)\\s+\\+X\\s+(\\d+)\\s*$/, header = {\n                valid: 0,\n                string: \"\",\n                comments: \"\",\n                programtype: \"RGBE\",\n                format: \"\",\n                gamma: 1,\n                exposure: 1,\n                width: 0,\n                height: 0\n            };\n            let line, match;\n            if (buffer2.pos >= buffer2.byteLength || !(line = fgets(buffer2))) {\n                rgbe_error(rgbe_read_error, \"no header found\");\n            }\n            if (!(match = line.match(magic_token_re))) {\n                rgbe_error(rgbe_format_error, \"bad initial token\");\n            }\n            header.valid |= RGBE_VALID_PROGRAMTYPE;\n            header.programtype = match[1];\n            header.string += line + \"\\n\";\n            while(true){\n                line = fgets(buffer2);\n                if (false === line) break;\n                header.string += line + \"\\n\";\n                if (\"#\" === line.charAt(0)) {\n                    header.comments += line + \"\\n\";\n                    continue;\n                }\n                if (match = line.match(gamma_re)) {\n                    header.gamma = parseFloat(match[1]);\n                }\n                if (match = line.match(exposure_re)) {\n                    header.exposure = parseFloat(match[1]);\n                }\n                if (match = line.match(format_re)) {\n                    header.valid |= RGBE_VALID_FORMAT;\n                    header.format = match[1];\n                }\n                if (match = line.match(dimensions_re)) {\n                    header.valid |= RGBE_VALID_DIMENSIONS;\n                    header.height = parseInt(match[1], 10);\n                    header.width = parseInt(match[2], 10);\n                }\n                if (header.valid & RGBE_VALID_FORMAT && header.valid & RGBE_VALID_DIMENSIONS) break;\n            }\n            if (!(header.valid & RGBE_VALID_FORMAT)) {\n                rgbe_error(rgbe_format_error, \"missing format specifier\");\n            }\n            if (!(header.valid & RGBE_VALID_DIMENSIONS)) {\n                rgbe_error(rgbe_format_error, \"missing image size specifier\");\n            }\n            return header;\n        }, RGBE_ReadPixels_RLE = function(buffer2, w2, h2) {\n            const scanline_width = w2;\n            if (// run length encoding is not allowed so read flat\n            scanline_width < 8 || scanline_width > 32767 || // this file is not run length encoded\n            2 !== buffer2[0] || 2 !== buffer2[1] || buffer2[2] & 128) {\n                return new Uint8Array(buffer2);\n            }\n            if (scanline_width !== (buffer2[2] << 8 | buffer2[3])) {\n                rgbe_error(rgbe_format_error, \"wrong scanline width\");\n            }\n            const data_rgba = new Uint8Array(4 * w2 * h2);\n            if (!data_rgba.length) {\n                rgbe_error(rgbe_memory_error, \"unable to allocate buffer space\");\n            }\n            let offset = 0, pos = 0;\n            const ptr_end = 4 * scanline_width;\n            const rgbeStart = new Uint8Array(4);\n            const scanline_buffer = new Uint8Array(ptr_end);\n            let num_scanlines = h2;\n            while(num_scanlines > 0 && pos < buffer2.byteLength){\n                if (pos + 4 > buffer2.byteLength) {\n                    rgbe_error(rgbe_read_error);\n                }\n                rgbeStart[0] = buffer2[pos++];\n                rgbeStart[1] = buffer2[pos++];\n                rgbeStart[2] = buffer2[pos++];\n                rgbeStart[3] = buffer2[pos++];\n                if (2 != rgbeStart[0] || 2 != rgbeStart[1] || (rgbeStart[2] << 8 | rgbeStart[3]) != scanline_width) {\n                    rgbe_error(rgbe_format_error, \"bad rgbe scanline format\");\n                }\n                let ptr = 0, count;\n                while(ptr < ptr_end && pos < buffer2.byteLength){\n                    count = buffer2[pos++];\n                    const isEncodedRun = count > 128;\n                    if (isEncodedRun) count -= 128;\n                    if (0 === count || ptr + count > ptr_end) {\n                        rgbe_error(rgbe_format_error, \"bad scanline data\");\n                    }\n                    if (isEncodedRun) {\n                        const byteValue = buffer2[pos++];\n                        for(let i = 0; i < count; i++){\n                            scanline_buffer[ptr++] = byteValue;\n                        }\n                    } else {\n                        scanline_buffer.set(buffer2.subarray(pos, pos + count), ptr);\n                        ptr += count;\n                        pos += count;\n                    }\n                }\n                const l = scanline_width;\n                for(let i = 0; i < l; i++){\n                    let off = 0;\n                    data_rgba[offset] = scanline_buffer[i + off];\n                    off += scanline_width;\n                    data_rgba[offset + 1] = scanline_buffer[i + off];\n                    off += scanline_width;\n                    data_rgba[offset + 2] = scanline_buffer[i + off];\n                    off += scanline_width;\n                    data_rgba[offset + 3] = scanline_buffer[i + off];\n                    offset += 4;\n                }\n                num_scanlines--;\n            }\n            return data_rgba;\n        };\n        const RGBEByteToRGBFloat = function(sourceArray, sourceOffset, destArray, destOffset) {\n            const e = sourceArray[sourceOffset + 3];\n            const scale = Math.pow(2, e - 128) / 255;\n            destArray[destOffset + 0] = sourceArray[sourceOffset + 0] * scale;\n            destArray[destOffset + 1] = sourceArray[sourceOffset + 1] * scale;\n            destArray[destOffset + 2] = sourceArray[sourceOffset + 2] * scale;\n            destArray[destOffset + 3] = 1;\n        };\n        const RGBEByteToRGBHalf = function(sourceArray, sourceOffset, destArray, destOffset) {\n            const e = sourceArray[sourceOffset + 3];\n            const scale = Math.pow(2, e - 128) / 255;\n            destArray[destOffset + 0] = three__WEBPACK_IMPORTED_MODULE_0__.DataUtils.toHalfFloat(Math.min(sourceArray[sourceOffset + 0] * scale, 65504));\n            destArray[destOffset + 1] = three__WEBPACK_IMPORTED_MODULE_0__.DataUtils.toHalfFloat(Math.min(sourceArray[sourceOffset + 1] * scale, 65504));\n            destArray[destOffset + 2] = three__WEBPACK_IMPORTED_MODULE_0__.DataUtils.toHalfFloat(Math.min(sourceArray[sourceOffset + 2] * scale, 65504));\n            destArray[destOffset + 3] = three__WEBPACK_IMPORTED_MODULE_0__.DataUtils.toHalfFloat(1);\n        };\n        const byteArray = new Uint8Array(buffer);\n        byteArray.pos = 0;\n        const rgbe_header_info = RGBE_ReadHeader(byteArray);\n        const w = rgbe_header_info.width, h = rgbe_header_info.height, image_rgba_data = RGBE_ReadPixels_RLE(byteArray.subarray(byteArray.pos), w, h);\n        let data, type;\n        let numElements;\n        switch(this.type){\n            case three__WEBPACK_IMPORTED_MODULE_0__.FloatType:\n                numElements = image_rgba_data.length / 4;\n                const floatArray = new Float32Array(numElements * 4);\n                for(let j = 0; j < numElements; j++){\n                    RGBEByteToRGBFloat(image_rgba_data, j * 4, floatArray, j * 4);\n                }\n                data = floatArray;\n                type = three__WEBPACK_IMPORTED_MODULE_0__.FloatType;\n                break;\n            case three__WEBPACK_IMPORTED_MODULE_0__.HalfFloatType:\n                numElements = image_rgba_data.length / 4;\n                const halfArray = new Uint16Array(numElements * 4);\n                for(let j = 0; j < numElements; j++){\n                    RGBEByteToRGBHalf(image_rgba_data, j * 4, halfArray, j * 4);\n                }\n                data = halfArray;\n                type = three__WEBPACK_IMPORTED_MODULE_0__.HalfFloatType;\n                break;\n            default:\n                throw new Error(\"THREE.RGBELoader: Unsupported type: \" + this.type);\n        }\n        return {\n            width: w,\n            height: h,\n            data,\n            header: rgbe_header_info.string,\n            gamma: rgbe_header_info.gamma,\n            exposure: rgbe_header_info.exposure,\n            type\n        };\n    }\n    setDataType(value) {\n        this.type = value;\n        return this;\n    }\n    load(url, onLoad, onProgress, onError) {\n        function onLoadCallback(texture, texData) {\n            switch(texture.type){\n                case three__WEBPACK_IMPORTED_MODULE_0__.FloatType:\n                case three__WEBPACK_IMPORTED_MODULE_0__.HalfFloatType:\n                    if (\"colorSpace\" in texture) texture.colorSpace = \"srgb-linear\";\n                    else texture.encoding = 3e3;\n                    texture.minFilter = three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter;\n                    texture.magFilter = three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter;\n                    texture.generateMipmaps = false;\n                    texture.flipY = true;\n                    break;\n            }\n            if (onLoad) onLoad(texture, texData);\n        }\n        return super.load(url, onLoadCallback, onProgress, onError);\n    }\n}\n //# sourceMappingURL=RGBELoader.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL2xvYWRlcnMvUkdCRUxvYWRlci5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUE2RjtBQUM3RixNQUFNSyxtQkFBbUJMLG9EQUFpQkE7SUFDeENNLFlBQVlDLE9BQU8sQ0FBRTtRQUNuQixLQUFLLENBQUNBO1FBQ04sSUFBSSxDQUFDQyxJQUFJLEdBQUdQLGdEQUFhQTtJQUMzQjtJQUNBLDhEQUE4RDtJQUM5RFEsTUFBTUMsTUFBTSxFQUFFO1FBQ1osTUFBTUMsa0JBQWtCLEdBQUdDLG1CQUFtQixHQUFHQyxvQkFBb0IsR0FBR0Msb0JBQW9CLEdBQUdDLGFBQWEsU0FBU0MsZUFBZSxFQUFFQyxHQUFHO1lBQ3ZJLE9BQVFEO2dCQUNOLEtBQUtMO29CQUNILE1BQU0sSUFBSU8sTUFBTSxtQ0FBb0NELENBQUFBLE9BQU8sRUFBQztnQkFDOUQsS0FBS0w7b0JBQ0gsTUFBTSxJQUFJTSxNQUFNLG9DQUFxQ0QsQ0FBQUEsT0FBTyxFQUFDO2dCQUMvRCxLQUFLSjtvQkFDSCxNQUFNLElBQUlLLE1BQU0sd0NBQXlDRCxDQUFBQSxPQUFPLEVBQUM7Z0JBQ25FO2dCQUNBLEtBQUtIO29CQUNILE1BQU0sSUFBSUksTUFBTSxxQ0FBc0NELENBQUFBLE9BQU8sRUFBQztZQUNsRTtRQUNGLEdBQUdFLHlCQUF5QixHQUFHQyxvQkFBb0IsR0FBR0Msd0JBQXdCLEdBQUdDLFVBQVUsTUFBTUMsUUFBUSxTQUFTQyxPQUFPLEVBQUVDLFNBQVMsRUFBRUMsT0FBTztZQUMzSSxNQUFNQyxZQUFZO1lBQ2xCRixZQUFZLENBQUNBLFlBQVksT0FBT0E7WUFDaEMsSUFBSUcsSUFBSUosUUFBUUssR0FBRyxFQUFFQyxJQUFJLENBQUMsR0FBR0MsTUFBTSxHQUFHQyxJQUFJLElBQUlDLFFBQVFDLE9BQU9DLFlBQVksQ0FBQ0MsS0FBSyxDQUFDLE1BQU0sSUFBSUMsWUFBWWIsUUFBUWMsUUFBUSxDQUFDVixHQUFHQSxJQUFJRDtZQUM5SCxNQUFP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QUNBLE9BQU87WUFDTGlELE9BQU91QztZQUNQdEMsUUFBUXVDO1lBQ1JFO1lBQ0FsRCxRQUFROEMsaUJBQWlCNUMsTUFBTTtZQUMvQkksT0FBT3dDLGlCQUFpQnhDLEtBQUs7WUFDN0JDLFVBQVV1QyxpQkFBaUJ2QyxRQUFRO1lBQ25DaEQ7UUFDRjtJQUNGO0lBQ0FpRyxZQUFZQyxLQUFLLEVBQUU7UUFDakIsSUFBSSxDQUFDbEcsSUFBSSxHQUFHa0c7UUFDWixPQUFPLElBQUk7SUFDYjtJQUNBQyxLQUFLQyxHQUFHLEVBQUVDLE1BQU0sRUFBRUMsVUFBVSxFQUFFQyxPQUFPLEVBQUU7UUFDckMsU0FBU0MsZUFBZUMsT0FBTyxFQUFFQyxPQUFPO1lBQ3RDLE9BQVFELFFBQVF6RyxJQUFJO2dCQUNsQixLQUFLTiw0Q0FBU0E7Z0JBQ2QsS0FBS0QsZ0RBQWFBO29CQUNoQixJQUFJLGdCQUFnQmdILFNBQ2xCQSxRQUFRRSxVQUFVLEdBQUc7eUJBRXJCRixRQUFRRyxRQUFRLEdBQUc7b0JBQ3JCSCxRQUFRSSxTQUFTLEdBQUdqSCwrQ0FBWUE7b0JBQ2hDNkcsUUFBUUssU0FBUyxHQUFHbEgsK0NBQVlBO29CQUNoQzZHLFFBQVFNLGVBQWUsR0FBRztvQkFDMUJOLFFBQVFPLEtBQUssR0FBRztvQkFDaEI7WUFDSjtZQUNBLElBQUlYLFFBQ0ZBLE9BQU9JLFNBQVNDO1FBQ3BCO1FBQ0EsT0FBTyxLQUFLLENBQUNQLEtBQUtDLEtBQUtJLGdCQUFnQkYsWUFBWUM7SUFDckQ7QUFDRjtBQUdFLENBQ0Ysc0NBQXNDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYmx1ZXByaW50LXRvLTNkLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL3RocmVlLXN0ZGxpYi9sb2FkZXJzL1JHQkVMb2FkZXIuanM/N2FiMSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBEYXRhVGV4dHVyZUxvYWRlciwgSGFsZkZsb2F0VHlwZSwgRmxvYXRUeXBlLCBEYXRhVXRpbHMsIExpbmVhckZpbHRlciB9IGZyb20gXCJ0aHJlZVwiO1xuY2xhc3MgUkdCRUxvYWRlciBleHRlbmRzIERhdGFUZXh0dXJlTG9hZGVyIHtcbiAgY29uc3RydWN0b3IobWFuYWdlcikge1xuICAgIHN1cGVyKG1hbmFnZXIpO1xuICAgIHRoaXMudHlwZSA9IEhhbGZGbG9hdFR5cGU7XG4gIH1cbiAgLy8gYWRhcHRlZCBmcm9tIGh0dHA6Ly93d3cuZ3JhcGhpY3MuY29ybmVsbC5lZHUvfmJqdy9yZ2JlLmh0bWxcbiAgcGFyc2UoYnVmZmVyKSB7XG4gICAgY29uc3QgcmdiZV9yZWFkX2Vycm9yID0gMSwgcmdiZV93cml0ZV9lcnJvciA9IDIsIHJnYmVfZm9ybWF0X2Vycm9yID0gMywgcmdiZV9tZW1vcnlfZXJyb3IgPSA0LCByZ2JlX2Vycm9yID0gZnVuY3Rpb24ocmdiZV9lcnJvcl9jb2RlLCBtc2cpIHtcbiAgICAgIHN3aXRjaCAocmdiZV9lcnJvcl9jb2RlKSB7XG4gICAgICAgIGNhc2UgcmdiZV9yZWFkX2Vycm9yOlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRIUkVFLlJHQkVMb2FkZXI6IFJlYWQgRXJyb3I6IFwiICsgKG1zZyB8fCBcIlwiKSk7XG4gICAgICAgIGNhc2UgcmdiZV93cml0ZV9lcnJvcjpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUSFJFRS5SR0JFTG9hZGVyOiBXcml0ZSBFcnJvcjogXCIgKyAobXNnIHx8IFwiXCIpKTtcbiAgICAgICAgY2FzZSByZ2JlX2Zvcm1hdF9lcnJvcjpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUSFJFRS5SR0JFTG9hZGVyOiBCYWQgRmlsZSBGb3JtYXQ6IFwiICsgKG1zZyB8fCBcIlwiKSk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGNhc2UgcmdiZV9tZW1vcnlfZXJyb3I6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVEhSRUUuUkdCRUxvYWRlcjogTWVtb3J5IEVycm9yOiBcIiArIChtc2cgfHwgXCJcIikpO1xuICAgICAgfVxuICAgIH0sIFJHQkVfVkFMSURfUFJPR1JBTVRZUEUgPSAxLCBSR0JFX1ZBTElEX0ZPUk1BVCA9IDIsIFJHQkVfVkFMSURfRElNRU5TSU9OUyA9IDQsIE5FV0xJTkUgPSBcIlxcblwiLCBmZ2V0cyA9IGZ1bmN0aW9uKGJ1ZmZlcjIsIGxpbmVMaW1pdCwgY29uc3VtZSkge1xuICAgICAgY29uc3QgY2h1bmtTaXplID0gMTI4O1xuICAgICAgbGluZUxpbWl0ID0gIWxpbmVMaW1pdCA/IDEwMjQgOiBsaW5lTGltaXQ7XG4gICAgICBsZXQgcCA9IGJ1ZmZlcjIucG9zLCBpID0gLTEsIGxlbiA9IDAsIHMgPSBcIlwiLCBjaHVuayA9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgbmV3IFVpbnQxNkFycmF5KGJ1ZmZlcjIuc3ViYXJyYXkocCwgcCArIGNodW5rU2l6ZSkpKTtcbiAgICAgIHdoaWxlICgwID4gKGkgPSBjaHVuay5pbmRleE9mKE5FV0xJTkUpKSAmJiBsZW4gPCBsaW5lTGltaXQgJiYgcCA8IGJ1ZmZlcjIuYnl0ZUxlbmd0aCkge1xuICAgICAgICBzICs9IGNodW5rO1xuICAgICAgICBsZW4gKz0gY2h1bmsubGVuZ3RoO1xuICAgICAgICBwICs9IGNodW5rU2l6ZTtcbiAgICAgICAgY2h1bmsgKz0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBuZXcgVWludDE2QXJyYXkoYnVmZmVyMi5zdWJhcnJheShwLCBwICsgY2h1bmtTaXplKSkpO1xuICAgICAgfVxuICAgICAgaWYgKC0xIDwgaSkge1xuICAgICAgICBpZiAoZmFsc2UgIT09IGNvbnN1bWUpXG4gICAgICAgICAgYnVmZmVyMi5wb3MgKz0gbGVuICsgaSArIDE7XG4gICAgICAgIHJldHVybiBzICsgY2h1bmsuc2xpY2UoMCwgaSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSwgUkdCRV9SZWFkSGVhZGVyID0gZnVuY3Rpb24oYnVmZmVyMikge1xuICAgICAgY29uc3QgbWFnaWNfdG9rZW5fcmUgPSAvXiNcXD8oXFxTKykvLCBnYW1tYV9yZSA9IC9eXFxzKkdBTU1BXFxzKj1cXHMqKFxcZCsoXFwuXFxkKyk/KVxccyokLywgZXhwb3N1cmVfcmUgPSAvXlxccypFWFBPU1VSRVxccyo9XFxzKihcXGQrKFxcLlxcZCspPylcXHMqJC8sIGZvcm1hdF9yZSA9IC9eXFxzKkZPUk1BVD0oXFxTKylcXHMqJC8sIGRpbWVuc2lvbnNfcmUgPSAvXlxccypcXC1ZXFxzKyhcXGQrKVxccytcXCtYXFxzKyhcXGQrKVxccyokLywgaGVhZGVyID0ge1xuICAgICAgICB2YWxpZDogMCxcbiAgICAgICAgc3RyaW5nOiBcIlwiLFxuICAgICAgICBjb21tZW50czogXCJcIixcbiAgICAgICAgcHJvZ3JhbXR5cGU6IFwiUkdCRVwiLFxuICAgICAgICBmb3JtYXQ6IFwiXCIsXG4gICAgICAgIGdhbW1hOiAxLFxuICAgICAgICBleHBvc3VyZTogMSxcbiAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgIGhlaWdodDogMFxuICAgICAgfTtcbiAgICAgIGxldCBsaW5lLCBtYXRjaDtcbiAgICAgIGlmIChidWZmZXIyLnBvcyA+PSBidWZmZXIyLmJ5dGVMZW5ndGggfHwgIShsaW5lID0gZmdldHMoYnVmZmVyMikpKSB7XG4gICAgICAgIHJnYmVfZXJyb3IocmdiZV9yZWFkX2Vycm9yLCBcIm5vIGhlYWRlciBmb3VuZFwiKTtcbiAgICAgIH1cbiAgICAgIGlmICghKG1hdGNoID0gbGluZS5tYXRjaChtYWdpY190b2tlbl9yZSkpKSB7XG4gICAgICAgIHJnYmVfZXJyb3IocmdiZV9mb3JtYXRfZXJyb3IsIFwiYmFkIGluaXRpYWwgdG9rZW5cIik7XG4gICAgICB9XG4gICAgICBoZWFkZXIudmFsaWQgfD0gUkdCRV9WQUxJRF9QUk9HUkFNVFlQRTtcbiAgICAgIGhlYWRlci5wcm9ncmFtdHlwZSA9IG1hdGNoWzFdO1xuICAgICAgaGVhZGVyLnN0cmluZyArPSBsaW5lICsgXCJcXG5cIjtcbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGxpbmUgPSBmZ2V0cyhidWZmZXIyKTtcbiAgICAgICAgaWYgKGZhbHNlID09PSBsaW5lKVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBoZWFkZXIuc3RyaW5nICs9IGxpbmUgKyBcIlxcblwiO1xuICAgICAgICBpZiAoXCIjXCIgPT09IGxpbmUuY2hhckF0KDApKSB7XG4gICAgICAgICAgaGVhZGVyLmNvbW1lbnRzICs9IGxpbmUgKyBcIlxcblwiO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXRjaCA9IGxpbmUubWF0Y2goZ2FtbWFfcmUpKSB7XG4gICAgICAgICAgaGVhZGVyLmdhbW1hID0gcGFyc2VGbG9hdChtYXRjaFsxXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1hdGNoID0gbGluZS5tYXRjaChleHBvc3VyZV9yZSkpIHtcbiAgICAgICAgICBoZWFkZXIuZXhwb3N1cmUgPSBwYXJzZUZsb2F0KG1hdGNoWzFdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWF0Y2ggPSBsaW5lLm1hdGNoKGZvcm1hdF9yZSkpIHtcbiAgICAgICAgICBoZWFkZXIudmFsaWQgfD0gUkdCRV9WQUxJRF9GT1JNQVQ7XG4gICAgICAgICAgaGVhZGVyLmZvcm1hdCA9IG1hdGNoWzFdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXRjaCA9IGxpbmUubWF0Y2goZGltZW5zaW9uc19yZSkpIHtcbiAgICAgICAgICBoZWFkZXIudmFsaWQgfD0gUkdCRV9WQUxJRF9ESU1FTlNJT05TO1xuICAgICAgICAgIGhlYWRlci5oZWlnaHQgPSBwYXJzZUludChtYXRjaFsxXSwgMTApO1xuICAgICAgICAgIGhlYWRlci53aWR0aCA9IHBhcnNlSW50KG1hdGNoWzJdLCAxMCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhlYWRlci52YWxpZCAmIFJHQkVfVkFMSURfRk9STUFUICYmIGhlYWRlci52YWxpZCAmIFJHQkVfVkFMSURfRElNRU5TSU9OUylcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmICghKGhlYWRlci52YWxpZCAmIFJHQkVfVkFMSURfRk9STUFUKSkge1xuICAgICAgICByZ2JlX2Vycm9yKHJnYmVfZm9ybWF0X2Vycm9yLCBcIm1pc3NpbmcgZm9ybWF0IHNwZWNpZmllclwiKTtcbiAgICAgIH1cbiAgICAgIGlmICghKGhlYWRlci52YWxpZCAmIFJHQkVfVkFMSURfRElNRU5TSU9OUykpIHtcbiAgICAgICAgcmdiZV9lcnJvcihyZ2JlX2Zvcm1hdF9lcnJvciwgXCJtaXNzaW5nIGltYWdlIHNpemUgc3BlY2lmaWVyXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGhlYWRlcjtcbiAgICB9LCBSR0JFX1JlYWRQaXhlbHNfUkxFID0gZnVuY3Rpb24oYnVmZmVyMiwgdzIsIGgyKSB7XG4gICAgICBjb25zdCBzY2FubGluZV93aWR0aCA9IHcyO1xuICAgICAgaWYgKFxuICAgICAgICAvLyBydW4gbGVuZ3RoIGVuY29kaW5nIGlzIG5vdCBhbGxvd2VkIHNvIHJlYWQgZmxhdFxuICAgICAgICBzY2FubGluZV93aWR0aCA8IDggfHwgc2NhbmxpbmVfd2lkdGggPiAzMjc2NyB8fCAvLyB0aGlzIGZpbGUgaXMgbm90IHJ1biBsZW5ndGggZW5jb2RlZFxuICAgICAgICAyICE9PSBidWZmZXIyWzBdIHx8IDIgIT09IGJ1ZmZlcjJbMV0gfHwgYnVmZmVyMlsyXSAmIDEyOFxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShidWZmZXIyKTtcbiAgICAgIH1cbiAgICAgIGlmIChzY2FubGluZV93aWR0aCAhPT0gKGJ1ZmZlcjJbMl0gPDwgOCB8IGJ1ZmZlcjJbM10pKSB7XG4gICAgICAgIHJnYmVfZXJyb3IocmdiZV9mb3JtYXRfZXJyb3IsIFwid3Jvbmcgc2NhbmxpbmUgd2lkdGhcIik7XG4gICAgICB9XG4gICAgICBjb25zdCBkYXRhX3JnYmEgPSBuZXcgVWludDhBcnJheSg0ICogdzIgKiBoMik7XG4gICAgICBpZiAoIWRhdGFfcmdiYS5sZW5ndGgpIHtcbiAgICAgICAgcmdiZV9lcnJvcihyZ2JlX21lbW9yeV9lcnJvciwgXCJ1bmFibGUgdG8gYWxsb2NhdGUgYnVmZmVyIHNwYWNlXCIpO1xuICAgICAgfVxuICAgICAgbGV0IG9mZnNldCA9IDAsIHBvcyA9IDA7XG4gICAgICBjb25zdCBwdHJfZW5kID0gNCAqIHNjYW5saW5lX3dpZHRoO1xuICAgICAgY29uc3QgcmdiZVN0YXJ0ID0gbmV3IFVpbnQ4QXJyYXkoNCk7XG4gICAgICBjb25zdCBzY2FubGluZV9idWZmZXIgPSBuZXcgVWludDhBcnJheShwdHJfZW5kKTtcbiAgICAgIGxldCBudW1fc2NhbmxpbmVzID0gaDI7XG4gICAgICB3aGlsZSAobnVtX3NjYW5saW5lcyA+IDAgJiYgcG9zIDwgYnVmZmVyMi5ieXRlTGVuZ3RoKSB7XG4gICAgICAgIGlmIChwb3MgKyA0ID4gYnVmZmVyMi5ieXRlTGVuZ3RoKSB7XG4gICAgICAgICAgcmdiZV9lcnJvcihyZ2JlX3JlYWRfZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIHJnYmVTdGFydFswXSA9IGJ1ZmZlcjJbcG9zKytdO1xuICAgICAgICByZ2JlU3RhcnRbMV0gPSBidWZmZXIyW3BvcysrXTtcbiAgICAgICAgcmdiZVN0YXJ0WzJdID0gYnVmZmVyMltwb3MrK107XG4gICAgICAgIHJnYmVTdGFydFszXSA9IGJ1ZmZlcjJbcG9zKytdO1xuICAgICAgICBpZiAoMiAhPSByZ2JlU3RhcnRbMF0gfHwgMiAhPSByZ2JlU3RhcnRbMV0gfHwgKHJnYmVTdGFydFsyXSA8PCA4IHwgcmdiZVN0YXJ0WzNdKSAhPSBzY2FubGluZV93aWR0aCkge1xuICAgICAgICAgIHJnYmVfZXJyb3IocmdiZV9mb3JtYXRfZXJyb3IsIFwiYmFkIHJnYmUgc2NhbmxpbmUgZm9ybWF0XCIpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBwdHIgPSAwLCBjb3VudDtcbiAgICAgICAgd2hpbGUgKHB0ciA8IHB0cl9lbmQgJiYgcG9zIDwgYnVmZmVyMi5ieXRlTGVuZ3RoKSB7XG4gICAgICAgICAgY291bnQgPSBidWZmZXIyW3BvcysrXTtcbiAgICAgICAgICBjb25zdCBpc0VuY29kZWRSdW4gPSBjb3VudCA+IDEyODtcbiAgICAgICAgICBpZiAoaXNFbmNvZGVkUnVuKVxuICAgICAgICAgICAgY291bnQgLT0gMTI4O1xuICAgICAgICAgIGlmICgwID09PSBjb3VudCB8fCBwdHIgKyBjb3VudCA+IHB0cl9lbmQpIHtcbiAgICAgICAgICAgIHJnYmVfZXJyb3IocmdiZV9mb3JtYXRfZXJyb3IsIFwiYmFkIHNjYW5saW5lIGRhdGFcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc0VuY29kZWRSdW4pIHtcbiAgICAgICAgICAgIGNvbnN0IGJ5dGVWYWx1ZSA9IGJ1ZmZlcjJbcG9zKytdO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgICAgICAgIHNjYW5saW5lX2J1ZmZlcltwdHIrK10gPSBieXRlVmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNjYW5saW5lX2J1ZmZlci5zZXQoYnVmZmVyMi5zdWJhcnJheShwb3MsIHBvcyArIGNvdW50KSwgcHRyKTtcbiAgICAgICAgICAgIHB0ciArPSBjb3VudDtcbiAgICAgICAgICAgIHBvcyArPSBjb3VudDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbCA9IHNjYW5saW5lX3dpZHRoO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIGxldCBvZmYgPSAwO1xuICAgICAgICAgIGRhdGFfcmdiYVtvZmZzZXRdID0gc2NhbmxpbmVfYnVmZmVyW2kgKyBvZmZdO1xuICAgICAgICAgIG9mZiArPSBzY2FubGluZV93aWR0aDtcbiAgICAgICAgICBkYXRhX3JnYmFbb2Zmc2V0ICsgMV0gPSBzY2FubGluZV9idWZmZXJbaSArIG9mZl07XG4gICAgICAgICAgb2ZmICs9IHNjYW5saW5lX3dpZHRoO1xuICAgICAgICAgIGRhdGFfcmdiYVtvZmZzZXQgKyAyXSA9IHNjYW5saW5lX2J1ZmZlcltpICsgb2ZmXTtcbiAgICAgICAgICBvZmYgKz0gc2NhbmxpbmVfd2lkdGg7XG4gICAgICAgICAgZGF0YV9yZ2JhW29mZnNldCArIDNdID0gc2NhbmxpbmVfYnVmZmVyW2kgKyBvZmZdO1xuICAgICAgICAgIG9mZnNldCArPSA0O1xuICAgICAgICB9XG4gICAgICAgIG51bV9zY2FubGluZXMtLTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhX3JnYmE7XG4gICAgfTtcbiAgICBjb25zdCBSR0JFQnl0ZVRvUkdCRmxvYXQgPSBmdW5jdGlvbihzb3VyY2VBcnJheSwgc291cmNlT2Zmc2V0LCBkZXN0QXJyYXksIGRlc3RPZmZzZXQpIHtcbiAgICAgIGNvbnN0IGUgPSBzb3VyY2VBcnJheVtzb3VyY2VPZmZzZXQgKyAzXTtcbiAgICAgIGNvbnN0IHNjYWxlID0gTWF0aC5wb3coMiwgZSAtIDEyOCkgLyAyNTU7XG4gICAgICBkZXN0QXJyYXlbZGVzdE9mZnNldCArIDBdID0gc291cmNlQXJyYXlbc291cmNlT2Zmc2V0ICsgMF0gKiBzY2FsZTtcbiAgICAgIGRlc3RBcnJheVtkZXN0T2Zmc2V0ICsgMV0gPSBzb3VyY2VBcnJheVtzb3VyY2VPZmZzZXQgKyAxXSAqIHNjYWxlO1xuICAgICAgZGVzdEFycmF5W2Rlc3RPZmZzZXQgKyAyXSA9IHNvdXJjZUFycmF5W3NvdXJjZU9mZnNldCArIDJdICogc2NhbGU7XG4gICAgICBkZXN0QXJyYXlbZGVzdE9mZnNldCArIDNdID0gMTtcbiAgICB9O1xuICAgIGNvbnN0IFJHQkVCeXRlVG9SR0JIYWxmID0gZnVuY3Rpb24oc291cmNlQXJyYXksIHNvdXJjZU9mZnNldCwgZGVzdEFycmF5LCBkZXN0T2Zmc2V0KSB7XG4gICAgICBjb25zdCBlID0gc291cmNlQXJyYXlbc291cmNlT2Zmc2V0ICsgM107XG4gICAgICBjb25zdCBzY2FsZSA9IE1hdGgucG93KDIsIGUgLSAxMjgpIC8gMjU1O1xuICAgICAgZGVzdEFycmF5W2Rlc3RPZmZzZXQgKyAwXSA9IERhdGFVdGlscy50b0hhbGZGbG9hdChNYXRoLm1pbihzb3VyY2VBcnJheVtzb3VyY2VPZmZzZXQgKyAwXSAqIHNjYWxlLCA2NTUwNCkpO1xuICAgICAgZGVzdEFycmF5W2Rlc3RPZmZzZXQgKyAxXSA9IERhdGFVdGlscy50b0hhbGZGbG9hdChNYXRoLm1pbihzb3VyY2VBcnJheVtzb3VyY2VPZmZzZXQgKyAxXSAqIHNjYWxlLCA2NTUwNCkpO1xuICAgICAgZGVzdEFycmF5W2Rlc3RPZmZzZXQgKyAyXSA9IERhdGFVdGlscy50b0hhbGZGbG9hdChNYXRoLm1pbihzb3VyY2VBcnJheVtzb3VyY2VPZmZzZXQgKyAyXSAqIHNjYWxlLCA2NTUwNCkpO1xuICAgICAgZGVzdEFycmF5W2Rlc3RPZmZzZXQgKyAzXSA9IERhdGFVdGlscy50b0hhbGZGbG9hdCgxKTtcbiAgICB9O1xuICAgIGNvbnN0IGJ5dGVBcnJheSA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlcik7XG4gICAgYnl0ZUFycmF5LnBvcyA9IDA7XG4gICAgY29uc3QgcmdiZV9oZWFkZXJfaW5mbyA9IFJHQkVfUmVhZEhlYWRlcihieXRlQXJyYXkpO1xuICAgIGNvbnN0IHcgPSByZ2JlX2hlYWRlcl9pbmZvLndpZHRoLCBoID0gcmdiZV9oZWFkZXJfaW5mby5oZWlnaHQsIGltYWdlX3JnYmFfZGF0YSA9IFJHQkVfUmVhZFBpeGVsc19STEUoYnl0ZUFycmF5LnN1YmFycmF5KGJ5dGVBcnJheS5wb3MpLCB3LCBoKTtcbiAgICBsZXQgZGF0YSwgdHlwZTtcbiAgICBsZXQgbnVtRWxlbWVudHM7XG4gICAgc3dpdGNoICh0aGlzLnR5cGUpIHtcbiAgICAgIGNhc2UgRmxvYXRUeXBlOlxuICAgICAgICBudW1FbGVtZW50cyA9IGltYWdlX3JnYmFfZGF0YS5sZW5ndGggLyA0O1xuICAgICAgICBjb25zdCBmbG9hdEFycmF5ID0gbmV3IEZsb2F0MzJBcnJheShudW1FbGVtZW50cyAqIDQpO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG51bUVsZW1lbnRzOyBqKyspIHtcbiAgICAgICAgICBSR0JFQnl0ZVRvUkdCRmxvYXQoaW1hZ2VfcmdiYV9kYXRhLCBqICogNCwgZmxvYXRBcnJheSwgaiAqIDQpO1xuICAgICAgICB9XG4gICAgICAgIGRhdGEgPSBmbG9hdEFycmF5O1xuICAgICAgICB0eXBlID0gRmxvYXRUeXBlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgSGFsZkZsb2F0VHlwZTpcbiAgICAgICAgbnVtRWxlbWVudHMgPSBpbWFnZV9yZ2JhX2RhdGEubGVuZ3RoIC8gNDtcbiAgICAgICAgY29uc3QgaGFsZkFycmF5ID0gbmV3IFVpbnQxNkFycmF5KG51bUVsZW1lbnRzICogNCk7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbnVtRWxlbWVudHM7IGorKykge1xuICAgICAgICAgIFJHQkVCeXRlVG9SR0JIYWxmKGltYWdlX3JnYmFfZGF0YSwgaiAqIDQsIGhhbGZBcnJheSwgaiAqIDQpO1xuICAgICAgICB9XG4gICAgICAgIGRhdGEgPSBoYWxmQXJyYXk7XG4gICAgICAgIHR5cGUgPSBIYWxmRmxvYXRUeXBlO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRIUkVFLlJHQkVMb2FkZXI6IFVuc3VwcG9ydGVkIHR5cGU6IFwiICsgdGhpcy50eXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHdpZHRoOiB3LFxuICAgICAgaGVpZ2h0OiBoLFxuICAgICAgZGF0YSxcbiAgICAgIGhlYWRlcjogcmdiZV9oZWFkZXJfaW5mby5zdHJpbmcsXG4gICAgICBnYW1tYTogcmdiZV9oZWFkZXJfaW5mby5nYW1tYSxcbiAgICAgIGV4cG9zdXJlOiByZ2JlX2hlYWRlcl9pbmZvLmV4cG9zdXJlLFxuICAgICAgdHlwZVxuICAgIH07XG4gIH1cbiAgc2V0RGF0YVR5cGUodmFsdWUpIHtcbiAgICB0aGlzLnR5cGUgPSB2YWx1ZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBsb2FkKHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yKSB7XG4gICAgZnVuY3Rpb24gb25Mb2FkQ2FsbGJhY2sodGV4dHVyZSwgdGV4RGF0YSkge1xuICAgICAgc3dpdGNoICh0ZXh0dXJlLnR5cGUpIHtcbiAgICAgICAgY2FzZSBGbG9hdFR5cGU6XG4gICAgICAgIGNhc2UgSGFsZkZsb2F0VHlwZTpcbiAgICAgICAgICBpZiAoXCJjb2xvclNwYWNlXCIgaW4gdGV4dHVyZSlcbiAgICAgICAgICAgIHRleHR1cmUuY29sb3JTcGFjZSA9IFwic3JnYi1saW5lYXJcIjtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB0ZXh0dXJlLmVuY29kaW5nID0gM2UzO1xuICAgICAgICAgIHRleHR1cmUubWluRmlsdGVyID0gTGluZWFyRmlsdGVyO1xuICAgICAgICAgIHRleHR1cmUubWFnRmlsdGVyID0gTGluZWFyRmlsdGVyO1xuICAgICAgICAgIHRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzID0gZmFsc2U7XG4gICAgICAgICAgdGV4dHVyZS5mbGlwWSA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAob25Mb2FkKVxuICAgICAgICBvbkxvYWQodGV4dHVyZSwgdGV4RGF0YSk7XG4gICAgfVxuICAgIHJldHVybiBzdXBlci5sb2FkKHVybCwgb25Mb2FkQ2FsbGJhY2ssIG9uUHJvZ3Jlc3MsIG9uRXJyb3IpO1xuICB9XG59XG5leHBvcnQge1xuICBSR0JFTG9hZGVyXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UkdCRUxvYWRlci5qcy5tYXBcbiJdLCJuYW1lcyI6WyJEYXRhVGV4dHVyZUxvYWRlciIsIkhhbGZGbG9hdFR5cGUiLCJGbG9hdFR5cGUiLCJEYXRhVXRpbHMiLCJMaW5lYXJGaWx0ZXIiLCJSR0JFTG9hZGVyIiwiY29uc3RydWN0b3IiLCJtYW5hZ2VyIiwidHlwZSIsInBhcnNlIiwiYnVmZmVyIiwicmdiZV9yZWFkX2Vycm9yIiwicmdiZV93cml0ZV9lcnJvciIsInJnYmVfZm9ybWF0X2Vycm9yIiwicmdiZV9tZW1vcnlfZXJyb3IiLCJyZ2JlX2Vycm9yIiwicmdiZV9lcnJvcl9jb2RlIiwibXNnIiwiRXJyb3IiLCJSR0JFX1ZBTElEX1BST0dSQU1UWVBFIiwiUkdCRV9WQUxJRF9GT1JNQVQiLCJSR0JFX1ZBTElEX0RJTUVOU0lPTlMiLCJORVdMSU5FIiwiZmdldHMiLCJidWZmZXIyIiwibGluZUxpbWl0IiwiY29uc3VtZSIsImNodW5rU2l6ZSIsInAiLCJwb3MiLCJpIiwibGVuIiwicyIsImNodW5rIiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwiYXBwbHkiLCJVaW50MTZBcnJheSIsInN1YmFycmF5IiwiaW5kZXhPZiIsImJ5dGVMZW5ndGgiLCJsZW5ndGgiLCJzbGljZSIsIlJHQkVfUmVhZEhlYWRlciIsIm1hZ2ljX3Rva2VuX3JlIiwiZ2FtbWFfcmUiLCJleHBvc3VyZV9yZSIsImZvcm1hdF9yZSIsImRpbWVuc2lvbnNfcmUiLCJoZWFkZXIiLCJ2YWxpZCIsInN0cmluZyIsImNvbW1lbnRzIiwicHJvZ3JhbXR5cGUiLCJmb3JtYXQiLCJnYW1tYSIsImV4cG9zdXJlIiwid2lkdGgiLCJoZWlnaHQiLCJsaW5lIiwibWF0Y2giLCJjaGFyQXQiLCJwYXJzZUZsb2F0IiwicGFyc2VJbnQiLCJSR0JFX1JlYWRQaXhlbHNfUkxFIiwidzIiLCJoMiIsInNjYW5saW5lX3dpZHRoIiwiVWludDhBcnJheSIsImRhdGFfcmdiYSIsIm9mZnNldCIsInB0cl9lbmQiLCJyZ2JlU3RhcnQiLCJzY2FubGluZV9idWZmZXIiLCJudW1fc2NhbmxpbmVzIiwicHRyIiwiY291bnQiLCJpc0VuY29kZWRSdW4iLCJieXRlVmFsdWUiLCJzZXQiLCJsIiwib2ZmIiwiUkdCRUJ5dGVUb1JHQkZsb2F0Iiwic291cmNlQXJyYXkiLCJzb3VyY2VPZmZzZXQiLCJkZXN0QXJyYXkiLCJkZXN0T2Zmc2V0IiwiZSIsInNjYWxlIiwiTWF0aCIsInBvdyIsIlJHQkVCeXRlVG9SR0JIYWxmIiwidG9IYWxmRmxvYXQiLCJtaW4iLCJieXRlQXJyYXkiLCJyZ2JlX2hlYWRlcl9pbmZvIiwidyIsImgiLCJpbWFnZV9yZ2JhX2RhdGEiLCJkYXRhIiwibnVtRWxlbWVudHMiLCJmbG9hdEFycmF5IiwiRmxvYXQzMkFycmF5IiwiaiIsImhhbGZBcnJheSIsInNldERhdGFUeXBlIiwidmFsdWUiLCJsb2FkIiwidXJsIiwib25Mb2FkIiwib25Qcm9ncmVzcyIsIm9uRXJyb3IiLCJvbkxvYWRDYWxsYmFjayIsInRleHR1cmUiLCJ0ZXhEYXRhIiwiY29sb3JTcGFjZSIsImVuY29kaW5nIiwibWluRmlsdGVyIiwibWFnRmlsdGVyIiwiZ2VuZXJhdGVNaXBtYXBzIiwiZmxpcFkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/three-stdlib/loaders/RGBELoader.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/three-stdlib/objects/GroundProjectedEnv.js":
/*!*****************************************************************!*\
  !*** ./node_modules/three-stdlib/objects/GroundProjectedEnv.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GroundProjectedEnv: () => (/* binding */ GroundProjectedEnv)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var _polyfill_constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../_polyfill/constants.js */ \"(ssr)/./node_modules/three-stdlib/_polyfill/constants.js\");\n\n\nconst isCubeTexture = (def)=>def && def.isCubeTexture;\nclass GroundProjectedEnv extends three__WEBPACK_IMPORTED_MODULE_0__.Mesh {\n    constructor(texture, options){\n        var _a, _b;\n        const isCubeMap = isCubeTexture(texture);\n        const w = (_b = isCubeMap ? (_a = texture.image[0]) == null ? void 0 : _a.width : texture.image.width) != null ? _b : 1024;\n        const cubeSize = w / 4;\n        const _lodMax = Math.floor(Math.log2(cubeSize));\n        const _cubeSize = Math.pow(2, _lodMax);\n        const width = 3 * Math.max(_cubeSize, 16 * 7);\n        const height = 4 * _cubeSize;\n        const defines = [\n            isCubeMap ? \"#define ENVMAP_TYPE_CUBE\" : \"\",\n            `#define CUBEUV_TEXEL_WIDTH ${1 / width}`,\n            `#define CUBEUV_TEXEL_HEIGHT ${1 / height}`,\n            `#define CUBEUV_MAX_MIP ${_lodMax}.0`\n        ];\n        const vertexShader = /* glsl */ `\n        varying vec3 vWorldPosition;\n        void main() \n        {\n            vec4 worldPosition = ( modelMatrix * vec4( position, 1.0 ) );\n            vWorldPosition = worldPosition.xyz;\n            \n            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n        }\n        `;\n        const fragmentShader = defines.join(\"\\n\") + /* glsl */ `\n        #define ENVMAP_TYPE_CUBE_UV\n        varying vec3 vWorldPosition;\n        uniform float radius;\n        uniform float height;\n        uniform float angle;\n        #ifdef ENVMAP_TYPE_CUBE\n            uniform samplerCube map;\n        #else\n            uniform sampler2D map;\n        #endif\n        // From: https://www.shadertoy.com/view/4tsBD7\n        float diskIntersectWithBackFaceCulling( vec3 ro, vec3 rd, vec3 c, vec3 n, float r ) \n        {\n            float d = dot ( rd, n );\n            \n            if( d > 0.0 ) { return 1e6; }\n            \n            vec3  o = ro - c;\n            float t = - dot( n, o ) / d;\n            vec3  q = o + rd * t;\n            \n            return ( dot( q, q ) < r * r ) ? t : 1e6;\n        }\n        // From: https://www.iquilezles.org/www/articles/intersectors/intersectors.htm\n        float sphereIntersect( vec3 ro, vec3 rd, vec3 ce, float ra ) \n        {\n            vec3 oc = ro - ce;\n            float b = dot( oc, rd );\n            float c = dot( oc, oc ) - ra * ra;\n            float h = b * b - c;\n            \n            if( h < 0.0 ) { return -1.0; }\n            \n            h = sqrt( h );\n            \n            return - b + h;\n        }\n        vec3 project() \n        {\n            vec3 p = normalize( vWorldPosition );\n            vec3 camPos = cameraPosition;\n            camPos.y -= height;\n            float intersection = sphereIntersect( camPos, p, vec3( 0.0 ), radius );\n            if( intersection > 0.0 ) {\n                \n                vec3 h = vec3( 0.0, - height, 0.0 );\n                float intersection2 = diskIntersectWithBackFaceCulling( camPos, p, h, vec3( 0.0, 1.0, 0.0 ), radius );\n                p = ( camPos + min( intersection, intersection2 ) * p ) / radius;\n            } else {\n                p = vec3( 0.0, 1.0, 0.0 );\n            }\n            return p;\n        }\n        #include <common>\n        #include <cube_uv_reflection_fragment>\n        void main() \n        {\n            vec3 projectedWorldPosition = project();\n            \n            #ifdef ENVMAP_TYPE_CUBE\n                vec3 outcolor = textureCube( map, projectedWorldPosition ).rgb;\n            #else\n                vec3 direction = normalize( projectedWorldPosition );\n                vec2 uv = equirectUv( direction );\n                vec3 outcolor = texture2D( map, uv ).rgb;\n            #endif\n            gl_FragColor = vec4( outcolor, 1.0 );\n            #include <tonemapping_fragment>\n            #include <${_polyfill_constants_js__WEBPACK_IMPORTED_MODULE_1__.version >= 154 ? \"colorspace_fragment\" : \"encodings_fragment\"}>\n        }\n        `;\n        const uniforms = {\n            map: {\n                value: texture\n            },\n            height: {\n                value: (options == null ? void 0 : options.height) || 15\n            },\n            radius: {\n                value: (options == null ? void 0 : options.radius) || 100\n            }\n        };\n        const geometry = new three__WEBPACK_IMPORTED_MODULE_0__.IcosahedronGeometry(1, 16);\n        const material = new three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial({\n            uniforms,\n            fragmentShader,\n            vertexShader,\n            side: three__WEBPACK_IMPORTED_MODULE_0__.DoubleSide\n        });\n        super(geometry, material);\n    }\n    set radius(radius) {\n        this.material.uniforms.radius.value = radius;\n    }\n    get radius() {\n        return this.material.uniforms.radius.value;\n    }\n    set height(height) {\n        this.material.uniforms.height.value = height;\n    }\n    get height() {\n        return this.material.uniforms.height.value;\n    }\n}\n //# sourceMappingURL=GroundProjectedEnv.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL29iamVjdHMvR3JvdW5kUHJvamVjdGVkRW52LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUE4RTtBQUMxQjtBQUNwRCxNQUFNSyxnQkFBZ0IsQ0FBQ0MsTUFBUUEsT0FBT0EsSUFBSUQsYUFBYTtBQUN2RCxNQUFNRSwyQkFBMkJQLHVDQUFJQTtJQUNuQ1EsWUFBWUMsT0FBTyxFQUFFQyxPQUFPLENBQUU7UUFDNUIsSUFBSUMsSUFBSUM7UUFDUixNQUFNQyxZQUFZUixjQUFjSTtRQUNoQyxNQUFNSyxJQUFJLENBQUNGLEtBQUtDLFlBQVksQ0FBQ0YsS0FBS0YsUUFBUU0sS0FBSyxDQUFDLEVBQUUsS0FBSyxPQUFPLEtBQUssSUFBSUosR0FBR0ssS0FBSyxHQUFHUCxRQUFRTSxLQUFLLENBQUNDLEtBQUssS0FBSyxPQUFPSixLQUFLO1FBQ3RILE1BQU1LLFdBQVdILElBQUk7UUFDckIsTUFBTUksVUFBVUMsS0FBS0MsS0FBSyxDQUFDRCxLQUFLRSxJQUFJLENBQUNKO1FBQ3JDLE1BQU1LLFlBQVlILEtBQUtJLEdBQUcsQ0FBQyxHQUFHTDtRQUM5QixNQUFNRixRQUFRLElBQUlHLEtBQUtLLEdBQUcsQ0FBQ0YsV0FBVyxLQUFLO1FBQzNDLE1BQU1HLFNBQVMsSUFBSUg7UUFDbkIsTUFBTUksVUFBVTtZQUNkYixZQUFZLDZCQUE2QjtZQUN6QyxDQUFDLDJCQUEyQixFQUFFLElBQUlHLE1BQU0sQ0FBQztZQUN6QyxDQUFDLDRCQUE0QixFQUFFLElBQUlTLE9BQU8sQ0FBQztZQUMzQyxDQUFDLHVCQUF1QixFQUFFUCxRQUFRLEVBQUUsQ0FBQztTQUN0QztRQUNELE1BQU1TLGVBQ0osUUFBUSxHQUNSLENBQUM7Ozs7Ozs7OztRQVNDLENBQUM7UUFFTCxNQUFNQyxpQkFBaUJGLFFBQVFHLElBQUksQ0FBQyxRQUFRLFFBQVEsR0FDcEQsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O3NCQXFFaUIsRUFBRXpCLDJEQUFPQSxJQUFJLE1BQU0sd0JBQXdCLHFCQUFxQjs7UUFFOUUsQ0FBQztRQUNMLE1BQU0wQixXQUFXO1lBQ2ZDLEtBQUs7Z0JBQUVDLE9BQU92QjtZQUFRO1lBQ3RCZ0IsUUFBUTtnQkFBRU8sT0FBTyxDQUFDdEIsV0FBVyxPQUFPLEtBQUssSUFBSUEsUUFBUWUsTUFBTSxLQUFLO1lBQUc7WUFDbkVRLFFBQVE7Z0JBQUVELE9BQU8sQ0FBQ3RCLFdBQVcsT0FBTyxLQUFLLElBQUlBLFFBQVF1QixNQUFNLEtBQUs7WUFBSTtRQUN0RTtRQUNBLE1BQU1DLFdBQVcsSUFBSWpDLHNEQUFtQkEsQ0FBQyxHQUFHO1FBQzVDLE1BQU1rQyxXQUFXLElBQUlqQyxpREFBY0EsQ0FBQztZQUNsQzRCO1lBQ0FGO1lBQ0FEO1lBQ0FTLE1BQU1qQyw2Q0FBVUE7UUFDbEI7UUFDQSxLQUFLLENBQUMrQixVQUFVQztJQUNsQjtJQUNBLElBQUlGLE9BQU9BLE1BQU0sRUFBRTtRQUNqQixJQUFJLENBQUNFLFFBQVEsQ0FBQ0wsUUFBUSxDQUFDRyxNQUFNLENBQUNELEtBQUssR0FBR0M7SUFDeEM7SUFDQSxJQUFJQSxTQUFTO1FBQ1gsT0FBTyxJQUFJLENBQUNFLFFBQVEsQ0FBQ0wsUUFBUSxDQUFDRyxNQUFNLENBQUNELEtBQUs7SUFDNUM7SUFDQSxJQUFJUCxPQUFPQSxNQUFNLEVBQUU7UUFDakIsSUFBSSxDQUFDVSxRQUFRLENBQUNMLFFBQVEsQ0FBQ0wsTUFBTSxDQUFDTyxLQUFLLEdBQUdQO0lBQ3hDO0lBQ0EsSUFBSUEsU0FBUztRQUNYLE9BQU8sSUFBSSxDQUFDVSxRQUFRLENBQUNMLFFBQVEsQ0FBQ0wsTUFBTSxDQUFDTyxLQUFLO0lBQzVDO0FBQ0Y7QUFHRSxDQUNGLDhDQUE4QyIsInNvdXJjZXMiOlsid2VicGFjazovL2JsdWVwcmludC10by0zZC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy90aHJlZS1zdGRsaWIvb2JqZWN0cy9Hcm91bmRQcm9qZWN0ZWRFbnYuanM/NjBiNSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBNZXNoLCBJY29zYWhlZHJvbkdlb21ldHJ5LCBTaGFkZXJNYXRlcmlhbCwgRG91YmxlU2lkZSB9IGZyb20gXCJ0aHJlZVwiO1xuaW1wb3J0IHsgdmVyc2lvbiB9IGZyb20gXCIuLi9fcG9seWZpbGwvY29uc3RhbnRzLmpzXCI7XG5jb25zdCBpc0N1YmVUZXh0dXJlID0gKGRlZikgPT4gZGVmICYmIGRlZi5pc0N1YmVUZXh0dXJlO1xuY2xhc3MgR3JvdW5kUHJvamVjdGVkRW52IGV4dGVuZHMgTWVzaCB7XG4gIGNvbnN0cnVjdG9yKHRleHR1cmUsIG9wdGlvbnMpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGNvbnN0IGlzQ3ViZU1hcCA9IGlzQ3ViZVRleHR1cmUodGV4dHVyZSk7XG4gICAgY29uc3QgdyA9IChfYiA9IGlzQ3ViZU1hcCA/IChfYSA9IHRleHR1cmUuaW1hZ2VbMF0pID09IG51bGwgPyB2b2lkIDAgOiBfYS53aWR0aCA6IHRleHR1cmUuaW1hZ2Uud2lkdGgpICE9IG51bGwgPyBfYiA6IDEwMjQ7XG4gICAgY29uc3QgY3ViZVNpemUgPSB3IC8gNDtcbiAgICBjb25zdCBfbG9kTWF4ID0gTWF0aC5mbG9vcihNYXRoLmxvZzIoY3ViZVNpemUpKTtcbiAgICBjb25zdCBfY3ViZVNpemUgPSBNYXRoLnBvdygyLCBfbG9kTWF4KTtcbiAgICBjb25zdCB3aWR0aCA9IDMgKiBNYXRoLm1heChfY3ViZVNpemUsIDE2ICogNyk7XG4gICAgY29uc3QgaGVpZ2h0ID0gNCAqIF9jdWJlU2l6ZTtcbiAgICBjb25zdCBkZWZpbmVzID0gW1xuICAgICAgaXNDdWJlTWFwID8gXCIjZGVmaW5lIEVOVk1BUF9UWVBFX0NVQkVcIiA6IFwiXCIsXG4gICAgICBgI2RlZmluZSBDVUJFVVZfVEVYRUxfV0lEVEggJHsxIC8gd2lkdGh9YCxcbiAgICAgIGAjZGVmaW5lIENVQkVVVl9URVhFTF9IRUlHSFQgJHsxIC8gaGVpZ2h0fWAsXG4gICAgICBgI2RlZmluZSBDVUJFVVZfTUFYX01JUCAke19sb2RNYXh9LjBgXG4gICAgXTtcbiAgICBjb25zdCB2ZXJ0ZXhTaGFkZXIgPSAoXG4gICAgICAvKiBnbHNsICovXG4gICAgICBgXG4gICAgICAgIHZhcnlpbmcgdmVjMyB2V29ybGRQb3NpdGlvbjtcbiAgICAgICAgdm9pZCBtYWluKCkgXG4gICAgICAgIHtcbiAgICAgICAgICAgIHZlYzQgd29ybGRQb3NpdGlvbiA9ICggbW9kZWxNYXRyaXggKiB2ZWM0KCBwb3NpdGlvbiwgMS4wICkgKTtcbiAgICAgICAgICAgIHZXb3JsZFBvc2l0aW9uID0gd29ybGRQb3NpdGlvbi54eXo7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG1vZGVsVmlld01hdHJpeCAqIHZlYzQoIHBvc2l0aW9uLCAxLjAgKTtcbiAgICAgICAgfVxuICAgICAgICBgXG4gICAgKTtcbiAgICBjb25zdCBmcmFnbWVudFNoYWRlciA9IGRlZmluZXMuam9pbihcIlxcblwiKSArIC8qIGdsc2wgKi9cbiAgICBgXG4gICAgICAgICNkZWZpbmUgRU5WTUFQX1RZUEVfQ1VCRV9VVlxuICAgICAgICB2YXJ5aW5nIHZlYzMgdldvcmxkUG9zaXRpb247XG4gICAgICAgIHVuaWZvcm0gZmxvYXQgcmFkaXVzO1xuICAgICAgICB1bmlmb3JtIGZsb2F0IGhlaWdodDtcbiAgICAgICAgdW5pZm9ybSBmbG9hdCBhbmdsZTtcbiAgICAgICAgI2lmZGVmIEVOVk1BUF9UWVBFX0NVQkVcbiAgICAgICAgICAgIHVuaWZvcm0gc2FtcGxlckN1YmUgbWFwO1xuICAgICAgICAjZWxzZVxuICAgICAgICAgICAgdW5pZm9ybSBzYW1wbGVyMkQgbWFwO1xuICAgICAgICAjZW5kaWZcbiAgICAgICAgLy8gRnJvbTogaHR0cHM6Ly93d3cuc2hhZGVydG95LmNvbS92aWV3LzR0c0JEN1xuICAgICAgICBmbG9hdCBkaXNrSW50ZXJzZWN0V2l0aEJhY2tGYWNlQ3VsbGluZyggdmVjMyBybywgdmVjMyByZCwgdmVjMyBjLCB2ZWMzIG4sIGZsb2F0IHIgKSBcbiAgICAgICAge1xuICAgICAgICAgICAgZmxvYXQgZCA9IGRvdCAoIHJkLCBuICk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmKCBkID4gMC4wICkgeyByZXR1cm4gMWU2OyB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHZlYzMgIG8gPSBybyAtIGM7XG4gICAgICAgICAgICBmbG9hdCB0ID0gLSBkb3QoIG4sIG8gKSAvIGQ7XG4gICAgICAgICAgICB2ZWMzICBxID0gbyArIHJkICogdDtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgcmV0dXJuICggZG90KCBxLCBxICkgPCByICogciApID8gdCA6IDFlNjtcbiAgICAgICAgfVxuICAgICAgICAvLyBGcm9tOiBodHRwczovL3d3dy5pcXVpbGV6bGVzLm9yZy93d3cvYXJ0aWNsZXMvaW50ZXJzZWN0b3JzL2ludGVyc2VjdG9ycy5odG1cbiAgICAgICAgZmxvYXQgc3BoZXJlSW50ZXJzZWN0KCB2ZWMzIHJvLCB2ZWMzIHJkLCB2ZWMzIGNlLCBmbG9hdCByYSApIFxuICAgICAgICB7XG4gICAgICAgICAgICB2ZWMzIG9jID0gcm8gLSBjZTtcbiAgICAgICAgICAgIGZsb2F0IGIgPSBkb3QoIG9jLCByZCApO1xuICAgICAgICAgICAgZmxvYXQgYyA9IGRvdCggb2MsIG9jICkgLSByYSAqIHJhO1xuICAgICAgICAgICAgZmxvYXQgaCA9IGIgKiBiIC0gYztcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYoIGggPCAwLjAgKSB7IHJldHVybiAtMS4wOyB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGggPSBzcXJ0KCBoICk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHJldHVybiAtIGIgKyBoO1xuICAgICAgICB9XG4gICAgICAgIHZlYzMgcHJvamVjdCgpIFxuICAgICAgICB7XG4gICAgICAgICAgICB2ZWMzIHAgPSBub3JtYWxpemUoIHZXb3JsZFBvc2l0aW9uICk7XG4gICAgICAgICAgICB2ZWMzIGNhbVBvcyA9IGNhbWVyYVBvc2l0aW9uO1xuICAgICAgICAgICAgY2FtUG9zLnkgLT0gaGVpZ2h0O1xuICAgICAgICAgICAgZmxvYXQgaW50ZXJzZWN0aW9uID0gc3BoZXJlSW50ZXJzZWN0KCBjYW1Qb3MsIHAsIHZlYzMoIDAuMCApLCByYWRpdXMgKTtcbiAgICAgICAgICAgIGlmKCBpbnRlcnNlY3Rpb24gPiAwLjAgKSB7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgdmVjMyBoID0gdmVjMyggMC4wLCAtIGhlaWdodCwgMC4wICk7XG4gICAgICAgICAgICAgICAgZmxvYXQgaW50ZXJzZWN0aW9uMiA9IGRpc2tJbnRlcnNlY3RXaXRoQmFja0ZhY2VDdWxsaW5nKCBjYW1Qb3MsIHAsIGgsIHZlYzMoIDAuMCwgMS4wLCAwLjAgKSwgcmFkaXVzICk7XG4gICAgICAgICAgICAgICAgcCA9ICggY2FtUG9zICsgbWluKCBpbnRlcnNlY3Rpb24sIGludGVyc2VjdGlvbjIgKSAqIHAgKSAvIHJhZGl1cztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcCA9IHZlYzMoIDAuMCwgMS4wLCAwLjAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwO1xuICAgICAgICB9XG4gICAgICAgICNpbmNsdWRlIDxjb21tb24+XG4gICAgICAgICNpbmNsdWRlIDxjdWJlX3V2X3JlZmxlY3Rpb25fZnJhZ21lbnQ+XG4gICAgICAgIHZvaWQgbWFpbigpIFxuICAgICAgICB7XG4gICAgICAgICAgICB2ZWMzIHByb2plY3RlZFdvcmxkUG9zaXRpb24gPSBwcm9qZWN0KCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgICNpZmRlZiBFTlZNQVBfVFlQRV9DVUJFXG4gICAgICAgICAgICAgICAgdmVjMyBvdXRjb2xvciA9IHRleHR1cmVDdWJlKCBtYXAsIHByb2plY3RlZFdvcmxkUG9zaXRpb24gKS5yZ2I7XG4gICAgICAgICAgICAjZWxzZVxuICAgICAgICAgICAgICAgIHZlYzMgZGlyZWN0aW9uID0gbm9ybWFsaXplKCBwcm9qZWN0ZWRXb3JsZFBvc2l0aW9uICk7XG4gICAgICAgICAgICAgICAgdmVjMiB1diA9IGVxdWlyZWN0VXYoIGRpcmVjdGlvbiApO1xuICAgICAgICAgICAgICAgIHZlYzMgb3V0Y29sb3IgPSB0ZXh0dXJlMkQoIG1hcCwgdXYgKS5yZ2I7XG4gICAgICAgICAgICAjZW5kaWZcbiAgICAgICAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoIG91dGNvbG9yLCAxLjAgKTtcbiAgICAgICAgICAgICNpbmNsdWRlIDx0b25lbWFwcGluZ19mcmFnbWVudD5cbiAgICAgICAgICAgICNpbmNsdWRlIDwke3ZlcnNpb24gPj0gMTU0ID8gXCJjb2xvcnNwYWNlX2ZyYWdtZW50XCIgOiBcImVuY29kaW5nc19mcmFnbWVudFwifT5cbiAgICAgICAgfVxuICAgICAgICBgO1xuICAgIGNvbnN0IHVuaWZvcm1zID0ge1xuICAgICAgbWFwOiB7IHZhbHVlOiB0ZXh0dXJlIH0sXG4gICAgICBoZWlnaHQ6IHsgdmFsdWU6IChvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmhlaWdodCkgfHwgMTUgfSxcbiAgICAgIHJhZGl1czogeyB2YWx1ZTogKG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMucmFkaXVzKSB8fCAxMDAgfVxuICAgIH07XG4gICAgY29uc3QgZ2VvbWV0cnkgPSBuZXcgSWNvc2FoZWRyb25HZW9tZXRyeSgxLCAxNik7XG4gICAgY29uc3QgbWF0ZXJpYWwgPSBuZXcgU2hhZGVyTWF0ZXJpYWwoe1xuICAgICAgdW5pZm9ybXMsXG4gICAgICBmcmFnbWVudFNoYWRlcixcbiAgICAgIHZlcnRleFNoYWRlcixcbiAgICAgIHNpZGU6IERvdWJsZVNpZGVcbiAgICB9KTtcbiAgICBzdXBlcihnZW9tZXRyeSwgbWF0ZXJpYWwpO1xuICB9XG4gIHNldCByYWRpdXMocmFkaXVzKSB7XG4gICAgdGhpcy5tYXRlcmlhbC51bmlmb3Jtcy5yYWRpdXMudmFsdWUgPSByYWRpdXM7XG4gIH1cbiAgZ2V0IHJhZGl1cygpIHtcbiAgICByZXR1cm4gdGhpcy5tYXRlcmlhbC51bmlmb3Jtcy5yYWRpdXMudmFsdWU7XG4gIH1cbiAgc2V0IGhlaWdodChoZWlnaHQpIHtcbiAgICB0aGlzLm1hdGVyaWFsLnVuaWZvcm1zLmhlaWdodC52YWx1ZSA9IGhlaWdodDtcbiAgfVxuICBnZXQgaGVpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLm1hdGVyaWFsLnVuaWZvcm1zLmhlaWdodC52YWx1ZTtcbiAgfVxufVxuZXhwb3J0IHtcbiAgR3JvdW5kUHJvamVjdGVkRW52XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9R3JvdW5kUHJvamVjdGVkRW52LmpzLm1hcFxuIl0sIm5hbWVzIjpbIk1lc2giLCJJY29zYWhlZHJvbkdlb21ldHJ5IiwiU2hhZGVyTWF0ZXJpYWwiLCJEb3VibGVTaWRlIiwidmVyc2lvbiIsImlzQ3ViZVRleHR1cmUiLCJkZWYiLCJHcm91bmRQcm9qZWN0ZWRFbnYiLCJjb25zdHJ1Y3RvciIsInRleHR1cmUiLCJvcHRpb25zIiwiX2EiLCJfYiIsImlzQ3ViZU1hcCIsInciLCJpbWFnZSIsIndpZHRoIiwiY3ViZVNpemUiLCJfbG9kTWF4IiwiTWF0aCIsImZsb29yIiwibG9nMiIsIl9jdWJlU2l6ZSIsInBvdyIsIm1heCIsImhlaWdodCIsImRlZmluZXMiLCJ2ZXJ0ZXhTaGFkZXIiLCJmcmFnbWVudFNoYWRlciIsImpvaW4iLCJ1bmlmb3JtcyIsIm1hcCIsInZhbHVlIiwicmFkaXVzIiwiZ2VvbWV0cnkiLCJtYXRlcmlhbCIsInNpZGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/three-stdlib/objects/GroundProjectedEnv.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/three-stdlib/shaders/HorizontalBlurShader.js":
/*!*******************************************************************!*\
  !*** ./node_modules/three-stdlib/shaders/HorizontalBlurShader.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HorizontalBlurShader: () => (/* binding */ HorizontalBlurShader)\n/* harmony export */ });\nconst HorizontalBlurShader = {\n    uniforms: {\n        tDiffuse: {\n            value: null\n        },\n        h: {\n            value: 1 / 512\n        }\n    },\n    vertexShader: /* glsl */ `\n      varying vec2 vUv;\n\n      void main() {\n\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n      }\n  `,\n    fragmentShader: /* glsl */ `\n    uniform sampler2D tDiffuse;\n    uniform float h;\n\n    varying vec2 vUv;\n\n    void main() {\n\n    \tvec4 sum = vec4( 0.0 );\n\n    \tsum += texture2D( tDiffuse, vec2( vUv.x - 4.0 * h, vUv.y ) ) * 0.051;\n    \tsum += texture2D( tDiffuse, vec2( vUv.x - 3.0 * h, vUv.y ) ) * 0.0918;\n    \tsum += texture2D( tDiffuse, vec2( vUv.x - 2.0 * h, vUv.y ) ) * 0.12245;\n    \tsum += texture2D( tDiffuse, vec2( vUv.x - 1.0 * h, vUv.y ) ) * 0.1531;\n    \tsum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;\n    \tsum += texture2D( tDiffuse, vec2( vUv.x + 1.0 * h, vUv.y ) ) * 0.1531;\n    \tsum += texture2D( tDiffuse, vec2( vUv.x + 2.0 * h, vUv.y ) ) * 0.12245;\n    \tsum += texture2D( tDiffuse, vec2( vUv.x + 3.0 * h, vUv.y ) ) * 0.0918;\n    \tsum += texture2D( tDiffuse, vec2( vUv.x + 4.0 * h, vUv.y ) ) * 0.051;\n\n    \tgl_FragColor = sum;\n\n    }\n  `\n};\n //# sourceMappingURL=HorizontalBlurShader.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL3NoYWRlcnMvSG9yaXpvbnRhbEJsdXJTaGFkZXIuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE1BQU1BLHVCQUF1QjtJQUMzQkMsVUFBVTtRQUNSQyxVQUFVO1lBQUVDLE9BQU87UUFBSztRQUN4QkMsR0FBRztZQUFFRCxPQUFPLElBQUk7UUFBSTtJQUN0QjtJQUNBRSxjQUNFLFFBQVEsR0FDUixDQUFDOzs7Ozs7Ozs7RUFTSCxDQUFDO0lBRURDLGdCQUNFLFFBQVEsR0FDUixDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztFQXVCSCxDQUFDO0FBRUg7QUFHRSxDQUNGLGdEQUFnRCIsInNvdXJjZXMiOlsid2VicGFjazovL2JsdWVwcmludC10by0zZC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy90aHJlZS1zdGRsaWIvc2hhZGVycy9Ib3Jpem9udGFsQmx1clNoYWRlci5qcz8wYmE4Il0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IEhvcml6b250YWxCbHVyU2hhZGVyID0ge1xuICB1bmlmb3Jtczoge1xuICAgIHREaWZmdXNlOiB7IHZhbHVlOiBudWxsIH0sXG4gICAgaDogeyB2YWx1ZTogMSAvIDUxMiB9XG4gIH0sXG4gIHZlcnRleFNoYWRlcjogKFxuICAgIC8qIGdsc2wgKi9cbiAgICBgXG4gICAgICB2YXJ5aW5nIHZlYzIgdlV2O1xuXG4gICAgICB2b2lkIG1haW4oKSB7XG5cbiAgICAgICAgdlV2ID0gdXY7XG4gICAgICAgIGdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG1vZGVsVmlld01hdHJpeCAqIHZlYzQoIHBvc2l0aW9uLCAxLjAgKTtcblxuICAgICAgfVxuICBgXG4gICksXG4gIGZyYWdtZW50U2hhZGVyOiAoXG4gICAgLyogZ2xzbCAqL1xuICAgIGBcbiAgICB1bmlmb3JtIHNhbXBsZXIyRCB0RGlmZnVzZTtcbiAgICB1bmlmb3JtIGZsb2F0IGg7XG5cbiAgICB2YXJ5aW5nIHZlYzIgdlV2O1xuXG4gICAgdm9pZCBtYWluKCkge1xuXG4gICAgXHR2ZWM0IHN1bSA9IHZlYzQoIDAuMCApO1xuXG4gICAgXHRzdW0gKz0gdGV4dHVyZTJEKCB0RGlmZnVzZSwgdmVjMiggdlV2LnggLSA0LjAgKiBoLCB2VXYueSApICkgKiAwLjA1MTtcbiAgICBcdHN1bSArPSB0ZXh0dXJlMkQoIHREaWZmdXNlLCB2ZWMyKCB2VXYueCAtIDMuMCAqIGgsIHZVdi55ICkgKSAqIDAuMDkxODtcbiAgICBcdHN1bSArPSB0ZXh0dXJlMkQoIHREaWZmdXNlLCB2ZWMyKCB2VXYueCAtIDIuMCAqIGgsIHZVdi55ICkgKSAqIDAuMTIyNDU7XG4gICAgXHRzdW0gKz0gdGV4dHVyZTJEKCB0RGlmZnVzZSwgdmVjMiggdlV2LnggLSAxLjAgKiBoLCB2VXYueSApICkgKiAwLjE1MzE7XG4gICAgXHRzdW0gKz0gdGV4dHVyZTJEKCB0RGlmZnVzZSwgdmVjMiggdlV2LngsIHZVdi55ICkgKSAqIDAuMTYzMztcbiAgICBcdHN1bSArPSB0ZXh0dXJlMkQoIHREaWZmdXNlLCB2ZWMyKCB2VXYueCArIDEuMCAqIGgsIHZVdi55ICkgKSAqIDAuMTUzMTtcbiAgICBcdHN1bSArPSB0ZXh0dXJlMkQoIHREaWZmdXNlLCB2ZWMyKCB2VXYueCArIDIuMCAqIGgsIHZVdi55ICkgKSAqIDAuMTIyNDU7XG4gICAgXHRzdW0gKz0gdGV4dHVyZTJEKCB0RGlmZnVzZSwgdmVjMiggdlV2LnggKyAzLjAgKiBoLCB2VXYueSApICkgKiAwLjA5MTg7XG4gICAgXHRzdW0gKz0gdGV4dHVyZTJEKCB0RGlmZnVzZSwgdmVjMiggdlV2LnggKyA0LjAgKiBoLCB2VXYueSApICkgKiAwLjA1MTtcblxuICAgIFx0Z2xfRnJhZ0NvbG9yID0gc3VtO1xuXG4gICAgfVxuICBgXG4gIClcbn07XG5leHBvcnQge1xuICBIb3Jpem9udGFsQmx1clNoYWRlclxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUhvcml6b250YWxCbHVyU2hhZGVyLmpzLm1hcFxuIl0sIm5hbWVzIjpbIkhvcml6b250YWxCbHVyU2hhZGVyIiwidW5pZm9ybXMiLCJ0RGlmZnVzZSIsInZhbHVlIiwiaCIsInZlcnRleFNoYWRlciIsImZyYWdtZW50U2hhZGVyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/three-stdlib/shaders/HorizontalBlurShader.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/three-stdlib/shaders/VerticalBlurShader.js":
/*!*****************************************************************!*\
  !*** ./node_modules/three-stdlib/shaders/VerticalBlurShader.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   VerticalBlurShader: () => (/* binding */ VerticalBlurShader)\n/* harmony export */ });\nconst VerticalBlurShader = {\n    uniforms: {\n        tDiffuse: {\n            value: null\n        },\n        v: {\n            value: 1 / 512\n        }\n    },\n    vertexShader: /* glsl */ `\n    varying vec2 vUv;\n\n    void main() {\n\n      vUv = uv;\n      gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n    }\n  `,\n    fragmentShader: /* glsl */ `\n\n  uniform sampler2D tDiffuse;\n  uniform float v;\n\n  varying vec2 vUv;\n\n  void main() {\n\n    vec4 sum = vec4( 0.0 );\n\n    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 4.0 * v ) ) * 0.051;\n    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 3.0 * v ) ) * 0.0918;\n    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 2.0 * v ) ) * 0.12245;\n    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 1.0 * v ) ) * 0.1531;\n    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;\n    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 1.0 * v ) ) * 0.1531;\n    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 2.0 * v ) ) * 0.12245;\n    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 3.0 * v ) ) * 0.0918;\n    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 4.0 * v ) ) * 0.051;\n\n    gl_FragColor = sum;\n\n  }\n  `\n};\n //# sourceMappingURL=VerticalBlurShader.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGhyZWUtc3RkbGliL3NoYWRlcnMvVmVydGljYWxCbHVyU2hhZGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxNQUFNQSxxQkFBcUI7SUFDekJDLFVBQVU7UUFDUkMsVUFBVTtZQUFFQyxPQUFPO1FBQUs7UUFDeEJDLEdBQUc7WUFBRUQsT0FBTyxJQUFJO1FBQUk7SUFDdEI7SUFDQUUsY0FDRSxRQUFRLEdBQ1IsQ0FBQzs7Ozs7Ozs7O0VBU0gsQ0FBQztJQUVEQyxnQkFDRSxRQUFRLEdBQ1IsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0VBd0JILENBQUM7QUFFSDtBQUdFLENBQ0YsOENBQThDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYmx1ZXByaW50LXRvLTNkLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL3RocmVlLXN0ZGxpYi9zaGFkZXJzL1ZlcnRpY2FsQmx1clNoYWRlci5qcz8yMTQyIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IFZlcnRpY2FsQmx1clNoYWRlciA9IHtcbiAgdW5pZm9ybXM6IHtcbiAgICB0RGlmZnVzZTogeyB2YWx1ZTogbnVsbCB9LFxuICAgIHY6IHsgdmFsdWU6IDEgLyA1MTIgfVxuICB9LFxuICB2ZXJ0ZXhTaGFkZXI6IChcbiAgICAvKiBnbHNsICovXG4gICAgYFxuICAgIHZhcnlpbmcgdmVjMiB2VXY7XG5cbiAgICB2b2lkIG1haW4oKSB7XG5cbiAgICAgIHZVdiA9IHV2O1xuICAgICAgZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbW9kZWxWaWV3TWF0cml4ICogdmVjNCggcG9zaXRpb24sIDEuMCApO1xuXG4gICAgfVxuICBgXG4gICksXG4gIGZyYWdtZW50U2hhZGVyOiAoXG4gICAgLyogZ2xzbCAqL1xuICAgIGBcblxuICB1bmlmb3JtIHNhbXBsZXIyRCB0RGlmZnVzZTtcbiAgdW5pZm9ybSBmbG9hdCB2O1xuXG4gIHZhcnlpbmcgdmVjMiB2VXY7XG5cbiAgdm9pZCBtYWluKCkge1xuXG4gICAgdmVjNCBzdW0gPSB2ZWM0KCAwLjAgKTtcblxuICAgIHN1bSArPSB0ZXh0dXJlMkQoIHREaWZmdXNlLCB2ZWMyKCB2VXYueCwgdlV2LnkgLSA0LjAgKiB2ICkgKSAqIDAuMDUxO1xuICAgIHN1bSArPSB0ZXh0dXJlMkQoIHREaWZmdXNlLCB2ZWMyKCB2VXYueCwgdlV2LnkgLSAzLjAgKiB2ICkgKSAqIDAuMDkxODtcbiAgICBzdW0gKz0gdGV4dHVyZTJEKCB0RGlmZnVzZSwgdmVjMiggdlV2LngsIHZVdi55IC0gMi4wICogdiApICkgKiAwLjEyMjQ1O1xuICAgIHN1bSArPSB0ZXh0dXJlMkQoIHREaWZmdXNlLCB2ZWMyKCB2VXYueCwgdlV2LnkgLSAxLjAgKiB2ICkgKSAqIDAuMTUzMTtcbiAgICBzdW0gKz0gdGV4dHVyZTJEKCB0RGlmZnVzZSwgdmVjMiggdlV2LngsIHZVdi55ICkgKSAqIDAuMTYzMztcbiAgICBzdW0gKz0gdGV4dHVyZTJEKCB0RGlmZnVzZSwgdmVjMiggdlV2LngsIHZVdi55ICsgMS4wICogdiApICkgKiAwLjE1MzE7XG4gICAgc3VtICs9IHRleHR1cmUyRCggdERpZmZ1c2UsIHZlYzIoIHZVdi54LCB2VXYueSArIDIuMCAqIHYgKSApICogMC4xMjI0NTtcbiAgICBzdW0gKz0gdGV4dHVyZTJEKCB0RGlmZnVzZSwgdmVjMiggdlV2LngsIHZVdi55ICsgMy4wICogdiApICkgKiAwLjA5MTg7XG4gICAgc3VtICs9IHRleHR1cmUyRCggdERpZmZ1c2UsIHZlYzIoIHZVdi54LCB2VXYueSArIDQuMCAqIHYgKSApICogMC4wNTE7XG5cbiAgICBnbF9GcmFnQ29sb3IgPSBzdW07XG5cbiAgfVxuICBgXG4gIClcbn07XG5leHBvcnQge1xuICBWZXJ0aWNhbEJsdXJTaGFkZXJcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1WZXJ0aWNhbEJsdXJTaGFkZXIuanMubWFwXG4iXSwibmFtZXMiOlsiVmVydGljYWxCbHVyU2hhZGVyIiwidW5pZm9ybXMiLCJ0RGlmZnVzZSIsInZhbHVlIiwidiIsInZlcnRleFNoYWRlciIsImZyYWdtZW50U2hhZGVyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/three-stdlib/shaders/VerticalBlurShader.js\n");

/***/ })

};
;